<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INFO505 Programmation C: TP3 - Mini-tetris graphique avec GTK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INFO505 Programmation C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP3 - Mini-tetris graphique avec GTK</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#TP3-intro">1 - Objectifs</a></li>
<li class="level1"><a href="#TP3-compilation-separee">2 - Compilation séparée</a><ul><li class="level2"><a href="#TP3-module-tetris">2.1 - Module tetris</a></li>
<li class="level2"><a href="#TP3-makefile">2.2 - Création d&#39;un makefile</a></li>
</ul>
</li>
<li class="level1"><a href="#TP3-fenetre">3 - L&#39;interface GTK</a><ul><li class="level2"><a href="#TP3-debut">3.1 - Première fenêtre</a></li>
<li class="level2"><a href="#TP3-bouton">3.2 - Premier bouton et réaction</a></li>
<li class="level2"><a href="#TP3-boutons">3.3 - Boîte pour mettre plusieurs composants</a></li>
<li class="level2"><a href="#TP3-mise_en_page">3.4 - Mise en page de l&#39;IHM</a></li>
<li class="level2"><a href="#TP3-reaction">3.5 - Ajouter une réaction</a></li>
<li class="level2"><a href="#TP3-donnees">3.6 - Accès à toutes les données</a></li>
</ul>
</li>
<li class="level1"><a href="#TP3-dessin">4 - Affichage du Tetris dans la zone de dessin.</a><ul><li class="level2"><a href="#TP3-expose">4.1 - Realize et draw events</a></li>
<li class="level2"><a href="#TP3-grille">4.2 - Dessin de la grille</a></li>
<li class="level2"><a href="#TP3-affichepiece">4.3 - Affichage de la pièce en attente</a></li>
<li class="level2"><a href="#TP3-deplacepiece">4.4 - Déplacement de la pièce</a></li>
<li class="level2"><a href="#TP3-placepiece">4.5 - Placement de la pièce</a></li>
</ul>
</li>
<li class="level1"><a href="#TP3-timer">5 - Un peu d&#39;action</a><ul><li class="level2"><a href="#TP3-reaction_timeout">5.1 - Réaction pour un time out</a></li>
<li class="level2"><a href="#TP3-touches">5.2 - Touches pour déplacer la pièce</a></li>
<li class="level2"><a href="#TP3-jeu_complet">5.3 - Jeu complet</a></li>
</ul>
</li>
<li class="level1"><a href="#TP3-divers">6 - Remise du tp</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="TP3-intro"></a>
1 - Objectifs</h1>
<p>L'objectif de ce TP est de rendre "graphique" votre Tetris "texte" mis au point lors du TP précédent (<a class="el" href="tp2.html">TP2 - Mini-projet Tetris simplifié</a>).</p>
<p>On va donc se servir d'une interface graphique classique, appelée GTK (<a href="http://www.gtk.org">http://www.gtk.org</a>). Cette interface, écrite en C, mais avec une philosophie objet, a été écrite pour réaliser le projet GIMP, qui est une très bonne alternative libre au logiciel de retouche d'image Photoshop. GTK est aussi à la base de l'environnement graphique GNOME.</p>
<p>On se servira aussi de Cairo (<a href="http://www.cairographics.org/">http://www.cairographics.org/</a>) qui est une bibliothèque très polyvalente pour du dessin vectoriel dans n'importe quel tampon (image, fichier svg, buffer OpenGL, et fenêtre). C'est depuis GTK+ 2.8 la façon officielle de faire du dessin dans les fenêtres.</p>
<p><b>Note</b> <b>importante</b>. Ce TP vous guide pas à pas pour que vous ayez les meilleures chances possibles de réussir un tetris graphique simplifié. Si vous trouvez ce canevas trop rigide, libre à vous de faire votre propre tetris graphique en suivant votre propre cheminement.</p>
<h1><a class="anchor" id="TP3-compilation-separee"></a>
2 - Compilation séparée</h1>
<p>On va réutiliser votre travail de la dernière fois. Pour bien faire les choses, on va faire des modules distincts. Le premier module sera la partie logique du Tetris, c'est-à-dire en gros votre dernier TP. Ce travail sera placé dans le module <code>tetris</code>, constitué du fichier entête <code>tetris.h</code> et du fichier source <code>tetris.c</code>. Le deuxième module sera la partie graphique du tetris et contiendra le programme principal. On créera donc un fichier <code><a class="el" href="gtktetris_8c_source.html">gtktetris.c</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Si vous êtes allé jusqu'au bout du TP2, vous pouvez utiliser normalement indifféremment la version "tableau" ou la version "liste" du TETRIS.</dd></dl>
<h2><a class="anchor" id="TP3-module-tetris"></a>
2.1 - Module tetris</h2>
<p>Vous récupérez votre TP de la dernière fois (version tableau ou liste, peu importe, du moment qu'elle fonctionne). Vous allez écrire un fichier <code>tetris.h</code> ne contenant que les prototypes des fonctions que vous avez écrite la dernière fois ainsi que les types de données.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef _TETRIS_H_</span></div>
<div class="line"><span class="preprocessor">#define _TETRIS_H_</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Constantes. */</span></div>
<div class="line"><span class="preprocessor">#define HAUTEUR 15</span></div>
<div class="line"><span class="preprocessor">#define LARGEUR 10</span></div>
<div class="line"><span class="preprocessor">#define NB_PIECES 3</span></div>
<div class="line"><span class="comment">/* ... */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Types. */</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">char</span> Grille[ HAUTEUR ][ LARGEUR ];</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structSPiece.html">SPiece</a> {</div>
<div class="line">} <a class="code hl_struct" href="structSPiece.html">Piece</a>;</div>
<div class="line"><span class="comment">/* ... */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Fonctions. */</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> genererPieces( <a class="code hl_struct" href="structSPiece.html">Piece</a> tabPiece[ NB_PIECES ] );</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> affichePieces( <a class="code hl_struct" href="structSPiece.html">Piece</a> p );</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">char</span> lireCase( Grille G, <span class="keywordtype">int</span> ligne, <span class="keywordtype">int</span> colonne );</div>
<div class="line"><span class="comment">/* ... */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">/* ifndef _TETRIS_H_ */</span><span class="preprocessor"></span></div>
<div class="ttc" id="astructSPiece_html"><div class="ttname"><a href="structSPiece.html">SPiece</a></div><div class="ttdef"><b>Definition</b> <a href="tetris-1_8h_source.html#l00012">tetris-1.h:12</a></div></div>
</div><!-- fragment --><p>Vous placerez ensuite les fonctions (prototypes et corps) dans un fichier <code>tetris.c</code>. Il faudra aussi enlever la fonction <code>main</code> car un programme C n'a qu'un seul <code>main</code>. Une façon élégante de le faire est de tout simplement renommer votre fonction <code>main</code>, par exemple en <code>main_console</code>. Enfin, il faudra inclure le fichier entête <code>tetris.h</code> au début de votre fichier <code>tetris.c</code>, juste après les inclusions d'entêtes systèmes.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;tetris.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> genererPieces( <a class="code hl_struct" href="structSPiece.html">Piece</a> tabPiece[ NB_PIECES ] )</div>
<div class="line">{</div>
<div class="line"> .... </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="TP3-makefile"></a>
2.2 - Création d'un makefile</h2>
<p>La commande <code>make</code> est un outil classique pour développer et compiler des programmes, notamment sur les systèmes UNIX. Cette commande regarde dans le répertoire où elle est lancé la présence d'un fichier <code>Makefile</code> ou <code>makefile</code>, et suit les directives écrites dedans. Créer donc le fichier <code>Makefile</code> avec:</p>
<pre class="fragment">CC=gcc
CFLAGS=-g -Wall -pedantic -std=c99

all: tetris.o

tetris.o: tetris.h tetris.c
	$(CC) -c $(CFLAGS) tetris.c</pre><p>Celui-ci compile simplement le fichier <code>tetris.c</code> en son fichier objet <code>tetris.o</code>. On voit que l'on peut définir des variables pour ensuite les utiliser.</p>
<p>On rajoute maintenant de quoi compiler notre futur programme <code>gtktetris</code>. Recopier ce mini-fichier source <code><a class="el" href="gtktetris_8c_source.html">gtktetris.c</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gtk/gtk.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;tetris.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span>   argc,</div>
<div class="line">          <span class="keywordtype">char</span> *argv[] )</div>
<div class="line">{</div>
<div class="line">  Grille g;</div>
<div class="line">  <a class="code hl_struct" href="structSPiece.html">Piece</a> tabPieces[ NB_PIECES ];</div>
<div class="line">  genererPieces( tabPieces );</div>
<div class="line">  initialiseGrille( g );</div>
<div class="line">  afficheGrille( g );</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Pour compiler <code>tetris.c</code> et <code><a class="el" href="gtktetris_8c_source.html">gtktetris.c</a></code> dans le même programme, on utilise maintenant le <code>makefile</code> suivant. On note qu'il nous permettra de compiler notre programme avec l'interface graphique GTK (ici version 3), même si pour l'instant on ne s'en sert pas.</p>
<pre class="fragment">CC=gcc
LD=gcc
CFLAGS=-g -Wall -pedantic -std=c99
GTKCFLAGS:=-g $(shell pkg-config --cflags gtk+-3.0)
GTKLIBS:=$(shell pkg-config --libs gtk+-3.0)

all: gtktetris

gtktetris: gtktetris.o tetris.o
	$(LD) gtktetris.o tetris.o -o gtktetris $(GTKLIBS)

gtktetris.o: gtktetris.c
	$(CC) -c $(CFLAGS) $(GTKCFLAGS) gtktetris.c

tetris.o: tetris.h tetris.c
	$(CC) -c $(CFLAGS) tetris.c

clean:
	rm -f gtktetris gtktetris.o tetris.o

</pre><p>Vérifier maintenant que la compilation fonctionne. Tapez maintenant <code>make</code> dans votre terminal. Il devrait afficher quelque chose ressemblant à ci-dessous. Vous pouvez vérifier que le programme <code>gtktetris</code> a bien été compilé. Si vous l'exécutez, cela affiche la grille sur le terminal, comme d'habitude.</p>
<div class="fragment"><div class="line"> $ make</div>
<div class="line">gcc -c -g -Wall -pedantic -std=c99 -g -I/opt/local/include/gtk-3.0 -I/opt/local/lib/gtk-3.0/include -I/opt/local/include/atk-1.0 -I/opt/local/include/cairo -I/opt/local/include/pango-1.0 -I/opt/local/include -I/opt/local/include/glib-3.0 -I/opt/local/lib/glib-3.0/include -I/opt/local/include/pixman-1 -I/opt/local/include/freetype2 -I/opt/local/include/libpng12   gtktetris.c</div>
<div class="line">gcc -c -g -Wall -pedantic -std=c99 tetris.c</div>
<div class="line">gcc -L/opt/local/lib -lgtk-x11-3.0 -lgdk-x11-3.0 -latk-1.0 -lgdk_pixbuf-3.0 -lpangocairo-1.0 -lgio-3.0 -lXinerama -lXi -lXrandr -lXcursor -lXcomposite -lXdamage -lpangoft2-1.0 -lXext -lXfixes -lcairo -lpixman-1 -lpng12 -lXrender -lX11 -lXau -lXdmcp -lpango-1.0 -lm -lfontconfig -lexpat -lfreetype -lz -lgobject-3.0 -lgmodule-3.0 -lglib-3.0 -lintl -liconv   gtktetris.o tetris.o -o gtktetris</div>
</div><!-- fragment --><p>La compilation est plus complexe car GTK utilise beaucoup de bibliothèques différentes (X, mais ausii cairo, pango, gdk, Xi, Xext, ...). Mais tout ceci se fait tout seul.</p>
<dl class="section note"><dt>Note</dt><dd>Le petit bout de code donné pour <code><a class="el" href="gtktetris_8c_source.html">gtktetris.c</a></code> est correct pour un type <code>Grille</code> qui est un tableau bidimensionnel. Si vous avez choisi une structure pour le type <code>Grille</code>, il faut passer la grille par <b>adresse</b>.</dd></dl>
<h1><a class="anchor" id="TP3-fenetre"></a>
3 - L'interface GTK</h1>
<p>Pour créer une interface graphique, GTK propose un système classique à base de composants. On dispose du type générique GtkWidget pour les désigner. La fenêtre (GtkWindow) est le composant dans lequel on place les autres. Certains composants peuvent contenir d'autres composants, on les appelle des conteneurs (GtkWindow est un conteneur ne contenant pas plus d'un composant, le GtkBox est un conteneur permettant de stocker autant d'autres composants que l'on souhaite). On dispose de plus de beaucoup de composants classiques pour les IHM : boutons, menus, checkbox, roulettes, zones de dessin, onglets, etc.</p>
<p>Ensuite, on associe à ces composants des <em>réactions</em> à certains événements. On pourra ainsi spécifier que la fonction <code>quitter</code> sera appelée lorsqu'on clique sur un bouton.</p>
<p>Une fois ces composants créés puis assemblés dans le bon ordre, on peut lancer l'application en donnant la main à GTK (appel de <code>gtk_main_loop</code>). Ce sera GTK qui appelera automatiquement nos <em>réactions</em> selon les événements induits par le comportement de l'utilisateur. On parle de <b>programmation</b> <b>événementielle</b>.</p>
<h2><a class="anchor" id="TP3-debut"></a>
3.1 - Première fenêtre</h2>
<p>Voilà un programme minimaliste pour créer une fenêtre GTK.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gtk/gtk.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;tetris.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span>   argc,</div>
<div class="line">          <span class="keywordtype">char</span> *argv[] )</div>
<div class="line">{</div>
<div class="line">    GtkWidget *window;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Passe les arguments à GTK, pour qu&#39;il extrait ceux qui le concernent. */</span></div>
<div class="line">    gtk_init (&amp;argc, &amp;argv);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Crée une fenêtre. */</span></div>
<div class="line">    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);</div>
<div class="line">    <span class="comment">/* La rend visible. */</span></div>
<div class="line">    gtk_widget_show  (window);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Rentre dans la boucle d&#39;événements. */</span></div>
<div class="line">    <span class="comment">/* Tapez Ctrl-C pour sortir du programme ! */</span></div>
<div class="line">    gtk_main ();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>On note qu'il faut un pointeur (de type <code>GtkWidget*</code>) pour pointer vers les composants créés. Chaque composant est créé avec une fonction de la forme <code>gtk_xxxx_new( ... )</code>, où xxxx désigne le type de composant voulu. Enfin, on doit appeler la fonction <code>gtk_widget_show</code> sur <b>chaque</b> composant créé pour le rendre visible. De la même façon, vous pouvez rendre invisible tout composant (et les composants qu'il contient) en appelant la fonction <code>gtk_widget_hide</code>.</p>
<p>Une fois tout en place, on appelle la boucle d'attente d'événements de GTK avec <code>gtk_main_loop</code>. Compilez et exécutez ce code. Notez qu'il faut interrompre le programme car rien n'est prévu pour quitter la boucle.</p>
<h2><a class="anchor" id="TP3-bouton"></a>
3.2 - Premier bouton et réaction</h2>
<p>On va créer un bouton (cliquable) avec <code>gtk_button_new_with_label</code>. Rajouter les lignes suivantes dans votre programme <b>avant</b> l'appel au <code>gtk_main_loop</code>.</p>
<div class="fragment"><div class="line">GtkWidget* button_quit;</div>
<div class="line"><span class="comment">// Crée le bouton.</span></div>
<div class="line">button_quit = gtk_button_new_with_label ( <span class="stringliteral">&quot;Quit&quot;</span> );</div>
<div class="line"><span class="comment">// Connecte la réaction gtk_main_quit à l&#39;événement &quot;clic&quot; sur ce bouton.</span></div>
<div class="line">g_signal_connect( button_quit, <span class="stringliteral">&quot;clicked&quot;</span>,</div>
<div class="line">                  G_CALLBACK( gtk_main_quit ),</div>
<div class="line">          NULL);</div>
<div class="line"><span class="comment">// Rajoute le bouton dans le conteneur window.</span></div>
<div class="line">gtk_container_add( GTK_CONTAINER( window ), button_quit );</div>
<div class="line"><span class="comment">// Rend visible le bouton.</span></div>
<div class="line">gtk_widget_show( button_quit );</div>
<div class="line"><span class="comment">// ... la suite</span></div>
</div><!-- fragment --><p>Vous avez maintenant une fenêtre composée d'un seul bouton. Si vous cliquez dessus, le programme se termine.</p>
<dl class="section note"><dt>Note</dt><dd><b>Important</b> ! Vous voyez qu'on a passé en paramètre un <b>nom</b> <b>de</b> <b>fonction</b> (via une macro <code>G_CALLBACK</code>). En fait, le programme passe l'<b>adresse</b> de la fonction comme argument. De son côté, la fonction <code>g_signal_connect</code> récupère cette adresse et la place dans un pointeur pour ensuite appeler cette fonction en réaction à l'événement "clic sur le bouton". On parle alors de <b>pointeur</b> <b>de</b> <b>fonction</b>, plutôt que de pointeur tout court, car le pointeur ne pointe pas sur des données mais sur l'<b>adresse</b> <b>du</b> <b>code</b> <b>assembleur</b> de la fonction.</dd></dl>
<div class="image">
<img src="gtktetris-3_2.png" alt=""/>
</div>
<h2><a class="anchor" id="TP3-boutons"></a>
3.3 - Boîte pour mettre plusieurs composants</h2>
<p>Comme une fenêtre ne contient qu'un composant au maximum, on place un autre composant (la boîte) dans la fenêtre et c'est dans cette boîte qu'on mettra plusieurs composants.</p>
<p>Les boîtes permettent de ranger des composants, mais ne rajoutent pas de décor autour des composants. Elles servent à mettre en page votre IHM. Il y a les boîtes horizontales (créées avec <code>gtk_box_new(GTK_ORIENTATION_HORIZONTAL,...)</code> pour placer les composants horizontalement et les boîtes verticales (créées avec <code>gtk_box_new(GTK_ORIENTATION_VERTICAL,...)</code>) pour placer les composants en vertical.</p>
<div class="fragment"><div class="line"><span class="comment">// FALSE: les composants internes n&#39;auront pas forcément la même largeur. </span></div>
<div class="line"><span class="comment">// TRUE: les composants internes auront forcément la même largeur. </span></div>
<div class="line"><span class="comment">// 10: bords autour des composants.</span></div>
<div class="line">GtkWidget* hbox1 = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 10);</div>
<div class="line"><span class="comment">// Crée un label</span></div>
<div class="line">GtkWidget* label = gtk_label_new( <span class="stringliteral">&quot;Grille TETRIS&quot;</span> );</div>
<div class="line">gtk_container_add ( GTK_CONTAINER (hbox1), label );</div>
</div><!-- fragment --><p>Ajouter maintenant aussi le bouton <code>button_quit</code> dans la boîte <code>hbox1</code>, ajouter la boîte dans la fenêtre <code>window</code>. N'oubliez pas de rendre visible tous les composants !</p>
<div class="image">
<img src="gtktetris-3_3.png" alt=""/>
</div>
<dl class="section note"><dt>Note</dt><dd>On peut rendre visible chaque composant avec <code>gtk_widget_show</code>. On peut rendre visible <b>tous</b> les composants contenus dans un conteneur avec <code>gtk_widget_show_all</code>.</dd></dl>
<h2><a class="anchor" id="TP3-mise_en_page"></a>
3.4 - Mise en page de l'IHM</h2>
<p>On se propose de faire la mise en page suivante pour notre IHM. Il vous faut créer autant de hbox et vbox nécessaires pour structurer cette mise en page. On note qu'il y aura des boutons (New, Quit et les 3 flèches), des labels (Score et Delay) et des labels qu'on va modifier (la valeur du score et le temps restant). Il y aura enfin une zone de dessin (GtkDrawingArea).</p>
<div class="image">
<img src="gtktetris-3_4.png" alt=""/>
</div>
<p>On va aussi créer des boutons flèches. On pourrait utiliser des petits icones, mais le plus simple est de faire des labels <code>"&lt;"</code>, <code>"v"</code>, <code>"&gt;"</code>. Pour faire un bouton flèche gauche, on écrit les lignes suivantes.</p>
<div class="fragment"><div class="line">GtkWidget* left = gtk_button_new_with_label( <span class="stringliteral">&quot;&lt;&quot;</span> );</div>
</div><!-- fragment --><p>Pour créer une zone de dessin de taille donnée, on fait ainsi.</p>
<div class="fragment"><div class="line">GtkWidget* drawing_area = gtk_drawing_area_new ();</div>
<div class="line"><span class="comment">// largeur=150 pixels, hauteur = 100 pixels.</span></div>
<div class="line">gtk_widget_set_size_request (drawing_area, 150, 100);</div>
</div><!-- fragment --><p>Vous définirez une constante TAILLE_CARRE qui vaut 16 et qui donne la taille de chaque carré de vos pièces de tetris. Il faudra donc créer une zone de dessin de largeur TAILLE_CARRE*(LARGEUR+4) et de hauteur TAILLE_CARRE*(HAUTEUR+7), car il faut prévoir la place pour le décor autour de la grille et pour la pièce qui arrive en haut.</p>
<p>Pour faire les choses un peu plus proprement, vous créerez une fonction <code>creerIHM()</code> pour créer tous ces composants et les mettre en page. Pour simplifier, les variables pointant vers les composants "utiles" pourront être globales au module (fenêtre, zone de dessin, label pour la valeur du score, label pour la valeur du delay).</p>
<dl class="section note"><dt>Note</dt><dd><b>Important</b> ! Ne passez pas 1h à mettre en page votre IHM. Faites un premier jet, même moche, et passez à la suite.</dd></dl>
<h2><a class="anchor" id="TP3-reaction"></a>
3.5 - Ajouter une réaction</h2>
<p>On peut écrire ses propres fonctions <em>réactions</em> pour les événements. Par exemple, si on veut que le bouton "gauche" appelle la fonction <code>Gauche</code> lorsqu'il est cliqué, on connecte le composant à cette fonction grâce à <code>g_signal_connect</code>. On note qu'on peut passer un pointeur en paramètre de plus.</p>
<div class="fragment"><div class="line">gboolean Gauche( GtkWidget *widget, gpointer data )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Recupère la valeur passée en paramètre.</span></div>
<div class="line">  <span class="keywordtype">int</span> val1 = * ( (<span class="keywordtype">int</span>*) data ); </div>
<div class="line">  printf( <span class="stringliteral">&quot;Gauche, val=%d\n&quot;</span>, val1 ); <span class="comment">// affichera 17</span></div>
<div class="line">  <span class="keywordflow">return</span> TRUE; <span class="comment">// Tout s&#39;est bien passé</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// variable globale</span></div>
<div class="line"><span class="keywordtype">int</span> val0 = 17;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">  g_signal_connect( button_left, <span class="stringliteral">&quot;clicked&quot;</span>,</div>
<div class="line">                G_CALLBACK( Gauche ), &amp;val0 );</div>
</div><!-- fragment --><p>Ecrivez des réactions similaires pour les boutons flèches gauche, bas, droite et "New". On les réécrira plus tard pour nos besoins. Il est important de remarquer que dans l'exemple ci-dessus, la valeur affichée est celle de <code>val0</code> lorsque le bouton sera cliqué, il est donc primordial que cette variable existe encore à ce moment là. On note que ce mécanisme de <code>réaction</code> est basé sur la notion de pointeur de fonction.</p>
<dl class="section note"><dt>Note</dt><dd>Comme la variable <code>val0</code> doit exister lorsque <code>Gauche</code> est appelé, ce ne peut être une variable définie dans le fonction <code>creerIHM</code>. <code>&amp;val0</code> doit désigner soit l'adresse d'une variable globale, soit l'adresse d'une variable définie dans la fonction appelante, i.e. la fonction <code>main</code>.</dd></dl>
<h2><a class="anchor" id="TP3-donnees"></a>
3.6 - Accès à toutes les données</h2>
<p>Nous allons avoir besoin d'accéder à la partie logique du jeu (grille tetris ainsi que pièces, score, autres) à partir de l'IHM. Or, dans les réactions que l'on va associer aux événements, une seule donnée (un pointeur) est envoyée en même temps. On va donc se créer un type qui rassemble toutes nos données en un seul endroit et on passera l'adresse d'une variable de ce type à toutes nos réactions.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">  Grille g;</div>
<div class="line">  <a class="code hl_struct" href="structSPiece.html">Piece</a> tab[ NB_PIECES ];</div>
<div class="line">  <span class="keywordtype">int</span> piece; <span class="comment">// la piece &quot;en cours&quot; que l&#39;on cherche à placer.</span></div>
<div class="line">  <span class="keywordtype">int</span> col; <span class="comment">// la colonne actuelle pour la pièce que l&#39;on cherche à caser.</span></div>
<div class="line">  <span class="keywordtype">int</span> score; <span class="comment">// le score</span></div>
<div class="line">  <span class="keywordtype">int</span> delay; <span class="comment">// le delay</span></div>
<div class="line">  <span class="comment">// ... peut-être d&#39;autres choses.</span></div>
<div class="line">} Jeu;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// déclaration</span></div>
<div class="line"><span class="keywordtype">void</span> creerIHM( Jeu* ptrJeu );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keywordtype">int</span> main( ... )</div>
<div class="line">{</div>
<div class="line">  Jeu jeu;</div>
<div class="line">  initialiseGrille( jeu.g );</div>
<div class="line">  <span class="comment">// initialiser les pièces et autres ...</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  creerIHM( &amp;jeu );</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// définition</span></div>
<div class="line"><span class="keywordtype">void</span> creerIHM( Jeu* ptrJeu )</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Il faudra donc rajouter un paramètre à <code>creerIHM</code>. Son prototype deviendra <code>void creerIHM( Jeu* ptrJeu )</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Dans la suite, vous aurez à mettre des pointeurs vers des <code>GtkWidget</code> dans la structure <code>Jeu</code>. Et <code>ptrJeu</code> sera la donnée que vous passerez aux différentes réactions/callbacks.</dd></dl>
<h1><a class="anchor" id="TP3-dessin"></a>
4 - Affichage du Tetris dans la zone de dessin.</h1>
<p>On va se servir de Cairo (<a href="http://www.cairographics.org/">http://www.cairographics.org/</a>) pour dessiner notre grille tetris ainsi que les pièces.</p>
<h2><a class="anchor" id="TP3-expose"></a>
4.1 - Realize et draw events</h2>
<p>Lorsqu'un composant est placé dans une fenêtre affichée à l'écran, il reçoit des signaux pour lui dire quand se réafficher. Cela arrive bien sûr la première fois que l'IHM est affichée, mais aussi par la suite si jamais la fenêtre a subie une occlusion partielle et doit donc être redessinée. Le composant GtkDrawingArea est par défaut rempli de gris, c'est tout ! On va donc se connecter aux signaux "realize" (appelé une seule fois lors du premier affichage) et "draw" (appelé régulièrement par le serveur de fenêtre) pour tracer notre tetris. On part donc du squelette suivant.</p>
<div class="fragment"><div class="line"> gboolean</div>
<div class="line"> realize_evt_reaction( GtkWidget *widget, gpointer data )</div>
<div class="line"> { <span class="comment">// force un événement &quot;draw&quot; juste derrière.</span></div>
<div class="line">   gtk_widget_queue_draw( widget ); </div>
<div class="line">   <span class="keywordflow">return</span> TRUE;</div>
<div class="line"> }</div>
<div class="line"> <span class="comment">// c&#39;est la réaction principale qui va redessiner tout.</span></div>
<div class="line"> gboolean</div>
<div class="line"> on_draw( GtkWidget *widget, GdkEventExpose *event, gpointer data )</div>
<div class="line"> {</div>
<div class="line">   <span class="comment">// Ces premières lignes permettent de récupérer la zone d&#39;affichage</span></div>
<div class="line">   <span class="comment">// et d&#39;initialiser un objet Cairographics cr qui permettra de dessiner</span></div>
<div class="line">   <span class="comment">// sur cette zone.</span></div>
<div class="line">   GdkWindow* window = gtk_widget_get_window(widget);</div>
<div class="line">   cairo_region_t* cairoRegion = cairo_region_create();</div>
<div class="line">   GdkDrawingContext* drawingContext</div>
<div class="line">     = gdk_window_begin_draw_frame( window, cairoRegion );</div>
<div class="line">   cairo_t* cr = gdk_drawing_context_get_cairo_context( drawingContext );</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// (A) maintenant je peux dessiner   </span></div>
<div class="line">   cairo_set_source_rgb (cr, 1, 1, 1); <span class="comment">// choisit le blanc.</span></div>
<div class="line">   cairo_paint( cr ); <span class="comment">// remplit tout dans la couleur choisie.</span></div>
<div class="line"> </div>
<div class="line">   cairo_set_source_rgb (cr, 0, 1, 0); <span class="comment">// choisit le vert</span></div>
<div class="line">   cairo_rectangle (cr, 50, 50, 100, 100 ); <span class="comment">// x, y, largeur, hauteur</span></div>
<div class="line">   cairo_fill_preserve( cr ); <span class="comment">// remplit la forme actuelle (un rectangle)</span></div>
<div class="line">   <span class="comment">// =&gt; &quot;_preserve&quot; garde la forme (le rectangle) pour la suite</span></div>
<div class="line"> </div>
<div class="line">   cairo_set_line_width(cr, 3);</div>
<div class="line">   cairo_set_source_rgb (cr, 0, 0.5, 0); <span class="comment">// choisit le vert sombre</span></div>
<div class="line">   cairo_stroke( cr ); <span class="comment">// trace la forme actuelle (le même rectangle)</span></div>
<div class="line">   <span class="comment">// =&gt; pas de &quot;_preserve&quot; donc la forme (le rectangle) est oublié.</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// (B) On a fini, on peut détruire la structure.</span></div>
<div class="line">   gdk_window_end_draw_frame(window,drawingContext);</div>
<div class="line">   <span class="comment">// cleanup</span></div>
<div class="line">   cairo_region_destroy(cairoRegion);</div>
<div class="line">   <span class="keywordflow">return</span> TRUE;</div>
<div class="line"> }</div>
<div class="line"><span class="comment">// Vous connectez ces réactions dans votre fonction creerIHM.</span></div>
<div class="line"><span class="keywordtype">void</span> creerIHM( Jeu* ptrJeu) {</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// ... votre zone de dessin s&#39;appelle ici &quot;drawing_area&quot;</span></div>
<div class="line">  g_signal_connect( G_OBJECT(drawing_area), <span class="stringliteral">&quot;realize&quot;</span>, </div>
<div class="line">            G_CALLBACK(realize_evt_reaction), ptrJeu );</div>
<div class="line">  g_signal_connect( G_OBJECT (drawing_area), <span class="stringliteral">&quot;draw&quot;</span>,</div>
<div class="line">                    G_CALLBACK (on_draw), ptrJeu );</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Maintenant, vous devriez voir à l'écran ceci lors de l'exécution.</p>
<div class="image">
<img src="gtktetris-4_1.png" alt=""/>
</div>
<h2><a class="anchor" id="TP3-grille"></a>
4.2 - Dessin de la grille</h2>
<p>Vous allez maintenant dessiner la grille en faisant un décor qui remplace les tubes '|' et en affichant un carré de couleur pour les pièces. Si cela vous amuse, vous pouvez les faire de différentes couleurs suivant vos choix pour les pièces (genre rouge pour '#', vert pour '@', etc). Les carrés seront donc de la taille TAILLE_CARRE * TAILLE_CARRE pixels. Pour plus de commandes sous cairo, allez voir <a href="http://cairographics.org/tutorial">http://cairographics.org/tutorial</a> .</p>
<p>Vous allez modifier ce qui est entre (A) et (B) au-dessus. <br  />
 Pour découper votre code, faites les fonctions</p>
<div class="fragment"><div class="line"><span class="comment">// Dessine le carré de type c à la ligne et colonne spécifiée dans le</span></div>
<div class="line"><span class="comment">// contexte graphique cr.</span></div>
<div class="line"><span class="keywordtype">void</span> dessineCarre( cairo_t* cr, <span class="keywordtype">int</span> ligne, <span class="keywordtype">int</span> colonne, <span class="keywordtype">char</span> c );</div>
<div class="line"><span class="comment">// Dessine toute la grille g dans le contexte graphique cr.</span></div>
<div class="line"><span class="keywordtype">void</span> dessineGrille( cairo_t* cr, Grille g );</div>
<div class="line"><span class="comment">// ....</span></div>
</div><!-- fragment --><p>On note qu'on récupère le pointeur vers le jeu dans la fonction <code>on_draw</code> en convertissant le pointeur <code>data</code> ainsi: </p><div class="fragment"><div class="line">Jeu* pJeu = (Jeu*) data;</div>
<div class="line"><span class="comment">// La grille est alors pJeu-&gt;g</span></div>
</div><!-- fragment --><p>Voilà un petit snapshot du jeu maintenant.</p>
<div class="image">
<img src="gtktetris-4_2.png" alt=""/>
</div>
<h2><a class="anchor" id="TP3-affichepiece"></a>
4.3 - Affichage de la pièce en attente</h2>
<p>On voit que, dans la structure Jeu, on mémorise la pièce courante ainsi que sa colonne courante. On va faire une fonction qui met à jour une structure Jeu en choisissant aléatoirement une nouvelle pièce courante et la place arbitrairement dans la colonne (LARGEUR-piece.largeur)/2. Appelons-là <code>nouvellePiece</code>.</p>
<p>Ecrivez ensuite la fonction <code>dessinePiece( cairo_t* cr, Jeu* pJeu )</code> qui l'affiche.</p>
<div class="image">
<img src="gtktetris-4_3.png" alt=""/>
</div>
<h2><a class="anchor" id="TP3-deplacepiece"></a>
4.4 - Déplacement de la pièce</h2>
<p>On peut maintenant écrire proprement les <em>réactions</em> <code>Gauche</code> et <code>Droite</code>. Elles doivent recevoir la donnée <code>jeu</code> aussi. Ensuite, leur seul rôle est de changer la colonne courante de la pièce, en la bloquant sur les bords. Il faut ensuite redessiner la <b>zone_de_dessin</b>. On procède alors de la même manière que dans <code>realize_evt_reaction</code>, c'est-à-dire avec la commande </p><div class="fragment"><div class="line">gtk_widget_queue_draw( window ); <span class="comment">// nb: drawing_area suffit</span></div>
</div><!-- fragment --><p>Chaque clic sur les flèches gauche ou droite doit maintenant réafficher votre pièce déplacée dans la bonne direction.</p>
<h2><a class="anchor" id="TP3-placepiece"></a>
4.5 - Placement de la pièce</h2>
<p>Il ne vous reste plus qu'à écrire la réaction au clic sur la flèche vers le bas, qui ne fait qu'appeler vos fonctions écrites dans le TP précédent (<code>hauteurMax</code> et <code>ecrirePiece</code>).</p>
<p>N'oubliez pas de rappeler ensuite <code>nouvellePiece</code> puis d'invalider la zone de dessin pour qu'elle soit réaffichée. Il faudrait aussi détecter les lignes complètes et les enlever.</p>
<p>Vous avez maintenant le même jeu de tetris qu'en mode texte !</p>
<h1><a class="anchor" id="TP3-timer"></a>
5 - Un peu d'action</h1>
<p>En général, le tetris donne un temps limité pour chaque pièce, sinon la pièce est placée pour vous (en fait elle descend d'un cran de plus en plus rapidement). On va faire quelque chose de similaire. On va juste laisser un temps à l'utilisateur au bout duquel, si l'utilisateur n'a pas appuyer sur la flèche bas, le jeu fait comme si vous avez appuyé sur la flèche vers le bas.</p>
<h2><a class="anchor" id="TP3-reaction_timeout"></a>
5.1 - Réaction pour un time out</h2>
<p>Il existe une façon très simple en GTK pour appeler une fonction spécifiée au bout d'un certain délai. Par exemple la fonction <code>tic</code> ci-dessous sera appelée toutes les 20ms, et recevra à chaque fois le pointeur vers le jeu.</p>
<div class="fragment"><div class="line">gint tic( gpointer data )</div>
<div class="line">{</div>
<div class="line">  Jeu* pJeu = (Jeu*) data;</div>
<div class="line">  printf( <span class="stringliteral">&quot;tic\n&quot;</span> );</div>
<div class="line">  g_timeout_add (20, tic, (gpointer) pJeu ); <span class="comment">// réenclenche le timer.</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// enclenche le timer pour se déclencher dans 20ms.</span></div>
<div class="line"><span class="comment">// (dans creerIHM)</span></div>
<div class="line">g_timeout_add (20, tic, (gpointer) ptrJeu );</div>
</div><!-- fragment --><p>Pour simplifier, on va supposer que le label pour le délai a été placé dans une variable globale du genre</p>
<div class="fragment"><div class="line">GtkWidget* valeur_delai;</div>
</div><!-- fragment --><p>En utilisant <code>gtk_label_set_text</code>( <code>GTK_LABEL</code>( <code>valeur_delai</code> ), <code>str</code> ), vous remplacez le texte stocké dans ce label par le contenu de la chaine de caractère <code>str</code>. On va donc stocker le délai courant dans la structure Jeu ainsi que le délai maximum redonné à chaque fois. Votre fonction <code>tic</code> doit décrémenter ce compteur délai et l'afficher. Lorsqu'il arrive à zéro, la réaction <code>Bas</code> doit être appelée et le compteur réinitialisé au délai maximum. Eventuellement, vous pouvez vous amuser à diminuer prgressivement le délai maximum, avec le même timer ou un autre timer.</p>
<div class="image">
<img src="gtktetris-5_1.png" alt=""/>
</div>
<h2><a class="anchor" id="TP3-touches"></a>
5.2 - Touches pour déplacer la pièce</h2>
<p>Le tetris sera beaucoup plus sympa à jouer si au lieu de cliquer sur les boutons, vous utilisez des touches pour déplacer les pièces. On peut mettre des événements "touches pressées" en Gtk/Gdk.</p>
<p>Il suffit de récupérer les symboles désignant les touches possibles en ajoutant <code>#include &lt;gdk/gdkkeysyms.h&gt;</code>, de connecter une réaction à l'événement <code>"key_press_event"</code>, et dans la réaction de gérer les touches et d'appeler les bonnes fonctions.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">  g_signal_connect (G_OBJECT (window), <span class="stringliteral">&quot;key_press_event&quot;</span>,</div>
<div class="line">                    G_CALLBACK (on_key_press), jeu );</div>
<div class="line">...</div>
<div class="line">gboolean</div>
<div class="line">on_key_press (GtkWidget *widget, GdkEventKey *event, gpointer user_data)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">switch</span> (event-&gt;keyval)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">case</span> GDK_KEY_Left:</div>
<div class="line">      Gauche( widget, user_data );</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="TP3-jeu_complet"></a>
5.3 - Jeu complet</h2>
<p>Il ne reste plus (!) qu'à fignoler le jeu.</p>
<ul>
<li>On peut mettre un booléen qui indique si une partie est en cours ou non. Cela permet de lancer un nouveau Jeu lorsqu'on clique sur New et de bloquer la partie lorsque le placement de la pièce dépasse le haut de la grille.</li>
<li>On peut changer le score à chaque pièce placée, ainsi qu'à chaque fois qu'on fait des lignes.</li>
<li>on peut s'occuper de la rotation des pièces. Il suffit de prévoir déjà les pièces qui sont rotations l'une de l'autre, de rajouter un bouton "rotation"/ touche "rotation" et de faire un tableau qui dit quel est l'indice de la pièce tournée.</li>
<li>on peut mettre des couleurs sympas...</li>
</ul>
<h1><a class="anchor" id="TP3-divers"></a>
6 - Remise du tp</h1>
<ul>
<li>Ce TP peut être fait par binôme.</li>
<li>A la fin de votre séance TP, vous m'enverrez votre TP via <a href="http://www.lama.univ-savoie.fr/TPLab">TPLab</a>. Ce mail devra contenir une archive nommée TP3-[votre ou vos nom(s)] contenant tous les fichiers sources, entêtes, makefile. Vous placerez un <b>README</b> précisant l'état d'avancement (ce qui marche, ce qui marche à moitié, et ce qui ne marche pas).</li>
<li>Vous m'enverrez la version finale de votre TP avant le <b>dimanche</b> <b>23</b> <b>octobre</b> <b>minuit</b> via <a href="https://www.lama.univ-savoie.fr/TPLab">TPLab</a>. Ce mail devra contenir une archive nommée TP3-[votre ou vos nom(s)] contenant tous les fichiers sources, entêtes, makefile. Vous complèterez le README en précisant l'état d'avancement (ce qui marche, ce qui marche à moitié, et ce qui ne marche pas) <b>relativement</b> à la version initiale.</li>
<li>Bien entendu, il faut que vos programmes compilent sous Linux lorsque j'écris <code>make</code> dans le terminal. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 24 2023 19:35:42 for INFO505 Programmation C by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
