<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INFO505 Programmation C: TP2 - Mini-projet Tetris simplifié</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INFO505 Programmation C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP2 - Mini-projet Tetris simplifié</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#TP2-intro">1 - Objectifs</a></li>
<li class="level1"><a href="#TP2-jeu">2 - Une version simplifiée du jeu Tetris</a></li>
<li class="level1"><a href="#TP2-prog">3 - Réalisation du programme en C</a><ul><li class="level2"><a href="#TP2-constantes">3.1 - Constantes</a></li>
<li class="level2"><a href="#TP2-types">3.2 - Nouveaux types</a></li>
<li class="level2"><a href="#TP2-affichage">3.3 - Initialisation et affichage de la grille</a></li>
<li class="level2"><a href="#TP2-pieces">3.4 - Génération et affichage des pièces</a></li>
<li class="level2"><a href="#TP2-ecriture">3.5 - Écriture dans la grille</a></li>
<li class="level2"><a href="#TP2-lecture">3.6 - Lecture des entrées</a></li>
<li class="level2"><a href="#TP2-fin">3.7 - Détection de la fin de la partie</a></li>
<li class="level2"><a href="#TP2-effacement">3.8 - Effacement de lignes</a></li>
<li class="level2"><a href="#TP2-pieces-complexes">3.9 - Pièces générales</a></li>
<li class="level2"><a href="#TP2-tourner-les-pieces">3.10 - Tourner les pieces</a></li>
</ul>
</li>
<li class="level1"><a href="#TP2-liste">4 - Implémentation à l&#39;aide d&#39;une liste chaînée</a></li>
<li class="level1"><a href="#TP2-bonus">5 - Améliorations optionnelles</a></li>
<li class="level1"><a href="#TP2-divers">6 - Notes</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="TP2-intro"></a>
1 - Objectifs</h1>
<p>L'objectif de ce TP, ainsi que du prochain, est de réaliser une version simplifiée du jeu Tetris. Si vous ne connaissez pas ce jeu, vous pouvez en apprendre les principes à l'adresse :</p>
<p><a href="http://fr.wikipedia.org/wiki/Tetris">http://fr.wikipedia.org/wiki/Tetris</a></p>
<p>Il est important de LIRE ATTENTIVEMENT ET EN ENTIER CE DOCUMENT AVANT DE COMMENCER A CODER!!</p>
<p>L'idée ici est de faire un jeu Tetris console, qui codera toute la logique du jeu, sans les aspects graphiques ni temps réel. Ces deux derniers aspects seront traités dans le TP suivant (<a class="el" href="tp3.html">TP3 - Mini-tetris graphique avec GTK</a>). Ici, l'objectif est de vous faire travailler sur les structures de données, avec d'abord une représentation <b>tableau</b> <b>à</b> <b>2</b> <b>dimensions</b>, puis ensuite une représentation <b>liste</b>, pour stocker la grille du tetris.</p>
<p>Plusieurs contraintes sur la structure de votre programme vous sont imposées.</p>
<p>Pour ce TP, vous devrez remettre au moins trois fichiers sous forme d'archive: <code>tp2-tableau.c</code>, <code>tp2-liste.c</code>, et un <code>README.txt</code>. Les points suivants seront évalués :</p>
<ul>
<li>Le README.txt <em>doit</em> indiquer quelles questions vous avez complètement traitées, et quelles questions ont été abordées (en précisant les problèmes ou erreurs). Vous perdrez des points sans ce fichier README, où si les informations données ne coincident pas avec le code rendu.</li>
<li>La lisibilité de votre programme (choix pertinent pour les noms de variables, indentation, etc.),</li>
<li>Chaque fichier devra comporter un commentaire au début avec vos nom, prénom, filière, intitulé du cours et numéro de TP,</li>
<li>Votre code devra compiler avec <code>gcc</code> sans erreurs ni warnings, et fonctionner sous Linux.</li>
<li>Toute mémoire allouée devra être libérée.</li>
<li>Ce TP peut être fait par binôme (mais mettez les deux noms !).</li>
<li>Vous m'enverrez une première version de votre TP à la fin de votre séance de TP (dépend des groupes), via <a href="https://tplab.apps.math.cnrs.fr">TPLab</a>. Vous aurez 7 jours ensuite pour envoyer une version finale (dépend des groupes aussi). Il faudra une archive (ZIP, ou TAR.GZ) nommée TP2-[votre ou vos nom(s)] contenant tous les fichiers sources, entêtes, le README mis à jour, éventuellement un makefile.</li>
</ul>
<h1><a class="anchor" id="TP2-jeu"></a>
2 - Une version simplifiée du jeu Tetris</h1>
<p>Dans le cadre de ce TP, le jeu sera implémenté uniquement en texte et son déroulement se fera entièrement dans le terminal. Vous aurez ainsi toute la partie logique du jeu qui fonctionne à la fin du TP. Pour cette partie, vous écrirez tout dans un fichier <code>tp2-[votre nom]-tableau.c</code></p>
<dl class="section note"><dt>Note</dt><dd>Vous étofferez votre jeu en mode graphique temps-réel à la séance suivante.</dd></dl>
<p>Tout d'abord nous allons simplifier grandement le déroulement du jeu.</p>
<ol type="1">
<li>L'interactivité du jeu sera réduite au minimum :</li>
</ol>
<ul>
<li>La lecture du clavier étant effectuée à l'aide de la commande "scanf" aucun délai n'est imposé au joueur.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> colonne;</div>
<div class="line">scanf( <span class="stringliteral">&quot;%d&quot;</span>, &amp;colonne );</div>
</div><!-- fragment --><ul>
<li><p class="startli">Lorsqu'un joueur a choisi la colonne dans laquelle faire tomber la pièce, celle-ci est directement ajouté à la position la plus basse qu'elle peut atteindre.</p>
<p class="startli">Voici un exemple : </p><div class="fragment"><div class="line">         @ </div>
<div class="line">        @@@</div>
<div class="line">        ↑</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  |||||||||||||||||||</div>
<div class="line">    012345678901234</div>
<div class="line"> </div>
<div class="line">Dans quelle colonne placer cette piece?</div>
<div class="line">&gt; </div>
</div><!-- fragment --></li>
</ul>
<p>Si le joueur choisit, par exemple, la colonne 8 alors la pièce est insérée de manière à ce que sa colonne la plus à gauche (celle indiquée par une flèche dans l'exemple) soit dans la colonne #8.</p>
<div class="fragment"><div class="line">Dans quelle colonne placer cette piece?</div>
<div class="line">&gt; 8  </div>
<div class="line"> </div>
<div class="line">         l</div>
<div class="line">         l</div>
<div class="line">         l</div>
<div class="line">         l</div>
<div class="line">         ↑</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||               ||</div>
<div class="line">  ||         @     ||</div>
<div class="line">  ||        @@@    ||</div>
<div class="line">  |||||||||||||||||||</div>
<div class="line">    012345678901234</div>
<div class="line"> </div>
<div class="line">Dans quelle colonne placer cette piece?</div>
<div class="line">&gt; </div>
</div><!-- fragment --><p>Par convention, la grille de jeu est modélisée de <b>bas</b> <b>en</b> <b>haut</b>, c'est-à-dire que la <b>ligne</b> <b>0</b> <b>est</b> <b>en</b> <b>bas</b>, la ligne 1 est juste au-dessus, etc. Attention, pour l'affichage sur la console, il faudra donc partir de la dernière ligne et afficher jusqu'à la première ligne. Ci-dessous, vous avez à gauche le numéro de ligne et en bas le numéro de colonne de chaque case. Les barres <code>|</code> ne font pas partie de la grille et sont juste affichés.</p>
<div class="fragment"><div class="line">9 ||               ||</div>
<div class="line">8 ||               ||</div>
<div class="line">7 ||               ||</div>
<div class="line">6 ||               ||</div>
<div class="line">5 ||               ||</div>
<div class="line">4 ||               ||</div>
<div class="line">3 ||               ||</div>
<div class="line">2 ||               ||</div>
<div class="line">1 ||         @     ||</div>
<div class="line">0 ||        @@@    ||</div>
<div class="line">  |||||||||||||||||||</div>
<div class="line">    0         1    </div>
<div class="line">    012345678901234</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Dans un <b>premier</b> <b>temps</b>, les pièces sont dessinées de manière à ce que la ligne la plus basse soit continue et au moins aussi large que toutes les autres au-dessus.</dd></dl>
<div class="fragment"><div class="line">     l</div>
<div class="line">     l      R                  LL  Z         </div>
<div class="line"> @   l  $$  R             @@@   L  ZZ       </div>
<div class="line">@@@  l  $$  RR ...         @    L   Z       </div>
<div class="line"> </div>
<div class="line">pièces valides         pièces non-valides</div>
</div><!-- fragment --><p>Comme nous le verrons plus tard, cette contrainte simplifie grandement le positionnement des pièces.</p>
<p>Remarques :</p><ul>
<li>Les bords de la grille de jeu sont représentés par le symbole <code>'|'</code> (pipe)</li>
<li>Les pièces sont représentées à l'aide de n'importe quels caractères autre qu'un espace (<code>' '</code>) ou un pipe (<code>'|'</code>).</li>
</ul>
<h1><a class="anchor" id="TP2-prog"></a>
3 - Réalisation du programme en C</h1>
<h2><a class="anchor" id="TP2-constantes"></a>
3.1 - Constantes</h2>
<p>Déclarez 4 constantes avec la directive <code>#define</code> :</p><ul>
<li>HAUTEUR : le nombre de lignes de l'espace de jeu. On la fixe à 10.</li>
<li>LARGEUR : le nombre de colonnes de l'espace de jeu. On la fixe à 15.</li>
<li>NB_PIECES : le nombre de pièces différentes. À fixer en fonction du nombre de pièces que vous déciderez d'include.</li>
<li>HAUTEUR_MAX_DES_PIECES : le nombre maximum de lignes qui peut occuper une pièce. On fixe cette valeur à 4. <div class="fragment"><div class="line"><span class="preprocessor">#define HAUTEUR 4</span></div>
<div class="line">...</div>
<div class="line">typedef <span class="keywordtype">char</span> Grille[ HAUTEUR ][ LARGEUR ];</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="TP2-types"></a>
3.2 - Nouveaux types</h2>
<ul>
<li><code>Piece</code> : une struct contenant les champs suivants<ul>
<li><code>hauteur</code> : le nombre de lignes qu'occupe la pièce.</li>
<li><code>largeur</code> : le nombre de colonnes qu'occupe la pièce.</li>
<li><code>forme</code> : un tableau de chaînes de caractères, permettant de dessiner la pièce. Ce sera un tableau de HAUTEUR_MAX_DES_PIECES cases, chaque case étant de type <code>char*</code>, qui pointe donc vers une chaîne de caractères.</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structSPiece.html">SPiece</a> {</div>
<div class="line">  <span class="keywordtype">int</span>   hauteur;</div>
<div class="line">  <span class="keywordtype">int</span>   largeur;</div>
<div class="line">  <span class="keywordtype">char</span>* forme[ HAUTEUR_MAX_DES_PIECES ];</div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structSPiece.html">SPiece</a> <a class="code hl_struct" href="structSPiece.html">Piece</a>;</div>
<div class="ttc" id="astructSPiece_html"><div class="ttname"><a href="structSPiece.html">SPiece</a></div><div class="ttdef"><b>Definition</b> <a href="tetris-1_8h_source.html#l00013">tetris-1.h:13</a></div></div>
</div><!-- fragment --><ul>
<li><code>Grille</code> : Un tableau bidimensionnel de caractères qui représente l'espace de jeu.</li>
</ul>
<h2><a class="anchor" id="TP2-affichage"></a>
3.3 - Initialisation et affichage de la grille</h2>
<ul>
<li>Écrivez une procédure <code>void initialiseGrille( Grille G )</code> qui remplit une grille de jeu <code>G</code> passé en paramètre avec le caractère <code>' '</code> (espace).</li>
<li>Écrivez une procédure <code>char lireCase( Grille G, int i, int j )</code> qui, pour une grille, un numéro de ligne et un numéro de colonne passés en paramètre, retourne le contenu de la case correspondante de cette grille. Vous devez toujours utiliser cette procédure lorsque vous voulez lire le contenu d'une case la grille de jeu. Ajoutez dans cette procédure un test vérifiant que la ligne et la colonne sont valides. Si tel n'est pas le cas, une erreur doit être affichée.</li>
<li>Écrivez une procédure <code>void afficheGrille( Grille G )</code> afin d'afficher le contenu d'une grille donnée en entrée en l'encadrant à gauche, à droite et en dessous avec le caractère <code>'|'</code> (pipe). Ajoutez également des nombres qui indiquent le numéro de chacune des colonnes (voir l'exemple plus haut).</li>
<li><p class="startli">Écrivez une procédure <code>main</code> qui vous permet de tester le fonctionnement des deux procédures précédentes. C'est au début du <code>main</code> qu'il faudra instancier une grille.</p>
<p class="startli"><b>TESTEZ</b> <b>VOTRE</b> <b>PROGRAMME</b> <b>À</b> <b>CHAQUE</b> <b>ÉTAPE</b> <b>DE</b> <b>SON</b> <b>DÉVELOPPEMENT!!</b> </p>
</li>
</ul>
<h2><a class="anchor" id="TP2-pieces"></a>
3.4 - Génération et affichage des pièces</h2>
<ul>
<li>Écrivez une procédure <code>générerPieces</code> qui initialise un tableau de pièce avec chacune des pièces qui apparaîtront dans le jeu. Les pièces sont écrites une par une "à la main" dans cette fonction. Voici un exemple d'initilisation de pièces : <div class="fragment"><div class="line">tabPiece[0].hauteur = 4;</div>
<div class="line">tabPiece[0].largeur = 1;</div>
<div class="line">tabPiece[0].forme[3] = <span class="stringliteral">&quot;I&quot;</span>;</div>
<div class="line">tabPiece[0].forme[2] = <span class="stringliteral">&quot;I&quot;</span>;</div>
<div class="line">tabPiece[0].forme[1] = <span class="stringliteral">&quot;I&quot;</span>;</div>
<div class="line">tabPiece[0].forme[0] = <span class="stringliteral">&quot;I&quot;</span>;</div>
<div class="line">tabPiece[1].hauteur = 2;</div>
<div class="line">tabPiece[1].largeur = 3;</div>
<div class="line">tabPiece[1].forme[1] = <span class="stringliteral">&quot; @ &quot;</span>;</div>
<div class="line">tabPiece[1].forme[0] = <span class="stringliteral">&quot;@@@&quot;</span>;</div>
<div class="line">...</div>
</div><!-- fragment --></li>
</ul>
<p>Il est important que chacune des chaînes de caractères du tableau <code>forme</code> aient exactement la même taille, cette taille étant la valeur donnée au champs <code>largeur</code> (1 ou 3 dans cet exemple). Votre jeu doit fournir au moins cinq pièces différentes, à vous de décider lesquelles. Notez que comme le joueur ne peut pas <b>encore</b> tourner les pièces, les quatre pièces suivantes sont considérées comme étant différentes :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#         #        </span></div>
<div class="line"><span class="preprocessor">#         #         #        #</span></div>
<div class="line"><span class="preprocessor">##       ##       ###        ###</span></div>
</div><!-- fragment --><ul>
<li>Faites impérativement la pièce verticale de 4 et la pièce 2x2, elles sont bien pratiques pour tester le tetris. <pre class="fragment">l
l
l    %%
l    %%
</pre></li>
<li>Écrivez une procédure <code>affichePiece</code> qui affiche une pièce passée en paramètre et ajoute une flèche (ou tout autre symbole) sous la colonne la plus à gauche de manière à indiquer au joueur où sera inséré la pièce. <div class="fragment"><div class="line"> @ </div>
<div class="line">@@@</div>
<div class="line">↑</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="TP2-ecriture"></a>
3.5 - Écriture dans la grille</h2>
<ul>
<li>Écrivez une procédure <code>void ecrireCase( Grille G, int i, int j,
     char c )</code> qui, pour une grille, un numéro de ligne et un numéro de colonne passés en paramètre, inscrit dans la case correspondante de la grille de jeu un caractère également spécifié en paramètre. Vous devez toujours utiliser cette procédure pour écrire dans la grille de jeu. Il est là aussi fortement conseillé de tester la validité des numéros de ligne et colonne et d'afficher une erreur dans le cas contraire.</li>
</ul>
<p>Lorsqu'un joueur décide de placer une pièce dans une colonne donnée, il faut être en mesure de déterminer à quelle hauteur la pièce sera déposée. On a imposé une forme particulière aux pièces de manière à simplifier cette étape. Comme la ligne la plus basse d'une pièce est forcément la plus large, il suffit de déterminer, pour chacune des colonnes que va occuper cette pièce, quelle est hauteur de la plus haute case occupée.</p>
<ul>
<li>Écrivez une procédure <code>int hauteurPlat( Grille g, int c1, int c2
     )</code> qui, étant donné une grille et un intervalle de colonnes, retourne la ligne la plus basse où on peut placer une pièce sans écraser une pièce déjà placée. C'est équivalent à retourner un plus la hauteur maximale où se trouve une case occupée entre les colonnes spécifiées. Cette procédure sera mise à jour dans un <b>deuxième</b> <b>temps</b> pour prendre en compte des pièces plus complexes (voir <code>hauteurExacte</code> plus loin).</li>
<li>Écrivez une procédure <code>void ecrirePiece( Grille G, Piece P, int
     c, int h )</code> qui reçoit en paramètre une grille, une pièce, un numéro de colonne ainsi qu'une hauteur et ajoute cette pièce à la grille de manière à ce que la colonne la plus à gauche de la pièce corresponde au numéro de colonne spécifiée. <dl class="section warning"><dt>Warning</dt><dd>Faites bien attention à ne <b>rien</b> <b>écrire</b> là où la pièce est vide (ie. un espace). Ce sera important pour la section <a class="el" href="tp2.html#TP2-pieces-complexes">3.9 - Pièces générales</a>.</dd></dl>
</li>
</ul>
<h2><a class="anchor" id="TP2-lecture"></a>
3.6 - Lecture des entrées</h2>
<ul>
<li>Écrivez une procédure <code>pieceAleatoire</code> qui choisit une pièce au hasard parmi celles que vous avez définies. Pour choisir un nombre aléatoirement dans l'ensemble {0,1,2,...,n-1} on peut utiliser la commande suivante : <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line">...</div>
<div class="line">int alea = (int)(((<span class="keywordtype">double</span>)rand()/((<span class="keywordtype">double</span>)RAND_MAX)) * (NB_PIECES));</div>
</div><!-- fragment --></li>
<li>Modifiez la fonction <code>main</code> en y ajoutant une boucle principale de manière à :<ul>
<li>Afficher une pièce choisie aléatoirement,</li>
<li>Affiche la grille de jeu,</li>
<li>Demande à l'utilisateur d'entrer le numéro de la colonne où il veut mettre la pièce,</li>
<li>Ajoute la pièce à la grille de jeu.</li>
<li>Répéter les étapes précédentes jusqu'à ce que l'utilisateur entre la valeur -1 indiquant qu'il souhaite quitter le programme.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Vous noterez que l'aléatoire ne semble pas si aléatoire que ça, avec toujours la même suite de pièces successives. C'est voulu ! En fait, ce sont des suites pseudo-aléatoires, c'est-à-dire qu'elles donnent des résultats déterministes. Si on veut un peu plus d'aléatoire, on change alors la graine (<em>seed</em> en anglais) du générateur pseudo-aléatoire pour l'initialiser à une valeur différente à chaque run. Par exemple, on peut mettre au début de la fonction <code>main</code> : <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;time.h&gt;</span></div>
<div class="line">...</div>
<div class="line">int main(...)</div>
<div class="line">{</div>
<div class="line">  srand( time( NULL ) );</div>
<div class="line">  ...</div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="TP2-fin"></a>
3.7 - Détection de la fin de la partie</h2>
<ul>
<li>Modifiez votre code de manière à ce qu'avant de faire une appel à <code>ecrirePiece</code> votre programme détecte si la pièce va dépasser de la grille de jeu. Si tel est le cas, on affiche un message informant le joueur qu'il a perdu la partie ainsi que le nombre de pièces qu'il a réussi à placer. La grille est alors réinitialisée et une nouvelle partie démarre.</li>
</ul>
<h2><a class="anchor" id="TP2-effacement"></a>
3.8 - Effacement de lignes</h2>
<ul>
<li>Écrivez une procédure <code>void supprimerLigne( Grille G, int i )</code> qui efface le contenu d'une ligne dont le numéro est passé en paramètre et fait descendre toutes celles au-dessus. Plus précisément, lorsqu'une ligne est <code>supprimée</code>, le contenu de chacune des lignes au dessus de celle-ci doit être recopié dans la ligne d'en dessous et la ligne la plus haute de la grille de jeu est remplacée par une ligne vide.</li>
<li>Écrivez une fonction <code>int nettoyer( Grille G )</code> qui supprime toutes les lignes ne contenant aucune case vide et qui retourne le nombre de lignes supprimées (utile si on veut gérer le score).</li>
<li>Modifiez votre code de manière à ce qu'à chaque fois que le joueur place une pièce, un appel à <code>nettoyer</code> soit effectué.</li>
</ul>
<p>Vous devriez avoir maintenant une version <em>jouable</em>. Malheureusement, les pièces étant toutes plus larges à la base, vous allez voir qu'il est difficile de gagner à ce Tetris.</p>
<h2><a class="anchor" id="TP2-pieces-complexes"></a>
3.9 - Pièces générales</h2>
<p>On autorise maintenant le type de pièces ci-dessous: </p><div class="fragment"><div class="line">                      LL                  Z         </div>
<div class="line">@@@                    L                  ZZ       </div>
<div class="line"> @                     L                   Z       </div>
</div><!-- fragment --><p>Il n'est plus suffisant d'utiliser <code>hauteurPlat</code> pour détecter la position où va tomber la pièce. On peut juste dire que <code>hauteurPlat</code> donne la "pire" hauteur possible, mais potentiellement la pièce peut aller plus bas. Ecrivez donc la fonction</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> hauteurExacte( Grille g, <span class="keywordtype">int</span> col_gauche, <a class="code hl_struct" href="structSPiece.html">Piece</a>* piece );</div>
</div><!-- fragment --><p>qui vous retourne cette hauteur exacte. Substituez ensuite <code>hauteurExacte</code> à <code>hauteurMax</code> dans le code. Si la procédure <code>ecrirePiece</code> est correctement écrite, alors cela devrait fonctionner du premier coup.</p>
<dl class="section note"><dt>Note</dt><dd>L'idée est de calculer colonne par colonne de la pièce à quelle hauteur on peut poser la pièce. Ensuite, la hauteur où on peut poser est le maximum des hauteurs calculées pour chaque colonne. <pre class="fragment">H   01      colonne piece
    ##        0 : hauteur_grille(2+0) = 3, hauteur_piece(0) = 2
     #          =&gt; hauteur_exacte(0) = 3 - 2 = 1
     #        1 : hauteur_grille(2+1) = 2, hauteur_piece(1) = 0
                =&gt; hauteur_exacte(1) = 2 - 0 = 2
3        L    =&gt; hauteur_exacte = max(1,2) = 2
2  AA  AAL
1  LLLLAAL
0 BBAABBAA
  01234567  colonne grille     
</pre></dd></dl>
<h2><a class="anchor" id="TP2-tourner-les-pieces"></a>
3.10 - Tourner les pieces</h2>
<p>On peut aussi implémenter les rotations. Cela se fait simplement en créant les rotations d'une pièce comme autant de pièces différentes. On mémorise ensuite dans un tableau <code>rotD</code> que la rotation d'une pièce à droite donne le numéro d'une autre pièce et similairement avec un tableau <code>rotG</code>. Enfin, l'utilisateur tape 'g' ou 'd' pour tourner la pièce avant de choisir la colonne. La lecture au clavier se fera plutôt en lisant une chaîne de caractères et en l'analysant. En pseudo-code, ça peut ressembler à ça:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">int colonne;</div>
<div class="line"><span class="keywordtype">char</span> str[ 8 ];</div>
<div class="line"><span class="keywordflow">while</span> ( 1 ) {</div>
<div class="line">  printf( <span class="stringliteral">&quot;(g)auche, (d)roite ou (0-14) colonne: &quot;</span> );</div>
<div class="line">  <span class="keywordflow">if</span> ( scanf( <span class="stringliteral">&quot;%7s&quot;</span>, str ) == 1 ) {</div>
<div class="line">  <span class="keywordflow">if</span> ( str[ 0 ] == <span class="charliteral">&#39;g&#39;</span> ) {  tourne à gauche la piece }</div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( str[ 0 ] == <span class="charliteral">&#39;d&#39;</span> ) {  tourne à droite la piece }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    colonne = atoi( str );</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">  réaffiche la pièce</div>
<div class="line">}</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Les tableaux rotD et rotG sont de simples tableaux d'entiers, pour aller de numéro de pièces en numéro de pièces. Par exemple, dans la situation suivante, on aurait :</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">      #                ##        </span></div>
<div class="line"><span class="preprocessor">      #         #       #       ###      %%</span></div>
<div class="line"><span class="preprocessor">      ##      ###       #       #        %%   ...</span></div>
<div class="line">n°    0        1        2        3        4</div>
<div class="line">rotG  1        2        3        0        4</div>
<div class="line">rotD  3        0        1        2        4   ...</div>
</div><!-- fragment --><h1><a class="anchor" id="TP2-liste"></a>
4 - Implémentation à l'aide d'une liste chaînée</h1>
<p>Cette partie est à faire dans un deuxième temps, une fois que le tetris "tableau" fonctionne (en effet, il servira pour le tetris graphique).</p>
<p>On propose une autre structure de données pour représenter la grille de jeu, où chaque ligne est indépendante des autres et où elles sont placées dans une liste chaînée. Ainsi, lorsqu'une ou plusieurs lignes seront supprimées, il suffira de supprimer un ou des éléments de la liste, les autres lignes seront donc automatiquement déplacées. Pour cela, nous allons remplacer le tableau servant à représenter la grille de jeu par une liste doublement chaînée.</p>
<ul>
<li>Commencez par effectuer une copie de sauvegarde de votre code. Appelez ce fichier <div class="fragment"><div class="line">tp2-[votre nom]-tableau.c</div>
</div><!-- fragment --></li>
</ul>
<p>Avant de modifier votre code, récupérez les codes suivants (<a class="el" href="Liste_8h_source.html">Liste.h</a>, <a class="el" href="Liste_8c_source.html">Liste.c</a>, <a class="el" href="test-Liste_8c_source.html">test-Liste.c</a>), compilez-les avec </p><div class="fragment"><div class="line">gcc <a class="code hl_struct" href="structSCellule.html">Liste</a>.c test-<a class="code hl_struct" href="structSCellule.html">Liste</a>.c -o test-<a class="code hl_struct" href="structSCellule.html">Liste</a></div>
<div class="ttc" id="astructSCellule_html"><div class="ttname"><a href="structSCellule.html">SCellule</a></div><div class="ttdoc">Definit le noeud d'une liste doublement chaînée.</div><div class="ttdef"><b>Definition</b> <a href="Liste_8h_source.html#l00007">Liste.h:7</a></div></div>
</div><!-- fragment --><p> et exécutez le programme.</p>
<div class="fragment"><div class="line"><span class="comment">// Liste.h</span></div>
<div class="line"><span class="preprocessor">#ifndef _LISTE_H_</span></div>
<div class="line"><span class="preprocessor">#define _LISTE_H_</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span> Elem; <span class="comment">/* Vous changerez après ce type lorsque vous l&#39;utiliserez pour le tetris */</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structSCellule.html">SCellule</a> {</div>
<div class="line">  Elem <a class="code hl_variable" href="structSCellule.html#aab31abf2ed6304a9e6ceb3aa68cf004f">val</a>;              </div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_struct" href="structSCellule.html">SCellule</a>* <a class="code hl_variable" href="structSCellule.html#a1576730f6dcd1fcc991c530a881e0cee">pred</a>; </div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_struct" href="structSCellule.html">SCellule</a>* <a class="code hl_variable" href="structSCellule.html#a85dbda377fba8d78b94e2a886623b62b">succ</a>; </div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structSCellule.html">SCellule</a> <a class="code hl_struct" href="structSCellule.html">Cellule</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_struct" href="structSCellule.html">Cellule</a>* <a class="code hl_struct" href="structSCellule.html">Adr</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_struct" href="structSCellule.html">Cellule</a> <a class="code hl_struct" href="structSCellule.html">Liste</a>; </div>
<div class="line"><span class="comment">/* Ici, la liste vide est une liste avec un élément (non utilisé). */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* alloue dynamiquement une liste et retourne son adresse */</span></div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_struct" href="structSCellule.html">Liste</a>* Liste_creer();</div>
<div class="line"><span class="comment">/* initialise correctement la liste donnée en paramètre, comme si elle était vide. */</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> Liste_init( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L );</div>
<div class="line"><span class="comment">/* détruit tous les éléments stockés dans la liste L. La liste est vide après.*/</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> Liste_termine( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L );</div>
<div class="line"><span class="comment">/* détruit tous les éléments stockés dans la liste L, et libère l&#39;espace mémoire de la liste. */</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> Liste_detruire( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L );</div>
<div class="line"><span class="comment">/* retourne l&#39;adresse du premier élément. */</span></div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_struct" href="structSCellule.html">Adr</a> Liste_debut( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L );</div>
<div class="line"><span class="comment">/* retourne l&#39;adresse après le dernier élément. */</span></div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_struct" href="structSCellule.html">Adr</a> Liste_fin( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L );</div>
<div class="line"><span class="comment">/* passe à l&#39;élément suivant. */</span></div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_struct" href="structSCellule.html">Adr</a> Liste_suivant( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A );</div>
<div class="line"><span class="comment">/* passe à l&#39;élément précédent. */</span></div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_struct" href="structSCellule.html">Adr</a> Liste_precedent( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A );</div>
<div class="line"><span class="comment">/* insère devant l&#39;élément A un nouvel élément de valeur v dans L. */</span></div>
<div class="line"><span class="keyword">extern</span> <a class="code hl_struct" href="structSCellule.html">Adr</a> Liste_insere( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A, Elem v );</div>
<div class="line"><span class="comment">/* supprime l&#39;élément A dans L. */</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> Liste_supprime( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A );</div>
<div class="line"><span class="comment">/* retourne la valeur stockée dans l&#39;élément A de la liste L. */</span></div>
<div class="line"><span class="keyword">extern</span> Elem Liste_valeur( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A );</div>
<div class="line"><span class="comment">/* modifie la valeur stockée dans l&#39;élément A de la liste L, en lui assignant la valeur v. */</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> Liste_modifie( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A, Elem v );</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="ttc" id="astructSCellule_html_a1576730f6dcd1fcc991c530a881e0cee"><div class="ttname"><a href="structSCellule.html#a1576730f6dcd1fcc991c530a881e0cee">SCellule::pred</a></div><div class="ttdeci">struct SCellule * pred</div><div class="ttdoc">pointeur vers le noeud précédent</div><div class="ttdef"><b>Definition</b> <a href="Liste_8h_source.html#l00009">Liste.h:9</a></div></div>
<div class="ttc" id="astructSCellule_html_a85dbda377fba8d78b94e2a886623b62b"><div class="ttname"><a href="structSCellule.html#a85dbda377fba8d78b94e2a886623b62b">SCellule::succ</a></div><div class="ttdeci">struct SCellule * succ</div><div class="ttdoc">pointeur vers le noeud suivant</div><div class="ttdef"><b>Definition</b> <a href="Liste_8h_source.html#l00010">Liste.h:10</a></div></div>
<div class="ttc" id="astructSCellule_html_aab31abf2ed6304a9e6ceb3aa68cf004f"><div class="ttname"><a href="structSCellule.html#aab31abf2ed6304a9e6ceb3aa68cf004f">SCellule::val</a></div><div class="ttdeci">Elem val</div><div class="ttdoc">valeur stockée dans le noeud</div><div class="ttdef"><b>Definition</b> <a href="Liste_8h_source.html#l00008">Liste.h:8</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Liste.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Liste.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structSCellule.html">Liste</a>* Liste_creer()</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structSCellule.html">Liste</a>* L = (<a class="code hl_struct" href="structSCellule.html">Liste</a>*) malloc( <span class="keyword">sizeof</span>( <a class="code hl_struct" href="structSCellule.html">Liste</a> ) );</div>
<div class="line">  Liste_init( L );</div>
<div class="line">  <span class="keywordflow">return</span> L;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Liste_init( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L )</div>
<div class="line">{</div>
<div class="line">  L-&gt;<a class="code hl_variable" href="structSCellule.html#a85dbda377fba8d78b94e2a886623b62b">succ</a> = L;</div>
<div class="line">  L-&gt;<a class="code hl_variable" href="structSCellule.html#a1576730f6dcd1fcc991c530a881e0cee">pred</a> = L;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Liste_termine( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">while</span> ( Liste_debut( L ) != Liste_fin( L ) )</div>
<div class="line">    Liste_supprime( L, Liste_debut( L ) );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Liste_detruire( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L )</div>
<div class="line">{</div>
<div class="line">  Liste_termine( L );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structSCellule.html">Adr</a> Liste_debut( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> L-&gt;<a class="code hl_variable" href="structSCellule.html#a85dbda377fba8d78b94e2a886623b62b">succ</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structSCellule.html">Adr</a> Liste_fin( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> L;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structSCellule.html">Adr</a> Liste_suivant( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> A-&gt;<a class="code hl_variable" href="structSCellule.html#a85dbda377fba8d78b94e2a886623b62b">succ</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structSCellule.html">Adr</a> Liste_precedent( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> A-&gt;<a class="code hl_variable" href="structSCellule.html#a1576730f6dcd1fcc991c530a881e0cee">pred</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structSCellule.html">Adr</a> Liste_insere( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A, Elem v )</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structSCellule.html">Adr</a> ncell = (<a class="code hl_struct" href="structSCellule.html">Adr</a>) malloc( <span class="keyword">sizeof</span>( <a class="code hl_struct" href="structSCellule.html">Cellule</a> ) );</div>
<div class="line">  ncell-&gt;<a class="code hl_variable" href="structSCellule.html#aab31abf2ed6304a9e6ceb3aa68cf004f">val</a> = v;</div>
<div class="line">  ncell-&gt;<a class="code hl_variable" href="structSCellule.html#a85dbda377fba8d78b94e2a886623b62b">succ</a> = A;</div>
<div class="line">  <span class="keywordflow">return</span> ncell;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Liste_supprime( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A )</div>
<div class="line">{</div>
<div class="line">  A-&gt;<a class="code hl_variable" href="structSCellule.html#a1576730f6dcd1fcc991c530a881e0cee">pred</a>-&gt;<a class="code hl_variable" href="structSCellule.html#a85dbda377fba8d78b94e2a886623b62b">succ</a> = A-&gt;<a class="code hl_variable" href="structSCellule.html#a85dbda377fba8d78b94e2a886623b62b">succ</a>;</div>
<div class="line">  A-&gt;<a class="code hl_variable" href="structSCellule.html#a85dbda377fba8d78b94e2a886623b62b">succ</a>-&gt;<a class="code hl_variable" href="structSCellule.html#a1576730f6dcd1fcc991c530a881e0cee">pred</a> = A-&gt;<a class="code hl_variable" href="structSCellule.html#a1576730f6dcd1fcc991c530a881e0cee">pred</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Elem Liste_valeur( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> A-&gt;<a class="code hl_variable" href="structSCellule.html#aab31abf2ed6304a9e6ceb3aa68cf004f">val</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Liste_modifie( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L, <a class="code hl_struct" href="structSCellule.html">Adr</a> A, Elem v )</div>
<div class="line">{</div>
<div class="line">  A-&gt;<a class="code hl_variable" href="structSCellule.html#aab31abf2ed6304a9e6ceb3aa68cf004f">val</a> = v;</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// test-Liste.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Liste.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> affiche( <a class="code hl_struct" href="structSCellule.html">Liste</a>* L )</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structSCellule.html">Adr</a> A;</div>
<div class="line">  <span class="keywordflow">for</span> ( A = Liste_debut( L );</div>
<div class="line">    A != Liste_fin( L );</div>
<div class="line">    A = Liste_suivant( L, A ) ) {</div>
<div class="line">    printf( <span class="stringliteral">&quot;%f &quot;</span>, Liste_valeur( L, A ) );</div>
<div class="line">  }</div>
<div class="line">  printf( <span class="stringliteral">&quot;\n&quot;</span> );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structSCellule.html">Liste</a>* L = Liste_creer( );</div>
<div class="line">  <a class="code hl_struct" href="structSCellule.html">Adr</a> A = Liste_debut( L );</div>
<div class="line">  <span class="keywordtype">double</span> x = 1.0;</div>
<div class="line">  <span class="keywordflow">while</span> ( x &lt; 100000.0 )</div>
<div class="line">    {</div>
<div class="line">      A = Liste_insere( L, A, x );</div>
<div class="line">      A = Liste_suivant( L, A );</div>
<div class="line">      x = 1.5*x;</div>
<div class="line">    }</div>
<div class="line">  affiche( L );</div>
<div class="line">  Liste_detruire( L );</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
</div><!-- fragment --><p>On constate que, contrairement à ce que l'on espérerait, la commande <code>affiche(L)</code> n'affiche rien du tout.</p>
<ul>
<li>Utilisez un débogueur (par exemple : ddd), afin de corriger cette implémentation de liste chaînées.</li>
<li>Assurez-vous que ces listes libèrent toute la mémoire allouée en utilisant l'outil <code>valgrind</code> de la manière suivante :</li>
</ul>
<div class="fragment"><div class="line">valgrind --leak-check=full ./test-<a class="code hl_struct" href="structSCellule.html">Liste</a></div>
</div><!-- fragment --><p>Lorsque vos listes fonctionnent correctement, vous pouvez les adapter afin de les utiliser pour représenter efficacement la grille de jeu de votre Tetris. Chaque noeud de votre liste représentera une ligne du jeu tetris, la première ligne (celle du bas) étant la première cellule utile de votre liste chaînée. Supprimer une ligne se fera donc en supprimant la cellule correspondante et vous devrez rajouter une ligne composée d'espaces en fin de liste. Voilà à quoi ressemble votre liste pour représenter le tetris ci-contre.</p>
<pre class="fragment">||        ||
...
||   l    ||
||  @l$$  ||
|| @@@$$  ||
</pre><div class="image">
<img src="liste-chainee-tetris-small.png" alt=""/>
</div>
<ul>
<li>Définissez un type pour représenter chacune des lignes de la grille de jeu.</li>
<li>Redéfinissez le type Grille de manière à remplacer le tableau par une liste chaînée dont chaque cellule représente une ligne de la grille.</li>
</ul>
<p>À ce stade, la compilation de votre programme échouera. C'est normal. Il faut maintenant modifier les procédures qui manipulent la grille de jeu.</p>
<ul>
<li>Afin de pouvoir compiler votre code, commentez le corps des procédures <code>ecrireCase</code> et <code>lireCase</code>. Il peut s'avérer pratique d'ajouter un return bidon (ex : <code>return</code> ' ';) à la procédure lireCase.</li>
</ul>
<p>Votre programme devrait maintenant compiler à nouveau tout en restant inutilisable.</p>
<ul>
<li>Écrivez une procédure <code>construireGrille</code> qui construit la grille de jeu.</li>
<li>Écrivez une procédure <code>détruireGrille</code> qui libère la mémoire occupée par la grille.</li>
<li>Modifiez le corps des procédures <code>lireCase</code> et <code>ecrireCase</code> afin de les adapter à la nouvelle structure de données employée pour la grille de jeu. Ces dexu procédures nécessite de parcourir la liste pour arriver à la bonne ligne.</li>
</ul>
<p>Votre programme devrait maintenant être redevenu fonctionnel.</p>
<ul>
<li>Modifier le corps de la procédure <code>supprimerLigne</code> de manière à ne plus recopier la grille case par case mais plutôt en supprimant l'élément approprié de la liste chaînée et en ajoutant une nouvelle ligne vide en bout de liste.</li>
<li><p class="startli">Renommez votre fichier source</p>
<div class="fragment"><div class="line">tp2-[votre nom]-liste.c</div>
</div><!-- fragment --></li>
<li>Tout devrait fonctionner.</li>
<li>Si vous avez terminé les étapes précédentes et que tout fonctionne bien, vous pouvez améliorer votre code en modifiant les procédures <code>afficherGrille</code>, <code>initialiser</code>, <code>ecrirePiece</code> et <code>hauteurMax</code> afin de remplacer les appels à <code>ecrireCase</code>, <code>lireCase</code> par une utilisation séquentielle de la liste chaînée.</li>
</ul>
<h1><a class="anchor" id="TP2-bonus"></a>
5 - Améliorations optionnelles</h1>
<ul>
<li>Vous pouvez rajouter des couleurs sur votre console, voir par exemple le TP précédent (<a class="el" href="tp1.html#onze">11 - Génération de terrain sur grille hexagonale</a>) qui vous met un joli tableau des couleurs possibles.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#define COLOR(X) printf(&quot;\033[&quot;X&quot;m&quot;)</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// essayez 40, 41, 42, 43 ... et 0 pour revenir à par défaut.</span></div>
<div class="line">if (c == <span class="charliteral">&#39;#&#39;</span>) { COLOR(<span class="stringliteral">&quot;41&quot;</span>); printf( <span class="stringliteral">&quot; &quot;</span> ); }</div>
</div><!-- fragment --><ul>
<li>N'oubliez pas de faire un certain nombre de pièces distinctes, c'est plus sympa pour jouer.</li>
<li>Vous pouvez apporter tout autre modification qui rendra votre programme plus semblable au <code>vrai</code> Tetris ;-): toutes les pièces, score (en fonction du nombre de lignes supprimé en même temps). L'aspect temps réél sera abordé dans le TP suivant.</li>
</ul>
<h1><a class="anchor" id="TP2-divers"></a>
6 - Notes</h1>
<ul>
<li>Pour tester plus facilement votre tetris, n'oubliez pas la pièce <em>verticale</em> dans la liste des pièces possibles.</li>
<li>Ayez une version <em>fonctionnelle</em> du tetris tableau, avant de faire la version liste. Vous aurez besoin d'une version fonctionnelle pour le tetris graphique.</li>
<li>Dans la version liste du Tetris, une erreur commune est d'initialiser chaque ligne par une affectation à la chaîne <code>"____________"</code> (où les '_' sont des espaces). Le problème est que c'est une chaîne constante, donc non modifiable. Il faut donc bien allouer <b>dynamiquement</b> une chaîne de la bonne longueur et la remplir d'espaces. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 7 2023 12:01:56 for INFO505 Programmation C by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
