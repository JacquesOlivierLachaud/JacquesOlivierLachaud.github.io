<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INFO804 Introduction à l&#39;informatique graphique: TP1 Visualisation et compression &quot;out-of-core&quot; de soupes de triangles</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INFO804 Introduction à l&#39;informatique graphique
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP1 Visualisation et compression "out-of-core" de soupes de triangles</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ig_tp1_1">1 - Objectifs, pointeurs utiles</a></li>
<li class="level1"><a href="#ig_tp1_2">2 - Code initial, application minimale libQGLViewer</a></li>
<li class="level1"><a href="#ig_tp1_3">3 - Soupe de triangles</a><ul><li class="level2"><a href="#ig_tp1_3_1">3.1 - Classes de base</a></li>
<li class="level2"><a href="#ig_tp1_3_2">3.2 - Classe TriangleSoup et chargement.</a></li>
<li class="level2"><a href="#ig_tp1_3_3">3.3 - Ajustement de la caméra</a></li>
<li class="level2"><a href="#ig_tp1_3_4">3.4 - Flat shading sur les faces</a></li>
<li class="level2"><a href="#ig_tp1_3_5">3.5 - Couleur ambiente / diffuse / spéculaire</a></li>
</ul>
</li>
<li class="level1"><a href="#ig_tp1_4">4 - Compression par découpage sur une grille régulière</a><ul><li class="level2"><a href="#ig_tp1_4_1">4.1 - Principe de l&#39;algorithme</a></li>
<li class="level2"><a href="#ig_tp1_4_2">4.2 - Zipper et index d&#39;une cellule</a></li>
<li class="level2"><a href="#ig_tp1_4_3">4.3 - Compression sans replacement des sommets des triangles</a></li>
<li class="level2"><a href="#ig_tp1_4_4">4.4 - Compression avec replacement des sommets des triangles</a></li>
</ul>
</li>
<li class="level1"><a href="#ig_tp1_5">5 - Conclusion et remise du TP</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ig_tp1_1"></a>
1 - Objectifs, pointeurs utiles</h1>
<p>L'objectif de ce TP est de vous familiariser avec l'informatique graphique, d'une part avec quelques petits traitements OpenGL, d'autre part avec un peu d'algorithmique sur des modèles géométriques simples. Le langage utilisé sera le C++. On utilisera pour l'interface graphique la bibliothèque <a href="https://github.com/GillesDebunne/libQGLViewer">libQGLViewer</a>. Celle-ci utilise Qt et OpenGL. L'avantage de ne pas faire de l'OpenGL directement est que libQGLViewer gère déjà pour vous la caméra, ainsi que le déplacement de la caméra. A l'issue de cette séance, vous maîtriserez:</p>
<ul>
<li>l'affichage de triangles via OpenGL</li>
<li>un modèle géométrique simple : la soupe de triangles</li>
<li>le problème de l'illumination "réaliste" de triangles</li>
<li>un algorithme de compression <em>out-of-core</em> de soupes de triangles</li>
<li>l'écriture C++ de petites classes de calcul (points/vecteurs, indexes) avec de la surcharge d'opérateurs.</li>
</ul>
<p>L'objectif du TP est:</p>
<ul>
<li>de pouvoir charger en mémoire un fichier texte contenant une soupe de triangles</li>
<li>de pouvoir visualiser ces triangles</li>
<li>de fabriquer une nouvelle soupe de triangles qui approche la soupe de triangles en entrée mais qui comporte moins de triangles (compression).</li>
<li>d'enregistrer le résultat sous forme de fichier texte.</li>
</ul>
<p>Les sites suivants pourront être utile pendant le TP:</p><ul>
<li>[<a href="http://libqglviewer.com/">http://libqglviewer.com/</a> Site libQGLViewer: exemples, doc, références]</li>
<li>[<a href="http://www.cplusplus.com/">http://www.cplusplus.com/</a> Site C++: tutoriels, références]</li>
<li>[<a href="http://www.parashift.com/c++-faq-lite/index.html">http://www.parashift.com/c++-faq-lite/index.html</a> C++ FAQ]</li>
</ul>
<h1><a class="anchor" id="ig_tp1_2"></a>
2 - Code initial, application minimale libQGLViewer</h1>
<p>On vous donne trois fichiers <a class="el" href="main_8cpp_source.html">main.cpp</a>, Viewer.h, Viewer.cpp, et un fichier de configuration Qt <a class="el" href="viewer_8pro_source.html">viewer.pro</a>. Il faut donc avoir installé <code>libqglviewer-dev</code> et Qt (qt5, qt6 pas testé). A priori, tout le code peut marcher sous Windows ou MacOS. On utilise <code>qmake</code> pour construire un <code>Makefile</code> à partir du fichier <a class="el" href="viewer_8pro_source.html">viewer.pro</a>. Le fichier a la forme ci-dessous, à adapter selon votre configuration:</p>
<div class="fragment"><div class="line"># Ceci est un fichier de configuration pour une application Qt</div>
<div class="line"># Il faut peut-etre legerement l adapter pour votre ordinateur.</div>
<div class="line"> </div>
<div class="line"># nom de votre executable</div>
<div class="line">TARGET  = viewer</div>
<div class="line"># config de l executable</div>
<div class="line">QMAKE_CXXFLAGS = --std=c++11</div>
<div class="line">CONFIG *= qt opengl release c++11</div>
<div class="line"> </div>
<div class="line"># config de Qt</div>
<div class="line">QT     *= opengl xml</div>
<div class="line"># Qt6</div>
<div class="line">QT     += openglwidgets</div>
<div class="line"> </div>
<div class="line"># Noms de vos fichiers entete</div>
<div class="line">HEADERS = Viewer.h</div>
<div class="line"># Noms de vos fichiers source (vous pouvez en mettre dautres)</div>
<div class="line">SOURCES = Viewer.cpp main.cpp</div>
<div class="line"> </div>
<div class="line">###########################################################</div>
<div class="line"># Commentez/decommentez selon votre config/systeme</div>
<div class="line"># (Une config windows est possible)</div>
<div class="line">###########################################################</div>
<div class="line"> </div>
<div class="line"># Exemple de configuration Linux de Qt et libQGLViewer Qt5</div>
<div class="line"># Ubuntu 20.04</div>
<div class="line">LIBS *= -L/usr/lib/x86_64-linux-gnu -lQGLViewer-qt5</div>
<div class="line"> </div>
<div class="line"># Exemple de configuration MacOSX avec macports</div>
<div class="line"># INCLUDEPATH *= /opt/local/include</div>
<div class="line"># LIBS *= -L/opt/local/lib -lQGLViewer </div>
<div class="line"> </div>
<div class="line"># Exemple de configuration MacOSX/Qt6 avec frameworks</div>
<div class="line"># INCLUDEPATH *= /Users/lachaud/local/src/libQGLViewer-2.9.1</div>
<div class="line"># LIBS *= -F/Users/lachaud/local/src/libQGLViewer-2.9.1/QGLViewer -framework QGLViewer</div>
<div class="line"> </div>
<div class="line"># Exemple de configuration Windows :</div>
<div class="line"># LIBS *= -lopengl32 -lglu32</div>
<div class="line"># INCLUDEPATH *= D:\Cours\Info805\TP1\libQGLViewer-2.7.1</div>
<div class="line"># LIBS *= -LD:\Cours\Info805\TP1\libQGLViewer-2.7.1\QGLViewer -lQGLViewer2</div>
</div><!-- fragment --><p>Tapez donc</p>
<pre class="fragment">$ qmake
$ make
</pre><p>L'application <code>viewer</code> est construite et vous pouvez l'exécuter.</p>
<div class="image">
<img src="ig1-1.png" alt=""/>
</div>
<dl class="section note"><dt>Note</dt><dd><b>Installation</b> de Qt et QGLViewer sous Ubuntu 16.04 - 20.04. Il suffit d'installer les paquets <code>qt5-default</code> et <code>libqglviewer-dev</code>. On peut ensuite utiliser le fichier <code><a class="el" href="viewer_8pro_source.html">viewer.pro</a></code> tel quel.</dd>
<dd>
Pour Qt5, testé sous MacOS avec Qt5.15.8 et libQGLViewer-2.7.2. Pour Qt6, testé sous MacOS avec Qt6.4.2 et libQGLViewer-2.9.1.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Faite attention à ne pas avoir plusieurs versions de Qt5/Qt6, notamment sous MacOS. Les exécutables MacOS cherchent les bibliothèques dépendantes à leur exécution dans des séries de répertoire, pas forcément dans l'ordre que vous souhaitez. <code>install_name_tool -add_rpath PATH</code> peut être utile.</dd></dl>
<p>Regardez maintenant les fichiers Viewer.h et Viewer.cpp.</p>
<div class="fragment"><div class="line"><span class="comment">/// \file Viewer.h</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;QGLViewer/qglviewer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classViewer.html">Viewer</a> : <span class="keyword">public</span> QGLViewer</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <a class="code hl_class" href="classViewer.html">Viewer</a>() : QGLViewer() {}</div>
<div class="line">  </div>
<div class="line"> protected :<span class="comment"></span></div>
<div class="line"><span class="comment">  /// Called at each draw of the window</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classViewer.html#a9ce9d06343c4e089ac76b19f78fe29e4">draw</a>();<span class="comment"></span></div>
<div class="line"><span class="comment">  /// Called before the first draw</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classViewer.html#a255cc2d6f55fc8565e614618d41589b1">init</a>();<span class="comment"></span></div>
<div class="line"><span class="comment">  /// Called when pressing help.</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">virtual</span> QString <a class="code hl_function" href="classViewer.html#abb55fd0b89d44d49094f828025813057">helpString</a>() <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassViewer_html"><div class="ttname"><a href="classViewer.html">Viewer</a></div><div class="ttdef"><b>Definition</b> <a href="TP1_2Viewer_8h_source.html#l00005">Viewer.h:6</a></div></div>
<div class="ttc" id="aclassViewer_html_a255cc2d6f55fc8565e614618d41589b1"><div class="ttname"><a href="classViewer.html#a255cc2d6f55fc8565e614618d41589b1">Viewer::init</a></div><div class="ttdeci">virtual void init()</div><div class="ttdoc">Called before the first draw.</div><div class="ttdef"><b>Definition</b> <a href="TP1_2Viewer_8cpp_source.html#l00036">Viewer.cpp:36</a></div></div>
<div class="ttc" id="aclassViewer_html_a9ce9d06343c4e089ac76b19f78fe29e4"><div class="ttname"><a href="classViewer.html#a9ce9d06343c4e089ac76b19f78fe29e4">Viewer::draw</a></div><div class="ttdeci">virtual void draw()</div><div class="ttdoc">Called at each draw of the window.</div><div class="ttdef"><b>Definition</b> <a href="TP1_2Viewer_8cpp_source.html#l00007">Viewer.cpp:7</a></div></div>
<div class="ttc" id="aclassViewer_html_abb55fd0b89d44d49094f828025813057"><div class="ttname"><a href="classViewer.html#abb55fd0b89d44d49094f828025813057">Viewer::helpString</a></div><div class="ttdeci">virtual QString helpString() const</div><div class="ttdoc">Called when pressing help.</div><div class="ttdef"><b>Definition</b> <a href="TP1_2Viewer_8cpp_source.html#l00045">Viewer.cpp:45</a></div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">/// \file Viewer.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;Viewer.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Draws a tetrahedron with 4 colors.</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classViewer.html#a9ce9d06343c4e089ac76b19f78fe29e4">Viewer::draw</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">float</span> colorBronzeDiff[4] = { 0.8, 0.6, 0.0, 1.0 };</div>
<div class="line">  <span class="keywordtype">float</span> colorRedDiff   [4] = { 1.0, 0.0, 0.0, 1.0 };</div>
<div class="line">  <span class="keywordtype">float</span> colorGreenDiff [4] = { 0.0, 1.0, 0.0, 1.0 };</div>
<div class="line">  <span class="keywordtype">float</span> colorBlueDiff  [4] = { 0.0, 0.0, 1.0, 1.0 };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Draws triangles given by 3 vertices.</span></div>
<div class="line">  glBegin(GL_TRIANGLES);</div>
<div class="line">  glColor4fv(colorBronzeDiff);</div>
<div class="line">  glVertex3f( 0.0, 0.0, 0.0 );</div>
<div class="line">  glVertex3f( 1.0, 0.0, 0.0 );</div>
<div class="line">  glVertex3f( 0.0, 1.0, 0.0 );</div>
<div class="line">  glColor4fv(colorRedDiff);</div>
<div class="line">  glVertex3f( 1.0, 0.0, 0.0 );</div>
<div class="line">  glVertex3f( 0.0, 1.0, 0.0 );</div>
<div class="line">  glVertex3f( 0.0, 0.0, 1.0 );</div>
<div class="line">  glColor4fv(colorGreenDiff);</div>
<div class="line">  glVertex3f( 0.0, 0.0, 0.0 );</div>
<div class="line">  glVertex3f( 0.0, 1.0, 0.0 );</div>
<div class="line">  glVertex3f( 0.0, 0.0, 1.0 );</div>
<div class="line">  glColor4fv(colorBlueDiff);</div>
<div class="line">  glVertex3f( 0.0, 0.0, 0.0 );</div>
<div class="line">  glVertex3f( 1.0, 0.0, 0.0 );</div>
<div class="line">  glVertex3f( 0.0, 0.0, 1.0 );</div>
<div class="line">  glEnd();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classViewer.html#a255cc2d6f55fc8565e614618d41589b1">Viewer::init</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Restore previous viewer state.</span></div>
<div class="line">  restoreStateFromFile();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Opens help window</span></div>
<div class="line">  help();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">QString <a class="code hl_function" href="classViewer.html#abb55fd0b89d44d49094f828025813057">Viewer::helpString</a>()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  QString text(<span class="stringliteral">&quot;&lt;h2&gt;S i m p l e V i e w e r&lt;/h2&gt;&quot;</span>);</div>
<div class="line">  text += <span class="stringliteral">&quot;Use the mouse to move the camera around the object. &quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;You can respectively revolve around, zoom and translate with the three mouse buttons. &quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;Left and middle buttons pressed together rotate around the camera view direction axis&lt;br&gt;&lt;br&gt;&quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;Pressing &lt;b&gt;Alt&lt;/b&gt; and one of the function keys (&lt;b&gt;F1&lt;/b&gt;..&lt;b&gt;F12&lt;/b&gt;) defines a camera keyFrame. &quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;Simply press the function key again to restore it. Several keyFrames define a &quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;camera path. Paths are saved when you quit the application and restored at next start.&lt;br&gt;&lt;br&gt;&quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;Press &lt;b&gt;F&lt;/b&gt; to display the frame rate, &lt;b&gt;A&lt;/b&gt; for the world axis, &quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;&lt;b&gt;Alt+Return&lt;/b&gt; for full screen mode and &lt;b&gt;Control+S&lt;/b&gt; to save a snapshot. &quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;See the &lt;b&gt;Keyboard&lt;/b&gt; tab in this window for a complete shortcut list.&lt;br&gt;&lt;br&gt;&quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;Double clicks automates single click actions: A left button double click aligns the closer axis with the camera (if close enough). &quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;A middle button double click fits the zoom of the camera and the right button re-centers the scene.&lt;br&gt;&lt;br&gt;&quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;A left button double click while holding right button pressed defines the camera &lt;i&gt;Revolve Around Point&lt;/i&gt;. &quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;See the &lt;b&gt;Mouse&lt;/b&gt; tab and the documentation web pages for details.&lt;br&gt;&lt;br&gt;&quot;</span>;</div>
<div class="line">  text += <span class="stringliteral">&quot;Press &lt;b&gt;Escape&lt;/b&gt; to exit the viewer.&quot;</span>;</div>
<div class="line">  <span class="keywordflow">return</span> text;</div>
<div class="line">}</div>
</div><!-- fragment --><p>La méthode <a class="el" href="classViewer.html#a9ce9d06343c4e089ac76b19f78fe29e4" title="Called at each draw of the window.">Viewer::draw</a> est appelée chaque fois que nécessaire (par exemple à chaque déplacement de la caméra). C'est elle qui envoie les ordres d'affichage à OpenGL, via les commandes <code>glBegin</code>, <code>glColor</code>, <code>glVertex</code>, etc. Notez que les commandes de positionnement de la caméra et de la transformation perspective sont faites par libQGLViewer (donc la classe qglviewer::QGLViewer).</p>
<p>Ainsi, pour afficher des triangles, vous n'aurez qu'à donner les coordonnées des 3 sommets de chacun des triangles.</p>
<h1><a class="anchor" id="ig_tp1_3"></a>
3 - Soupe de triangles</h1>
<p>On va se donner en entrée des fichiers contenant des triangles décrits sous format texte (c'est pas optimisé, mais c'est pas grave). Par ligne, on aura les 3 coordonnées des 3 sommets de chaque triangle, soit 9 nombres à virgule flottante. Les lignes commençant par '#' seront des commentaires.</p>
<pre class="fragment"># Soupe 1 ...
5.40414 0.269732 0.917559 4.68585 0.381459 0.739248 4.35375 -1.08202 1.25418
5.40414 0.269732 0.917559 4.35375 -1.08202 1.25418 5.02057 -1.34041 1.47509
4.68585 0.381459 0.739248 4.26875 0.269732 0.127895 3.9607 -1.10742 0.617722
4.68585 0.381459 0.739248 3.9607 -1.10742 0.617722 4.35375 -1.08202 1.25418
4.26875 0.269732 0.127895 4.39716 0 -0.558376 4.07166 -1.40172 -0.0614581
4.26875 0.269732 0.127895 4.07166 -1.40172 -0.0614581 3.9607 -1.10742 0.617722
4.39716 0 -0.558376 4.99586 -0.269732 -0.917559 4.62163 -1.79253 -0.385507
4.39716 0 -0.558376 4.62163 -1.79253 -0.385507 4.07166 -1.40172 -0.0614581
4.99586 -0.269732 -0.917559 5.71414 -0.381459 -0.739248 5.28845 -2.05092 -0.164601
4.99586 -0.269732 -0.917559 5.28845 -2.05092 -0.164601 4.62163 -1.79253 -0.385507
5.71414 -0.381459 -0.739248 6.13125 -0.269732 -0.127895 5.68151 -2.02552 0.471856
# etc
</pre><h2><a class="anchor" id="ig_tp1_3_1"></a>
3.1 - Classes de base</h2>
<p>Faites un fichier <code>Utils.h</code> (éventuellement aussi <code>Utils.cpp</code>) dans lequel vous allez mettre un peu toutes vos classes.</p>
<p>Commencez par créer une classe <code>Vecteur</code> qui contient quelques fonctions de base pour manipuler 3 flottants.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Utils.h</span></div>
<div class="line"><span class="keyword">struct </span>Vecteur {</div>
<div class="line">  <span class="keywordtype">float</span> xyz[ 3 ]; <span class="comment">// les composantes</span></div>
<div class="line">  Vecteur( <span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">float</span> z ); <span class="comment">// constructeur</span></div>
<div class="line">  <span class="keywordtype">float</span>  operator[]( <span class="keywordtype">int</span> i ) <span class="keyword">const</span>;     <span class="comment">// accesseur en lecture</span></div>
<div class="line">  <span class="keywordtype">float</span>&amp; operator[]( <span class="keywordtype">int</span> i );           <span class="comment">// accesseur en ecriture</span></div>
<div class="line">};</div>
<div class="line">std::ostream&amp; operator&lt;&lt;( std::ostream&amp; out, Vecteur v );</div>
<div class="line">std::istream&amp; operator&gt;&gt;( std::istream&amp; in, Vecteur&amp; v );</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Utils.cpp</span></div>
<div class="line">std::ostream&amp; operator&lt;&lt;( std::ostream&amp; out, Vecteur v )</div>
<div class="line">{</div>
<div class="line">  out &lt;&lt; v[ 0 ] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; v[ 1 ] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; v[ 2 ];</div>
<div class="line">  <span class="keywordflow">return</span> out;</div>
<div class="line">}</div>
<div class="line">std::istream&amp; operator&gt;&gt;( std::istream&amp; in, Vecteur&amp; v )</div>
<div class="line">{</div>
<div class="line">  in &gt;&gt; v[ 0 ] &gt;&gt; v[ 1 ] &gt;&gt; v[ 2 ];</div>
<div class="line">  <span class="keywordflow">return</span> in;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Faites ensuite une classe <code>Triangle</code> qui se compose de 3 vecteurs, les sommets du triangle. On peut aussi créer des opérateurs flux pour la classe triangle, sur le même principe que ci-dessus.</p>
<h2><a class="anchor" id="ig_tp1_3_2"></a>
3.2 - Classe TriangleSoup et chargement.</h2>
<p>Ecrivez maintenant la classe <code>TriangleSoup</code> qui comporte au moins les méthodes et attributs suivants:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TriangleSoup {</div>
<div class="line">  std::vector&lt;Triangle&gt; triangles; <span class="comment">// les triangles</span></div>
<div class="line">  TriangleSoup() {}</div>
<div class="line">  <span class="keywordtype">void</span> read( std::istream&amp; in );</div>
<div class="line">};</div>
</div><!-- fragment --><p>Vous allez avoir besoin d'inclure les entêtes systèmes <code>iostream</code>, <code>fstream</code>, <code>sstream</code>. On rappelle que pour obtenir le flux en lecture sur le fichier "toto.tri", on écrit:</p>
<div class="fragment"><div class="line">ifstream input( <span class="stringliteral">&quot;toto.tri&quot;</span> ); <span class="comment">// input est un flux en entrée.</span></div>
<div class="line"><span class="keywordflow">if</span> ( ! input.good() ) std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">...</div>
<div class="line">inputFile.close(); <span class="comment">// à la fin</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Pour lire une ligne à la fois dans le flux, utilisez <code>getline(
istream, string )</code> dans une chaîne de caractères <code>str</code>. Ensuite, créez un <code>istringstream</code> autour de <code>str</code> pour voir la chaîne comme un flux d'entrée, et passez ce flux à l'operateur &gt;&gt; de Triangle.</dd></dl>
<div class="fragment"><div class="line">std::string line;</div>
<div class="line">std::getline( input, line );</div>
<div class="line"><span class="keywordflow">if</span> ( ( line.size() &gt; 0 ) &amp;&amp; ( line[ 0 ] != <span class="charliteral">&#39;#&#39;</span> ) )  {</div>
<div class="line">  std::istringstream inputLine( line );</div>
<div class="line">  <span class="keywordtype">float</span> x,y,z;</div>
<div class="line">  inputLine  &gt;&gt; x &gt;&gt; y &gt;&gt; z;</div>
<div class="line">   ...</div>
<div class="line">}   </div>
</div><!-- fragment --><p>Il ne vous reste plus qu'à écrire la méthode <code>read</code> pour lire les triangles dans le flux en entrée. Transformez votre main pour qu'il récupère en premier paramètre (<code>argv[1]</code>) le nom du fichier contenant les triangles. Je vous donne ci-dessous des pointeurs vers des soupes de triangles.</p>
<ul>
<li>un noeud de trèfle <a href="https:./tref.tri">https:./tref.tri</a> (50Ko)</li>
<li>un modèle pixelisé du célèbre Stanford bunny <a href="https:./bunny258.tri">https:./bunny258.tri</a> (21Mo)</li>
<li>une surface extraite par Marching-cubes d'une image CT 3d <a href="https:./cthead100.tri">https:./cthead100.tri</a> (26Mo)</li>
<li>un modèle pixelisé de "Octaflower" <a href="https:./octaflower-513.tri">https:./octaflower-513.tri</a> (65Mo)</li>
<li>un modèle pixelisé de "RepublicCruiser" <a href="https:./rcruiser.tri">https:./rcruiser.tri</a> (19Mo)</li>
<li>un modèle pixelisé (gzipped) de "SharpSphere" <a href="https:./ssphere.tri.gz">https:./ssphere.tri.gz</a> (93Mo)</li>
</ul>
<p>Vous vérifiez que ça fonctionne en affichant le nombre de triangles dans votre classe TriangleSoup après chargement.</p>
<h2><a class="anchor" id="ig_tp1_3_2"></a>
3.2 - Classe TriangleSoup et chargement.</h2>
<p>On modifie maintenant la classe <a class="el" href="classViewer.html">Viewer</a> en lui rajoutant un pointeur vers un TriangleSoup, et en rajoutant au constructeur un paramètre TrangleSoupe:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classViewer.html">Viewer</a> : <span class="keyword">public</span> QGLViewer</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  TriangleSoup* ptrSoup;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classViewer.html">Viewer</a>( TriangleSoup* aSoup = 0 ) : QGLViewer(), ptrSoup( aSoup ) {}</div>
<div class="line">...</div>
<div class="line">};</div>
</div><!-- fragment --><p>Modifiez maintenant la fonction <a class="el" href="classViewer.html#a9ce9d06343c4e089ac76b19f78fe29e4" title="Called at each draw of the window.">Viewer::draw</a> pour qu'elle affiche tous les triangles de la soupe, au lieu du tétraèdre.</p>
<div class="fragment"><div class="line">TriangleSoup iSoup;</div>
<div class="line">ifstream input( <span class="stringliteral">&quot;tref.tri&quot;</span> );</div>
<div class="line">iSoup.read( input );</div>
<div class="line">viewer.ptrSoup = &amp;soup;</div>
<div class="line">viewer.setWindowTitle(<span class="stringliteral">&quot;Viewer triangle soup&quot;</span>);</div>
<div class="line">...</div>
</div><!-- fragment --><p>Voilà un aperçu de ce que ça donne sur <code>"tref.tri"</code>, si vous avez choisi la couleur bronze.</p>
<div class="image">
<img src="ig1-2.png" alt=""/>
</div>
<p>Il y a normalement plusieurs problèmes:</p>
<ol type="1">
<li>d'abord, on voit que les couleurs sont "pleines" sur les faces, et on n'a pas l'impression de volume;</li>
<li>ensuite il est possible que l'on ne voit pas tout le volume, selon le paramétrage de la caméra ou le modèle géométrique lu en entrée.</li>
</ol>
<p>On va les résoudre dans les questions suivantes.</p>
<h2><a class="anchor" id="ig_tp1_3_3"></a>
3.3 - Ajustement de la caméra</h2>
<p>Il faut préciser à la caméra la taille et la position de l'objet à regarder pour qu'elle embrasse toute la scène au début. C'est en fait relativement complexe si on devait le faire sur les matrices de transformation, mais tout simple grâce à QGLViewer.</p>
<p>Il suffit juste de calculer la boîte englobante à l'objet (ici la soupe de triangles), et de la donner au <a class="el" href="classViewer.html">Viewer</a>. Pour ce faire, écrivez d'abord les deux méthodes suivantes dans <code>Vecteur</code>, qui vont servir à calculer les deux points extrêmes qui définissent une boîte englobante (l'un est le <code>inf</code> de tous les vecteurs, l'autre est le <code>sup</code> de tous les vecteurs):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Vecteur {</div>
<div class="line">...</div>
<div class="line">  <span class="comment">// Retourne le vecteur dont les composantes sont les minima des</span></div>
<div class="line">  <span class="comment">// composantes de soi-même et de other.</span></div>
<div class="line">  Vecteur inf( <span class="keyword">const</span> Vecteur&amp; other ) <span class="keyword">const</span>;</div>
<div class="line">  <span class="comment">// Retourne le vecteur dont les composantes sont les maxima des</span></div>
<div class="line">  <span class="comment">// composantes de soi-même et de other.</span></div>
<div class="line">  Vecteur sup( <span class="keyword">const</span> Vecteur&amp; other ) <span class="keyword">const</span>;</div>
<div class="line">...</div>
</div><!-- fragment --><p>En utilisant les 2 méthodes ci-dessus, écrivez ensuite la méthode <code>void TriangleSoup::boundingBox( Vecteur&amp; low, Vecteur&amp; up)</code> qui calcule la boîte qui englobe tous les sommets de la soupe de triangle.</p>
<p>Il ne reste plus qu'à appeler <b>dans</b> <b>la</b> <b>méthode</b> <a class="el" href="classViewer.html#a255cc2d6f55fc8565e614618d41589b1" title="Called before the first draw.">Viewer::init</a>, la méthode <code>boundingBox</code> suivie de la méthode qui règle la camera.</p>
<div class="fragment"><div class="line"><span class="comment">// dans Viewer::init</span></div>
<div class="line">  camera()-&gt;setSceneBoundingBox( ... );</div>
<div class="line"><span class="comment">// ou camera()-&gt;setSceneRadius( ... );</span></div>
<div class="line">  camera()-&gt;showEntireScene( ... );</div>
</div><!-- fragment --><h2><a class="anchor" id="ig_tp1_3_4"></a>
3.4 - Flat shading sur les faces</h2>
<p>Pour que OpenGL puisse calculer une couleur qui dépend de l'éclairage et de la position de la caméra, il faut lui donner d'abord une information supplémentaire : le vecteur normal à la surface, donc ici, à chacun à des triangles. Pour un triangle abc donné, nous allons le calculer simplement en faisant le produit vectoriel \( \vec{ab}
\times \vec{ac} \). Ecrivez donc la méthode <code>Vecteur::cross</code> qui calcule le produit vectoriel entre soi-même et un autre vecteur donné en paramètre.</p>
<dl class="section note"><dt>Note</dt><dd>On note que si \( \vec{u} \) et \( \vec{v}  \) sont deux vecteurs alors leur produit vectoriel \( \vec{w} = \vec{u} \times \vec{v} \) s'écrit en composantes:</dd></dl>
<p class="formulaDsp">
\[ \begin{pmatrix} w_x \\ w_y \\ w_z \end{pmatrix} = \begin{pmatrix} u_y v_z - u_z v_y \\ u_z v_x - u_x v_z \\ u_x v_y - u_y v_x \end{pmatrix} \]
</p>
<dl class="section note"><dt>Note</dt><dd>Voir wikipedia pour le calcul et les propriétés. On utilise ici juste le fait que le vecteur \( \vec{ab} \times \vec{ac} \) est orthogonal au triangle \( abc \).</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Vecteur { ...</div>
<div class="line">  Vecteur cross( <span class="keyword">const</span> Vecteur&amp; v ) <span class="keyword">const</span>;</div>
<div class="line">  ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>Ecrivez ensuite une méthode <code>Vecteur Triangle::normal() const</code> qui retourne le vecteur normal au triangle (n'oubliez pas de normaliser le vecteur pour qu'il ait une norme 1. Il suffit enfin de rajouter dans <a class="el" href="classViewer.html#a9ce9d06343c4e089ac76b19f78fe29e4" title="Called at each draw of the window.">Viewer::draw</a> les lignes suivantes:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">  <span class="keywordtype">float</span> colorBronzeDiff[4] = { 0.8, 0.6, 0.0, 1.0 };</div>
<div class="line">  <span class="keywordtype">float</span> colorBronzeSpec[4] = { 1.0, 1.0, 0.4, 1.0 };</div>
<div class="line">  <span class="keywordtype">float</span> colorNull      [4] = { 0.0, 0.0, 0.0, 1.0 };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// OpenGL met en place par défaut le modèle de Phong d&#39;illumination.</span></div>
<div class="line">  glBegin(GL_TRIANGLES);</div>
<div class="line">  <span class="comment">// Si vous les écrivez là, ces couleurs/réglages seront partagés par tous</span></div>
<div class="line">  <span class="comment">// les triangles. </span></div>
<div class="line">  glColor4fv(colorBronzeDiff);</div>
<div class="line">  glMaterialfv(GL_FRONT, GL_DIFFUSE, colorBronzeDiff);</div>
<div class="line">  glMaterialfv(GL_FRONT, GL_SPECULAR, colorBronzeSpec);</div>
<div class="line">  glMaterialf(GL_FRONT, GL_SHININESS, 20.0f );</div>
<div class="line">  ...</div>
<div class="line">    <span class="comment">// Pour chaque triangle, avant les glVertex de chaque triangle:</span></div>
<div class="line">    <span class="keyword">const</span> Triangle&amp; T = ptrSoup-&gt;triangles[ i ];</div>
<div class="line">    Vecteur n = T.normal();</div>
<div class="line">    glNormal3f( n[ 0 ], n[ 1 ], n[ 2 ] );</div>
<div class="line">    glVertex</div>
<div class="line">  ...</div>
</div><!-- fragment --><p>Vous devriez maintenant avoir votre visualisateur de soupes de triangles qui ressemble à ceci :</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="ig1-3.png" alt=""/>
</div>
td </td><td><div class="image">
<img src="ig1-4.png" alt=""/>
</div>
td  </td></tr>
</table>
<h2><a class="anchor" id="ig_tp1_3_5"></a>
3.5 - Couleur ambiente / diffuse / spéculaire</h2>
<p>En fait, tel qu'écrit plus haut, vous avez donné une couleur ambiente "bronze" (donc c'est le minimum de couleur, même dans le noir), à laquelle vous ajoutez encore une couleur diffuse "bronze" (dépend de la lumière), et enfin une couleur spéculaire jaune, mais très brillant (donc assez métallique). Si vous voulez un effet très métallique, mettez la couleur ambiente à (0,0,0). Vous devriez obtenir:</p>
<div class="image">
<img src="ig1-5.png" alt=""/>
</div>
<p>Vous pouvez jouer un peu avec les paramètres pour voir les différents effets possibles.</p>
<p>Si vous voulez changer les matériaux de chacun des triangles, il faut le dire à OpenGL après glBegin(GL_TRIANGLES) avec: </p><div class="fragment"><div class="line">glBegin(GL_TRIANGLES);</div>
<div class="line">glEnable(GL_COLOR_MATERIAL); <span class="comment">// le materiau peut changer à chaque triangle.</span></div>
<div class="line">... </div>
<div class="line"><span class="comment">// changer les couleurs à chaque triangle.</span></div>
<div class="line">...</div>
<div class="line">glDisable(GL_COLOR_MATERIAL);</div>
<div class="line">glEnd();</div>
</div><!-- fragment --><p>On peut par exemple obtenir un effet "Elmer" en utilisant la partie décimale des coordonnées d'un sommet comme couleur ambiente.</p>
<div class="image">
<img src="ig1-6.png" alt=""/>
</div>
<h1><a class="anchor" id="ig_tp1_4"></a>
4 - Compression par découpage sur une grille régulière</h1>
<p>Nous allons maintenant implémenter un algorithme de compression de soupes de triangles, qui est d'une part entièrement parallélisable, et d'autre part peut même fonctionner sous forme de flux d'entrée-sortie. Chaque triangle sera en effet traité <em>indépendamment</em> des autres.</p>
<h2><a class="anchor" id="ig_tp1_4_1"></a>
4.1 - Principe de l'algorithme</h2>
<ol type="1">
<li>On va découper l'espace (enfin, la boîte englobante de l'objet) de façon régulière en une grille. Un paramètre de l'algorithme de compression est le nombre de découpage selon chaque dimension, soit 3 entiers <code>nbx</code>, <code>nby</code>, <code>nbz</code>. Si vous choisissez (10,10,10) la boîte englobante sera découpée en \( 10 \times 10 \times 10 \) cellules, soit 1000 cellules.</li>
<li>Chacune de ces cellules sera en fait numérotée naturellement par un triplet d'entier, de (0,0,0) à (9,9,9). Ce triplet sera appelé <code>Index</code> de la cellule.</li>
<li>Ensuite, on cherchera dans quelle cellule tombe chaque sommet. Un triangle ayant 3 sommets, chacun des 3 sommets d'un triangle aura donc un Index.</li>
<li>Si les 3 sommets d'un triangle n'ont pas tous un Index différent, alors on jette le triangle ! Il ne sera pas dans la soupe de triangle en sortie.<ol type="a">
<li>Si les 3 sommets d'un triangle ont chacun un Index différent, on va construire un triangle de sortie. La difficulté est qu'il faut replacer les sommets si on ne veut pas avoir des trous partout dans la triangulation de sortie. Dans un premier temps, vous placerez les sommets au <b>centre</b> de la cellule. Dans un deuxième temps, vous placerez les sommets au <b>barycentre</b> de tous les sommets qui tombent dans la cellule.</li>
<li>Si 2 sommets ou 3 sommets ont le même Index, on jette le triangle.</li>
</ol>
</li>
<li>L'ensemble des triangles de sortie forme une soupe de triangles, que l'on pourra sauvegarder dans un fichier. Cette soupe de triangles a au pire le même nombre de triangles que la soupe en entrée, et en général beaucoup moins. Dans certains cas, elle peut même lisser le résultat.</li>
</ol>
<h2><a class="anchor" id="ig_tp1_4_2"></a>
4.2 - Zipper et index d'une cellule</h2>
<p>On va créer une classe <code>TriangleSoupZipper</code> pour réaliser la compression. On va se servir aussi d'une classe <code>Index</code> pour stocker les 3 entiers qui numérotent chaque cellule. Une partie de cette classe vous est donnée ci-dessous:</p>
<div class="fragment"><div class="line"><span class="comment">/// Définit un index sur 3 entiers. Toutes les opérations usuelles</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// sont surchargées (accès, comparaisons, égalité).</span></div>
<div class="line"><span class="comment"></span><span class="keyword">struct </span>Index {</div>
<div class="line">  <span class="keywordtype">int</span> idx[ 3 ];</div>
<div class="line">  Index() {}</div>
<div class="line">  Index( <span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2 )</div>
<div class="line">  {</div>
<div class="line">    idx[ 0 ] = i0;</div>
<div class="line">    idx[ 1 ] = i1;</div>
<div class="line">    idx[ 2 ] = i2;</div>
<div class="line">  }</div>
<div class="line">  Index( <span class="keywordtype">int</span> indices[] )</div>
<div class="line">  {</div>
<div class="line">    idx[ 0 ] = indices[ 0 ];</div>
<div class="line">    idx[ 1 ] = indices[ 1 ];</div>
<div class="line">    idx[ 2 ] = indices[ 2 ];</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">int</span>  operator[]( <span class="keywordtype">int</span> i )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> idx[ i ]; }</div>
<div class="line">  <span class="keywordtype">int</span>&amp; operator[]( <span class="keywordtype">int</span> i )       { <span class="keywordflow">return</span> idx[ i ]; }</div>
<div class="line">  <span class="keywordtype">bool</span> operator&lt;( <span class="keyword">const</span> Index&amp; other )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> ( idx[ 0 ] &lt; other.idx[ 0 ] )</div>
<div class="line">      || ( ( idx[ 0 ] == other.idx[ 0 ] )</div>
<div class="line">           &amp;&amp; ( ( idx[ 1 ] &lt; other.idx[ 1 ] )</div>
<div class="line">                || ( ( idx[ 1 ] == other.idx[ 1 ] )</div>
<div class="line">                     &amp;&amp; ( idx[ 2 ] &lt; other.idx[ 2 ] ) ) ) );</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Rajoutez l'opérateur d'égalité == dans la classe. Vous écrirez ensuite la classe <code>TriangleSoupZipper</code> avec le constructeur suivant:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TriangleSoupZipper { ...</div>
<div class="line">  <span class="comment">// Construit le zipper avec une soupe de triangle en entrée \a</span></div>
<div class="line">  <span class="comment">// anInput, une soupe de triangle en sortie \a anOutput, et un index \a size</span></div>
<div class="line">  <span class="comment">// qui est le nombre de cellules de la boîte découpée selon les 3 directions.</span></div>
<div class="line">  TriangleSoupZipper( <span class="keyword">const</span> TriangleSoup&amp; anInput,</div>
<div class="line">                      TriangleSoup&amp; anOuput, </div>
<div class="line">                      Index size );</div>
<div class="line">  ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>N'oubliez pas de créer les données membres nécessaires. Vous précalculerez dans le constructeur, la boîte englobante de la soupe de triangles en entrée, les tailles réelles de chaque cellule (i.e. il faut diviser la taille de la boîte par le nombre de cellules le long de chaque dimension).</p>
<p>Vous aurez ensuite besoin de créer une méthode <code>index</code> qui calcule l'Index d'un point dans l'espace, et son inverse la fonction <code>centroid</code> qui calcule le centroïde de la cellule d'Index donné.</p>
<div class="fragment"><div class="line"><span class="comment">/// @return l&#39;index de la cellule dans laquelle tombe \a p.</span></div>
<div class="line">Index index( <span class="keyword">const</span> Vecteur&amp; p ) <span class="keyword">const</span>;<span class="comment"></span></div>
<div class="line"><span class="comment">/// @return le centroïde de la cellule d&#39;index \a idx (son &quot;centre&quot;).</span></div>
<div class="line"><span class="comment"></span>Vecteur centroid( <span class="keyword">const</span> Index&amp; idx ) <span class="keyword">const</span>;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Par exemple, si la boîte englobante est (-5,-5,-5) - (5,5,5) et qu'on a divisé en 10 x 10 x 10 cellules, alors l'index du point (1.2, 3.4, -1.7) est (6,8,3). Le centroïde de la cellule (6,8,3) est (1.5, 3.5, -1.5).</dd></dl>
<h2><a class="anchor" id="ig_tp1_4_3"></a>
4.3 - Compression sans replacement des sommets des triangles</h2>
<p>Il ne reste plus qu'à écrire une méthode <code>zip()</code> qui compresse tous les triangles de la soupe en entrée et sort les triangles dont les sommets ont des index différents. La position des sommets en sortie est juste <code>centroid( idx )</code> si <code>idx</code> est l'index du sommet. Vous obtiendrez un résultat du type:</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="ig1-7.png" alt=""/>
</div>
td </td><td><div class="image">
<img src="ig1-8.png" alt=""/>
</div>
td  </td></tr>
<tr>
<td>bunny258.tri (464588 triangles)  </td><td>pour une décomposition 50x50x50 (19637 triangles)   </td></tr>
</table>
<h2><a class="anchor" id="ig_tp1_4_4"></a>
4.4 - Compression avec replacement des sommets des triangles</h2>
<p>Malheureusement le résultat n'est souvent pas très joli. Cela vient du mauvais positionnement des sommets des triangles de sortie. Une meilleure idée est de moyenner tous les sommets qui tombent dans la même cellule, puis en sortie d'associer cette position moyenne aux sommets. On va donc calculer (pendant la fonction <code>zip()</code>) le barycentre des sommets de chaque cellule. Ensuite, on réaffectera les positions des sommets des triangles de sortie.</p>
<p>Il faut donc calculer les barycentres de toutes les cellules qui touchent les triangles. On pourrait faire un grand tableau. C'est un peu lourd. On va plutôt utiliser un tableau associatif, i.e. un <code>std::map</code> en C++, qui va associer à un Index une structure <code>CellData</code> qui va stocker un accumulateur de "Point" et un nombre. Elle aura la forme suivante:</p>
<div class="fragment"><div class="line"><span class="comment">// Structure pour calculer le barycentre d&#39;un ensemble de points.</span></div>
<div class="line"><span class="keyword">struct </span>CellData {</div>
<div class="line">  Vecteur acc;</div>
<div class="line">  <span class="keywordtype">int</span> nb;</div>
<div class="line">  <span class="comment">// Crée un accumulateur vide.</span></div>
<div class="line">  CellData(): acc(), nb(0) {}</div>
<div class="line">  <span class="comment">// Ajoute le point v à l&#39;accumulateur.</span></div>
<div class="line">  <span class="keywordtype">void</span> add( <span class="keyword">const</span> Vecteur&amp; v );</div>
<div class="line">  <span class="comment">// Retourne le barycentre de tous les points ajoutés.</span></div>
<div class="line">  Vecteur barycenter() <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Ecrivez cette structure. Ensuite, ajoutez dans <code>TriangleSoupZipper</code> une donnée membre `index2data:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TriangleSoupZipper {</div>
<div class="line">...</div>
<div class="line">  <span class="comment">// Stocke pour chaque cellule son barycentre.</span></div>
<div class="line">  std::map&lt;Index, CellData&gt; index2data;</div>
<div class="line">...</div>
<div class="line">};</div>
</div><!-- fragment --><p>Mettez à jour <code>zip()</code> pour que chaque sommet soit ajouté au barycentre de sa cellule (mise à jour de <code>index2data</code>). Ecrivez enfin la méthode <code>smartZip()</code> qui :</p>
<ol type="1">
<li>Met à zéro <code>index2data</code> avec sa méthode <code>clear()</code>.</li>
<li>Appelle <code>zip()</code></li>
<li><p class="startli">Reparcourt les triangles de sortie pour replacer les sommets au barycentre de leur cellule (plutôt que leur centroïde).</p>
<p class="startli">Pour chaque sommet s d'un triangle de sortie, sa nouvelle position est <code>index2data[ index( s ) ].barycenter()</code></p>
</li>
</ol>
<p>Vous devriez maintenant obtenir les résultats suivants, beaucoup plus satisfaisants:</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="ig1-9.png" alt=""/>
</div>
td </td><td><div class="image">
<img src="ig1-10.png" alt=""/>
</div>
td  </td></tr>
<tr>
<td>bunny258.tri (464588 triangles)  </td><td>pour une décomposition 20x20x20 (3184 triangles)   </td></tr>
<tr>
<td><div class="image">
<img src="ig1-11.png" alt=""/>
</div>
td </td><td><div class="image">
<img src="ig1-12.png" alt=""/>
</div>
td  </td></tr>
<tr>
<td>pour une décomposition 50x50x50 (19637 triangles)  </td><td>pour une décomposition 100x100x100 (74060 triangles)   </td></tr>
</table>
<h1><a class="anchor" id="ig_tp1_5"></a>
5 - Conclusion et remise du TP</h1>
<p>Il ne vous reste plus qu'à faire 2 exécutables (qui peuvent être dans deux répertoires différents avec deux fichiers .pro différents):</p>
<ol type="1">
<li>Un visualiseur graphique <code>viewer</code> de soupe de triangles (1 argument: le nom du fichier contenant la soupe de triangles). Ce programme affichera le nombre de triangles en entrée.</li>
<li>Un programme non graphique qui prend 5 arguments, le nom du fichier contenant la soupe de triangles en entrée, le nom du fichier contenant la soupe de triangles en sortie, et les 3 entiers décrivant la subdivision. Ce programme affichera le nombre de triangles en entrée, en sortie, et le taux de compression (nb_triangles_output / nb_triangles_input * 100).</li>
</ol>
<p>Et un README à la racine qui précise quelles sont les questions traitées complètement, partiellement, ou non-traitées.</p>
<p>Tout cela sera à remettre via <a href="https://www.lama.univ-savoie.fr/TPLab">TPLab</a> en binôme avant <b>mercredi</b> <b>8</b> <b>janvier</b> <b>minuit</b>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 8 2024 11:06:49 for INFO804 Introduction à l&#39;informatique graphique by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
