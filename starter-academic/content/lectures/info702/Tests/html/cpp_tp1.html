<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INFO702 - TPs: TP1 Traitement d&#39;images en niveaux de gris (POO simple, surcharge d&#39;opérateurs, entrées/sorties).</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INFO702 - TPs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP1 Traitement d'images en niveaux de gris (POO simple, surcharge d'opérateurs, entrées/sorties).</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#cpp_tp1_1">1 - Objectifs, pointeurs utiles</a></li>
<li class="level1"><a href="#cpp_tp1_2">2 - Définition d&#39;une classe pour représenter les images</a></li>
<li class="level1"><a href="#cpp_tp1_3">3 - Accesseurs utiles (taille, valeurs de niveaux de gris).</a></li>
<li class="level1"><a href="#cpp_tp1_4">4 - Un iterateur pour les images</a></li>
<li class="level1"><a href="#cpp_tp1_5">5 - Import / Export en format PGM</a></li>
<li class="level1"><a href="#cpp_tp1_6">6 - Filtrage médian</a></li>
<li class="level1"><a href="#cpp_tp1_7">7 - Histogramme et Histogramme cumulé d&#39;une image.</a></li>
<li class="level1"><a href="#cpp_tp1_8">8 - Rehaussement de contraste par filtrage par convolution</a></li>
<li class="level1"><a href="#cpp_tp1_9">9 - Générateur de bruit</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="cpp_tp1_1"></a>
1 - Objectifs, pointeurs utiles</h1>
<p>L'objectif de ce TP est de vous familiariser avec la programmation objet classique en C++. Il n'y aura pas explicitement de la généricité, mais on définira néanmoins des objets classiques en programmation générique (comme les itérateurs). Ce TP servira de base à l'écriture d'une classe générique image au TP suivant. A l'issue de cette séance, vous maîtriserez:</p>
<ul>
<li>la déclaration d'une classe, de ses constructeurs, de ses données membre, dans un fichier entête.</li>
<li>la définition des méthodes de la classe dans un fichier source</li>
<li>l'écriture de programmes principaux pour faire des commandes en ligne</li>
<li>l'utilisation du container STL <code>vector</code> et du quasi-conteneur <code>string</code> </li>
<li>la déclaration de types et de classes internes à une autre classe</li>
<li>la lecture et l'écriture dans un flux</li>
<li>la surcharge de plusieurs opérateurs (incrémentation ++, décrémentation &ndash;, déréférencement *)</li>
</ul>
<p>Le fil conducteur est l'écriture d'une classe pour représenter les images en niveaux de gris. Vous développerez un certain nombre de services autour de ces images:</p>
<ul>
<li>création d'image vide</li>
<li>lecture/écriture d'images PGM (le format le plus simple possible de stockage)</li>
<li>filtrage médian</li>
<li>rehaussement de contraste par filtrage par convolution</li>
<li>histogramme de l'image</li>
<li>correction de contraste par égalisation d'histogramme</li>
</ul>
<p>Les sites suivants pourront être utile pendant le TP:</p><ul>
<li>[<a href="http://www.cppreference.com/">http://www.cppreference.com/</a> Site C/C++: références très complètes]</li>
<li>[<a href="http://www.cplusplus.com/">http://www.cplusplus.com/</a> Site C++: tutoriels, références]</li>
<li>[<a href="http://www.parashift.com/c++-faq-lite/index.html">http://www.parashift.com/c++-faq-lite/index.html</a> C++ FAQ]</li>
</ul>
<p>Note: Tout bon logiciel de manipulation d'image peut importer ou exporter du portable pixmap (PBM, PGM, PPM). Le logiciel ImageMagick (commandes <code>convert</code> et <code>display</code> notamment) est bien pratique pour convertir en ligne de commande une image:</p>
<pre class="fragment">   prompt&gt; convert toto.jpg toto.pgm 
   prompt&gt; display toto.pgm </pre><dl class="section note"><dt>Note</dt><dd>Il n'y a pas d'IDE recommandé plus particulièrement qu'un autre, mais je constate:<ul>
<li>un étudiant sous Linux avec un éditeur de texte et la compilation via <code>make</code> démarre le TP en 5 minutes.</li>
<li>un étudiant avec son IDE déjà bien configuré avant d'arriver en TP gagne 1h sur l'étudiant qui installe son IDE pendant le TP.</li>
<li>la plupart des étudiants utilisent CodeBlocks, parfois Eclipse, parfois Visual C++</li>
<li>Windows entraîne des problèmes supplémentaires: bibliothèques manquantes, programme exécuté qui ne s'arrête jamais (vérifiez votre antivirus, certains avaient des problèmes avec AVAST), gestion des fichiers bizarre (Windows a deux modes: texte et binaire; il faut donc rajouter le mode <code>ios::binary</code> ou <code>ios::text</code> à l'ouverture des fichiers)</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="cpp_tp1_2"></a>
2 - Définition d'une classe pour représenter les images</h1>
<p>Nous représenterons les images en niveaux de gris de façon classique, avec un tableau de taille W*H de caractères (les niveaux de gris sont un nombre entre 0 et 255), et W et H sont respectivement la largeur et la hauteur de l'image. Vous déclarerez donc la classe <a class="el" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> dans un fichier <a class="el" href="GrayLevelImage2D_8hpp_source.html">GrayLevelImage2D.hpp</a>. Un extrait du fichier entête donne:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> GrayLevel;         <span class="comment">// le type pour les niveaux de gris.</span></div>
<div class="line">  <span class="keyword">typedef</span> std::vector&lt;GrayLevel&gt; Container;<span class="comment">// le type pour stocker les niveaux de gris de l&#39;image.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constructeur par défaut</span></div>
<div class="line">  <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>();</div>
<div class="line">  <span class="comment">// Constructeur avec taille w x h. Remplit tout avec la valeur g (par défaut 0).</span></div>
<div class="line">  <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>( <span class="keywordtype">int</span> <a class="code hl_function" href="classGrayLevelImage2D.html#abef26bf39fa708316b52ce973396c43a">w</a>, <span class="keywordtype">int</span> <a class="code hl_function" href="classGrayLevelImage2D.html#aff7a95b8419a38404da536db4f24dfec">h</a>, GrayLevel g = 0 );</div>
<div class="line"> </div>
<div class="line">  ... <span class="comment">// du boulot</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Container m_data; <span class="comment">// mes données; évitera de faire les allocations dynamiques</span></div>
<div class="line">  <span class="keywordtype">int</span>       m_width; <span class="comment">// ma largeur</span></div>
<div class="line">  <span class="keywordtype">int</span>       m_height; <span class="comment">// ma hauteur</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassGrayLevelImage2D_html"><div class="ttname"><a href="classGrayLevelImage2D.html">GrayLevelImage2D</a></div><div class="ttdef"><b>Definition</b> <a href="GrayLevelImage2D_8hpp_source.html#l00009">GrayLevelImage2D.hpp:9</a></div></div>
<div class="ttc" id="aclassGrayLevelImage2D_html_abef26bf39fa708316b52ce973396c43a"><div class="ttname"><a href="classGrayLevelImage2D.html#abef26bf39fa708316b52ce973396c43a">GrayLevelImage2D::w</a></div><div class="ttdeci">int w() const</div></div>
<div class="ttc" id="aclassGrayLevelImage2D_html_aff7a95b8419a38404da536db4f24dfec"><div class="ttname"><a href="classGrayLevelImage2D.html#aff7a95b8419a38404da536db4f24dfec">GrayLevelImage2D::h</a></div><div class="ttdeci">int h() const</div></div>
</div><!-- fragment --><p>On utilisera la classe <a href="http://www.cplusplus.com/reference/vector/vector/">std::vector</a> de la STL. Cela nous évitera toute allocation dynamique ! Il suffit soit de l'initialiser avec la bonne taille (i.e. donc largeur * hauteur), soit d'appeler vector::resize pour changer la taille. Ecrivez donc cette première version de la classe <a class="el" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>, avec les deux constructeurs précisés. Faut-il réécrire le constructeur par copie et l'affectation ?</p>
<p>NB: les méthodes seront écrites dans un fichier source GrayLevelImage2D.cpp.</p>
<h1><a class="anchor" id="cpp_tp1_3"></a>
3 - Accesseurs utiles (taille, valeurs de niveaux de gris).</h1>
<p>Le principe est que les valeurs de l'image sont stockées les unes à la suite des autres en balayant l'axe des x d'abord. Par exemple, cela donne les indices suivants dans le tableau <code>m_data:</code> </p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Pixel (x,y):   </th><th class="markdownTableHeadNone">(0,0)   </th><th class="markdownTableHeadNone">(1,0)   </th><th class="markdownTableHeadNone">...   </th><th class="markdownTableHeadNone">(w-1,0)   </th><th class="markdownTableHeadNone">(0,1)   </th><th class="markdownTableHeadNone">(1,1)   </th><th class="markdownTableHeadNone">...   </th><th class="markdownTableHeadNone">(w-1,h-1)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Indice   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">w-1   </td><td class="markdownTableBodyNone">w   </td><td class="markdownTableBodyNone">w+1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">w*(h-1)+w-1   </td></tr>
</table>
<p>On écrira donc une méthode (privée) <code>int index( int x, int y ) const</code> qui retourne l'indice du pixel de coordonnées <code>(x,y)</code>.</p>
<p>Cette fonction sera utilisée partout où il faut convertir les coordonnées en l'indice dans <code>m_data</code>.</p>
<p>On ajoutera aussi les méthodes suivantes:</p>
<div class="fragment"><div class="line"><span class="comment">  /// @return la largeur de l&#39;image.</span></div>
<div class="line">  <span class="keywordtype">int</span> w() <span class="keyword">const</span>;<span class="comment"></span></div>
<div class="line"><span class="comment">  /// @return la hauteur de l&#39;image.</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">int</span> h() <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">     Accesseur read-only à la valeur d&#39;un pixel.</span></div>
<div class="line"><span class="comment">     @return la valeur du pixel(i,j)</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  GrayLevel at( <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j ) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">     Accesseur read-write à la valeur d&#39;un pixel.</span></div>
<div class="line"><span class="comment">     @return une référence à la valeur du pixel(i,j)</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  GrayLevel&amp; at( <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j );</div>
</div><!-- fragment --><p>On testera les méthodes précédents en créant un fichier testGrayLevelImage2D.cpp. Vous pourrez utiliser le <code>Makefile</code> suivant:</p>
<pre class="fragment">LD=g++
CXX=g++ -Wall -std=c++11 -g -c

EXEC_SRC=\
	testGrayLevelImage2D.cpp

MODULE_SRC=\
	GrayLevelImage2D.cpp

MODULE_OBJ=${MODULE_SRC:.cpp=.o}
EXEC_OBJ=${EXEC_SRC:.cpp=.o}

EXEC_PRG=${EXEC_SRC:.cpp=}

all: ${EXEC_PRG} ${MODULE_OBJ} ${EXEC_OBJ}

testGrayLevelImage2D: testGrayLevelImage2D.o ${MODULE_OBJ}
	${LD} ${MODULE_OBJ} $&lt; -o $@

.cpp.o: %.cpp %.hpp
	${CXX} $&lt;

clean:
	rm -f ${EXEC_PRG} ${MODULE_OBJ} ${EXEC_OBJ}

</pre><p>Il vous suffira alors à vous de taper la commande <code>make</code> dans votre terminal pour que tout soit compilé.</p>
<p>Le programme principal testGrayLevelImage2D.cpp contiendra au moins:</p>
<div class="fragment"><div class="line">    <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> img( 8, 8, 5 ); <span class="comment">// imagette 8x8 remplie de 5</span></div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> y = 0; y &lt; img.h(); ++y )</div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> x = 0; x &lt; img.w(); ++x )</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; (<span class="keywordtype">int</span>) img.at( x, y ); <span class="comment">// la conversion permet de voir les caractères sous forme d&#39;entiers.</span></div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>qui devra fonctionner et afficher (bien sûr): </p><pre class="fragment"> 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5</pre><h1><a class="anchor" id="cpp_tp1_4"></a>
4 - Un iterateur pour les images</h1>
<p>Le programme précédent montre comment accéder pixel par pixel à l'image. L'avantage est que l'on donne un sens géométrique aux indices dans le tableau. C'est donc tout à fait pertinent dans les cas où la position géométrique du pixel doit être exploité. En revanche, il existe un certain nombre d'algorithmes où l'on ne fait que traiter en séquence les valeurs de pixel, sans se préoccuper de leur position. On peut citer:</p><ul>
<li>remplissage avec un valeur</li>
<li>seuillage de l'image (toutes les valeurs inférieurs à <em>s</em> sont noires, les autres blanches), par exemple par la méthode d'Otsu.</li>
<li>copie de l'image</li>
<li>calcul de l'histogramme</li>
<li>égalisation</li>
<li>correction gamma</li>
<li>import/export dans les formats de données "bruts".</li>
<li>...</li>
</ul>
<p>Dans ce cas, il est utile de pouvoir énumérer (le plus rapidement possible) les valeurs de l'image, comme si on parcourait directement le tableau <code>m_data</code>.</p>
<p>Pour faire tout cela proprement, on introduit une classe Iterator, interne à <a class="el" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>, que l'on fait dériver de <code>std::vector&lt;<a class="el" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>&gt;::iterator</code>. Cela permet de récupérer tous les services usuels des itérateurs, en ajoutant des possibilités supplémentaires si on veut faire évoluer nos itérateurs. On écrira donc:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> {</div>
<div class="line">...</div>
<div class="line">  <span class="keyword">struct </span>Iterator : <span class="keyword">public</span> Container::iterator {</div>
<div class="line">    <span class="comment">// Constructeur à partir d&#39;une image et des coordonnées d&#39;un pixel (x,y).</span></div>
<div class="line">    <span class="comment">// NB: doit appeler le constructeur de la superclasse.</span></div>
<div class="line">    Iterator( <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>&amp; Image, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y );</div>
<div class="line">  };</div>
<div class="line">...</div>
<div class="line">};</div>
</div><!-- fragment --><p>Il ne reste plus qu'à écrire le constructeur de Iterator à partir d'une image et des coordonnées d'un pixel. Attention, on note que dans <code>GrayLevelImage2D.cpp</code>, le prototype du constructeur de <code>Iterator</code> est:</p>
<div class="fragment"><div class="line">GrayLevelImage2D::Iterator::Iterator( <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>&amp; Image, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )</div>
<div class="line">...</div>
</div><!-- fragment --><p>On utilise d'une part la méthode <code>std::vector::begin()</code> appliquée au vecteur <code>m_data</code> pour récupérer un itérateur sur le début du tableau, puis il suffit d'additionner l'indice du pixel (x,y) pour décaler l'itérateur au bon endroit. Cela donne</p>
<div class="fragment"><div class="line">GrayLevelImage2D::Iterator::Iterator( <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>&amp; Image, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )</div>
<div class="line"> : Container::iterator( image.m_data.begin() + image.index( x, y ) )</div>
<div class="line"> {}</div>
</div><!-- fragment --><p>Il suffit maintenant d'écrire une méthode <code>Iterator start( int x,
   int y )</code> dans <a class="el" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> qui fabrique l'itérateur qui pointe sur la valeur du pixel (x,y) (c'est juste le bon appel du constructeur de Iterator), puis les méthodes <code>begin</code> et <code>end</code> qui sont des cas particuliers de <code>start</code>.</p>
<div class="fragment"><div class="line">Iterator begin();  <span class="comment">// pixel (0,0) -&gt; le tout premier</span></div>
<div class="line">Iterator end();    <span class="comment">// pixel (0,h) -&gt; juste après le dernier (pareil que (w,h-1)).</span></div>
<div class="line">Iterator start( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y );</div>
</div><!-- fragment --><p>Avec cela, on peut remplacer l'affichage de la section précédente (<a class="el" href="cpp_tp1.html#cpp_tp1_3">3 - Accesseurs utiles (taille, valeurs de niveaux de gris).</a>) par le code suivant:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> ( <a class="code hl_struct" href="structGrayLevelImage2D_1_1Iterator.html">GrayLevelImage2D::Iterator</a> it = img.begin(), itE = img.end(); it != itE; ++it )</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; (<span class="keywordtype">int</span>) *it; <span class="comment">// la conversion permet de voir les caractères sous forme d&#39;entiers.</span></div>
<div class="ttc" id="astructGrayLevelImage2D_1_1Iterator_html"><div class="ttname"><a href="structGrayLevelImage2D_1_1Iterator.html">GrayLevelImage2D::Iterator</a></div><div class="ttdef"><b>Definition</b> <a href="GrayLevelImage2D_8hpp_source.html#l00020">GrayLevelImage2D.hpp:20</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="cpp_tp1_5"></a>
5 - Import / Export en format PGM</h1>
<p>Le format PGM [<a href="http://fr.wikipedia.org/wiki/Portable_pixmap">http://fr.wikipedia.org/wiki/Portable_pixmap</a> PBM image format] permet de stocker très simplement les images en niveaux de gris sous forme de fichier. Le format PGM a deux formes, selon que les valeurs sont stockées en clair sous forme ASCII (le fichier est lisible et éditable, mais prend 3 fois plus de place sur le disque), ou stockées en format brut octet par octet.</p>
<p>Exemple d'une image 256 x 256 stockée sous forme ascii. </p><pre class="fragment">P2
# CREATOR: XV Version 3.10a  Rev: 12/29/94 (PNG patch 1.2)
256 256
255
0 0 1 10 53 67 45 0 12 12 ...</pre><p>Exemple d'une image 256 x 256 stockée sous forme brute. </p><pre class="fragment">P5
# CREATOR: XV Version 3.10a  Rev: 12/29/94 (PNG patch 1.2)
256 256
255
... le reste est illisible         </pre><p>Nous allons utiliser les flux (<code>stream</code>) pour représenter les fichiers en entrée ou en sortie. On incluera les entêtes suivants:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span> <span class="comment">// chaînes de caractères</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span> <span class="comment">// flux sur les fichiers</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span> <span class="comment">// flux sur les chaînes de caractères</span></div>
</div><!-- fragment --><p>On écrira donc les méthodes suivantes pour la classe <a class="el" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> importPGM( std::istream &amp; input );</div>
<div class="line"><span class="keywordtype">bool</span> exportPGM( std::ostream &amp; output, <span class="keywordtype">bool</span> ascii_mode = <span class="keyword">true</span> ) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>Maintenant, pour ouvrir un fichier "toto.pgm" en lecture on écrira:</p>
<div class="fragment"><div class="line"><span class="comment">// Ouvre le flux en entrée sur le fichier &quot;toto.pgm&quot;</span></div>
<div class="line">ifstream input( <span class="stringliteral">&quot;toto.pgm&quot;</span>, std::ios::binary ); <span class="comment">// le ios::binary est nécessaire seulement sous Windows.</span></div>
<div class="line"><span class="comment">// teste si tout va bien</span></div>
<div class="line"><span class="keywordflow">if</span> ( ! input.good() ) std::cerr &lt;&lt; <span class="stringliteral">&quot;Probleme !&quot;</span>;</div>
</div><!-- fragment --><p>Une fois qu'un flux est ouvert, c'est facile de lire dedans avec les opérateuurs de flux <code>&gt;&gt;</code> et <code>std::getline</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// par exemple, lit un entier:</span></div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line">input &gt;&gt; i;</div>
<div class="line"><span class="comment">// par exemple, lit un mot (s&#39;arrête à un caractères de séparation).</span></div>
<div class="line">std::string s;</div>
<div class="line">input &gt;&gt; s;   </div>
<div class="line"><span class="comment">// par exemple, lit toute une ligne dans une chaîne de caractères.</span></div>
<div class="line">std::getline( input, str );</div>
<div class="line"><span class="keywordflow">if</span> (( str != <span class="stringliteral">&quot;&quot;</span> ) &amp;&amp; (str[0]==<span class="charliteral">&#39;#&#39;</span>)) </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;C&#39;est un commentaire ! J&#39;ignore superbement&quot;</span>;</div>
</div><!-- fragment --><p>On peut aussi utiliser une chaîne de caractères comme un flux, grâce aux classes <a href="http://www.cplusplus.com/reference/sstream/istringstream/">istringstream</a> et <a href="http://www.cplusplus.com/reference/sstream/ostringstream/">ostringstream</a>. Ainsi, la chaîne "123 45 54" est décomposée en trois entiers ainsi:</p>
<div class="fragment"><div class="line">std::string s( <span class="stringliteral">&quot;123 45 54&quot;</span> );</div>
<div class="line">std::istringstream istr( s );</div>
<div class="line"><span class="keywordtype">int</span> x,y,z;</div>
<div class="line">istr &gt;&gt; x &gt;&gt; y &gt;&gt; z; <span class="comment">// x=123, y=45, z=54.</span></div>
</div><!-- fragment --><p>Ecrire les méthodes <code>bool importPGM( std::istream &amp; input )</code> et <code>bool exportPGM( std::ostream &amp; output, bool ascii_mode ) const</code> de la classe <code><a class="el" href="classGrayLevelImage2D.html">GrayLevelImage2D</a></code>, en utilisant les flux.</p>
<p>On pourra maintenant lire un fichier image "lena.pgm" ainsi:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> img;</div>
<div class="line">ifstream input( <span class="stringliteral">&quot;lena.pgm&quot;</span> );</div>
<div class="line"><span class="keywordtype">bool</span> ok = img.importPGM( input );</div>
<div class="line"><span class="keywordflow">if</span> ( !ok ) std::cerr &lt;&lt; <span class="stringliteral">&quot;Hum !&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">input.close();</div>
</div><!-- fragment --><p>On testera nos fonctions avec le mini-programme <code><a class="el" href="double-brightness_8cpp_source.html">double-brightness.cpp</a></code> suivant, qui double la brillance d'une image:</p>
<div class="fragment"><div class="line"><span class="comment">// double-brightness.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;GrayLevelImage2D.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> GrayLevelImage2D::GrayLevel GrayLevel;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structGrayLevelImage2D_1_1Iterator.html">GrayLevelImage2D::Iterator</a>  Iterator;</div>
<div class="line">  <span class="keywordflow">if</span> ( argc &lt; 3 ) </div>
<div class="line">    { </div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: double-brightness &lt;input.pgm&gt; &lt;output.pgm&gt;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">  <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> img;</div>
<div class="line">  ifstream input( argv[1] ); <span class="comment">// récupère le 1er argument.</span></div>
<div class="line">  <span class="keywordtype">bool</span> ok = img.importPGM( input );</div>
<div class="line">  <span class="keywordflow">if</span> ( !ok )</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Error reading input file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">       <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  input.close();</div>
<div class="line">  <span class="keywordflow">for</span> ( Iterator it = img.<a class="code hl_function" href="classGrayLevelImage2D.html#afda19a1d74371e81d40e7adb28ba3120">begin</a>(), itE = img.end(); it != itE; ++it )</div>
<div class="line">    {</div>
<div class="line">      *it = ( 2 * (int)(*it) ) % 256;</div>
<div class="line">    }</div>
<div class="line">  ofstream output( argv[2] ); <span class="comment">// récupère le 2ème argument.</span></div>
<div class="line">  ok = img.exportPGM( output, <span class="keyword">false</span> );</div>
<div class="line">  <span class="keywordflow">if</span> ( !ok )</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Error writing output file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">       <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  output.close();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassGrayLevelImage2D_html_afda19a1d74371e81d40e7adb28ba3120"><div class="ttname"><a href="classGrayLevelImage2D.html#afda19a1d74371e81d40e7adb28ba3120">GrayLevelImage2D::begin</a></div><div class="ttdeci">Iterator begin()</div><div class="ttdoc">[gli2d-sec3]</div></div>
</div><!-- fragment --><p>N'oubliez pas de mettre à jour le <code>Makefile</code>. Si vous l'exécutez sur l'image <code>"lena.pgm"</code>, l'affichage donne:</p>
<div class="image">
<img src="lena-d.png" alt=""/>
<div class="caption">
Image lena.pgm après appel de double-brightness.</div></div>
<dl class="section note"><dt>Note</dt><dd><b>Important</b>. Lorsque vous lisez un fichier sous forme ASCII pour récupérez des nombres ou des chaînes de caractères, vous voulez que les espaces ne soient pas des données mais juste des séparateurs. Pour être sûr d'avoir ce comportement (qui est celui par défaut), on écrit la commande suivante dans le flux d'entrée:</dd></dl>
<div class="fragment"><div class="line">input &gt;&gt; std::skipws;</div>
</div><!-- fragment --><p>A l'inverse, lorsque vous lisez des données brutes comme des suites d'octets, vous voulez que les espaces soient bien l'octet 32 et non des séparateurs, pareil pour les retours chariots (13). Pour être sûr d'avoir ce comportement, on écrit la commande suivante dans le flux d'entrée:</p>
<div class="fragment"><div class="line">input &gt;&gt; std::noskipws;</div>
</div><!-- fragment --><p>N'oubliez pas des les utiliser à bon escient dans la fonction <code>bool importPGM( std::istream &amp; input )</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Dans cette question, il suffit d'utiliser les itérateurs pour lire ou écrire dans les images.</dd></dl>
<h1><a class="anchor" id="cpp_tp1_6"></a>
6 - Filtrage médian</h1>
<p>Le filtrage médian est un algorithme très simple d'élimination de bruit dans une image. Il est très pertinent pour ce que l'on appelle le bruit impulsionnel, causé par des capteurs défectueux, ce qui sature ou désature complètement la valeur de certains pixels (ils deviennent tout blanc ou tout noir).</p>
<p>Son principe est le suivant. On se donne un voisinage autour de chaque pixel (par exemple un voisinage 3x3). On met toutes les valeurs de ces pixels dans un tableau (ici 9 valeurs). On remplace la valeur du pixel par la valeur médiane des valeurs du tableau (On peut par exemple trier le tableau et prendre la 5ème valeur).</p>
<p>Implémenter un algorithme de filtrage médian sous forme de commande en-ligne <code>filtrage-median</code> similaire à <code>double-brightness</code>. On pourra donner en plus un paramètre entier <em>k</em>, qui indique la taille du voisinage (2k+1 x 2k+1) autour de chaque point.</p>
<center> <table class="doxtable">
<tr>
<td>pourcentage de pixels "bruités" </td><td>image source </td><td>taille voisinage </td><td>résultat médian  </td></tr>
<tr>
<td>10% </td><td><img src="lena-imp-0_1.png" alt="" class="inline"/> </td><td>3x3 </td><td><img src="lena-imp-0_1-fm-1.png" alt="" class="inline"/>  </td></tr>
<tr>
<td>50% </td><td><img src="lena-imp-0_5.png" alt="" class="inline"/> </td><td>7x7 </td><td><img src="lena-imp-0_5-fm-3.png" alt="" class="inline"/>  </td></tr>
<tr>
<td>90% </td><td><img src="lena-imp-0_9.png" alt="" class="inline"/> </td><td>31x31 </td><td><img src="lena-imp-0_9-fm-15.png" alt="" class="inline"/>  </td></tr>
</table>
</center><dl class="section note"><dt>Note</dt><dd>Pour trier un tableau (ou un <code>vector</code>), n'oubliez pas d'utiliser la fonction <code>std::sort</code> définie dans le header <code>&lt;algorithm&gt;</code>. Par exemple, on peut écrire:</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> x[] = { 0.4, 13.2, 5.7, 4.2, 8.6 };</div>
<div class="line">std::sort( x, x+5 ); <span class="comment">// x vaut { 0.4, 4.2, 5.7, 8.6, 13.2 };</span></div>
<div class="line"><span class="keywordtype">double</span> med = x[ 2 ]; <span class="comment">// valeur médiane</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Attention, dans cette question, on <b>ne</b> <b>peut</b> <b>se</b> <b>contenter</b> <b>des</b> <b>itérateurs</b> pour parcourir l'image, il faudra <b>aussi</b> faire des accès directs dans l'image avec des coordonnées pour obtenir la valeur du pixel (méthode <code><a class="el" href="classGrayLevelImage2D.html#a4f25298244f6cdb4a7dd9c3aaa5e60f8">GrayLevelImage2D::at</a></code>). Attention aussi aux pixels proches du bord de l'image, leur voisinage est alors plus limité.</dd></dl>
<h1><a class="anchor" id="cpp_tp1_7"></a>
7 - Histogramme et Histogramme cumulé d'une image.</h1>
<p>L'<b>histogramme</b> d'une image \(I\) en 256 niveaux de gris est une fonction \(h_I\) qui associe à chaque niveau de gris <em>i</em> la proportion de pixels qui ont exactement ce niveau de gris:</p>
<p class="formulaDsp">
\[ h_I: \{0,\ldots,255 \} \rightarrow \lbrack 0,1 \rbrack, \quad i \mapsto h_I( i ) = \frac{\#\{(x,y), I(x,y)=i \}}{\#\{(x,y)\}} \]
</p>
<p>où # désigne le nombre d'éléments d'un ensemble et les (x,y) sont les pixels de l'image. En un sens, c'est la probabilité qu'un pixel pris au hasard ait un niveau de gris donné. Un autre outil important est l'<b>histogramme</b> <b>cummulé</b> \(H_I\) d'une image \(I\). Il s'agit simplement d'associer à chaque niveau de gris <em>i</em> la proportion de pixels qui ont ce niveau de gris ou moins.</p>
<p class="formulaDsp">
\[ H_I: \{0,\ldots,255 \} \rightarrow \lbrack 0,1 \rbrack, \quad i \mapsto H_I( i ) = \frac{\#\{(x,y), I(x,y) \le i \}}{\#\{(x,y)\}} \]
</p>
<p>On note facilement que \( H_I(g) = \sum_{i=0}^g h_I(i) \).</p>
<p>Un histogramme est dit <em>bien</em> <em>balancé</em> si à peu près tous les niveaux de gris sont équiprobables. En général, une bonne photo a un histogramme bien balancé. Une photo <em>sous-exposée</em> a tendance à avoir un histogramme décalé vers les niveaux de gris sombres, tandis qu'un photo <em>sur-exposée</em> a tendance à avoir un histogramme décalé vers les niveaux de gris clairs.</p>
<center> <table class="doxtable">
<tr>
<td><div class="image">
<img src="lena.png" alt=""/>
<div class="caption">
Image lena.pgm</div></div>
  </td><td><div class="image">
<img src="lena-hH.png" alt=""/>
<div class="caption">
Histogramme (à gauche) et histogramme cumulé (à droite)</div></div>
   </td></tr>
</table>
</center><p>Or, on peut corriger automatiquement une image pour que son histogramme soit bien balancé. Cette opération s'appelle <b>égalisation</b> d'histogramme. Comment est-ce possible ? Il suffit de trouver une fonction \( f: \{0,\ldots,255\} \rightarrow \{0,\ldots,255\} \) qui transforme les niveaux de gris de façon à éclaircir ou assombrir au besoin l'image. Quelle est la bonne fonction <em>f</em> ? On la trouve en remarquant que l'histogramme cumulé d'une image bien balancée est la simplement la fonction \( i \mapsto
i/255 \). On écrit donc:</p>
<p class="formulaDsp">
\[ \frac{i}{255} = H_{f \circ I}(i) \quad = \frac{\#\{(x,y), f \circ I(x,y) \le i \}}{\#\{(x,y)\}}
  \quad = \frac{\#\{(x,y), I(x,y) \le f^{-1}(i) \}}{\#\{(x,y)\}}
  \quad = H_{I}( f^{-1}(i))
  \]
</p>
<p>En posant \( j=f^{-1}(i) \), il vient \( i = f(j) \), et l'équation précédente s'écrit:</p>
<p class="formulaDsp">
\[ \frac{f(j)}{255} =  H_{I}( j ) \]
</p>
<p>La fonction d'<b>égalisation</b> <em>f</em> est donc tout simplement :</p>
<p class="formulaDsp">
\[ f : j \mapsto f(j) = 255 \times H_{I}( j ) \]
</p>
<p>Ecrivez une classe <code>Histogramme</code> qui contiendra deux tableaux de 256 entrées double, l'un pour \(h_I\), l'autre pour \(H_I\). Cette classe aura une méthode <code>void init( <a class="el" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> &amp; img )</code>, qui parcourera l'image pour calculer son histogramme et son histogramme cummulé.</p>
<p>Ecrivez alors la méthode <code>int egalisation( int j ) const</code> dans la classe <code>Histogramme</code>, qui est simplement la fonction <em>f</em> ci-dessus. Il ne vaut reste plus qu'à faire le programme <code>egalise.cpp</code> qui utilise cette fonction d'égalisation sur tous les pixels de l'image. Sur l'image <code>lena.pgm</code> (légèrement sous-exposée) cela donne:</p>
<p>NB: On pourra regarder avec <code>gimp</code> l'histogramme des images (menu Couleurs &gt; Niveaux).</p>
<center> <table class="doxtable">
<tr>
<td>image source </td><td>image égalisée  </td></tr>
<tr>
<td><img src="lena.png" alt="" class="inline"/> </td><td><img src="lena-eg.png" alt="" class="inline"/>  </td></tr>
</table>
</center><dl class="section note"><dt>Note</dt><dd>Dans cette question, les itérateurs suffisent pour lire les valeurs des pixels ou ensuite les modifier dans l'égalisation.</dd></dl>
<h1><a class="anchor" id="cpp_tp1_8"></a>
8 - Rehaussement de contraste par filtrage par convolution</h1>
<p>Une autre façon de traiter les images est de corriger les valeurs d'un pixel en fonction de la valeur de ses voisins et de lui-même. En générale la transformation ne dépend pas de la position du pixel dans l'image. On parle alors de <em>convolution</em> <em>spatiale</em>. Par exemple, si on suppose qu'on ne regarde que la valeur des 8 voisins plus de soi-même, on représente le filtre de convolution par une matrice 3x3:</p>
<p class="formulaDsp">
\[ A := \begin{array}{|c|c|c|} \hline a_{-1,-1} &amp; a_{0,-1} &amp; a_{1,-1} \\ \hline
   a_{-1,0} &amp; a_{0,0} &amp; a_{1,0} \\ \hline
   a_{-1,1} &amp; a_{0,1} &amp; a_{1,1} \\ \hline \end{array}\]
</p>
<p>La valeur du pixel \( p(x,y) \) est calculée en prenant les valeurs des pixels autour multipliées par le poids correspondant dans la matrice \(A\). Autrement dit:</p>
<p class="formulaDsp">
\[ p(x,y) := a_{-1,-1} p(x-1,y-1) + a_{0,-1} p(x,y-1) + a_{1,-1} p(x+1,y-1) + \cdots + a_{1,1} p(x+1,y+1) \]
</p>
<p>Pour implémenter un filtre de convolution, il suffit donc juste de faire le calcul précédent pour chaque pixel.</p>
<p>Ci-dessous, quelques exemples de filtre "classiques":</p>
<p class="formulaDsp">
\[ M :=\begin{array}{|c|c|c|}\hline 1/9 &amp; 1/9 &amp; 1/9 \\ \hline
   1/9 &amp; 1/9 &amp; 1/9 \\ \hline
   1/9 &amp; 1/9 &amp; 1/9 \\ \hline \end{array} \qquad 
   L :=\begin{array}{|c|c|c|}\hline 0 &amp; -1/4 &amp; 0 \\ \hline
   -1/4 &amp; 1 &amp; -1/4 \\ \hline
   0 &amp; -1/4 &amp; 0 \\ \hline \end{array} \]
</p>
<p>Le filtre <em>M</em> moyenne les valeurs autour de chaque pixel et rend l'image un peu plus floue, tout en éliminant des bruits dans l'image. Le filtre <em>L</em>, dit "Laplacien", produit une image avec des valeurs positives ou négatives. Il détecte en fait les contours de l'image. Il vaut 0 là où l'image est homogène (plus précisément là où l'image est un aplat linéaire), et est différent de 0 là où il y a des fortes variations.</p>
<p>Pour rehausser les contrastes, c'est-à-dire rendre l'image plus nette, un moyen est d'additionner à l'image ses propres contours (ou un coefficient fois les contours). On fabrique donc le filtre \( R_\alpha \) en additionnant au filtre identité <em>Id</em> un coefficient \(
   \alpha \) fois la matrice laplacien <em>L</em>. Le filtre identité vaut simplement 1 au milieu et 0 ailleurs. On obtient donc:</p>
<p class="formulaDsp">
\[ R_\alpha :=  \begin{array}{|c|c|c|}\hline 0 &amp; -\alpha/4 &amp; 0 \\ \hline
   -\alpha/4 &amp; 1+\alpha &amp; -\alpha/4 \\ \hline
   0  &amp; -\alpha/4 &amp; 0 \\ \hline \end{array} \]
</p>
<p>Ci-dessous quelques exemples. Vous pourrez tester plusieurs \( \alpha \).</p>
<center> <table class="doxtable">
<tr>
<td>image source </td><td>image floutée par <em>M</em>  </td><td>image plus nette par \( R_\alpha \)  </td></tr>
<tr>
<td><img src="lena.png" alt="" class="inline"/> </td><td><img src="lena-flou.png" alt="" class="inline"/> </td><td><img src="lena-net.png" alt="" class="inline"/>  </td></tr>
</table>
</center><p>Ecrivez donc un programme qui permet à l'utilisateur de rendre une image plus nette, en fonction d'un coefficient \( \alpha \) donné en paramètre par l'utilisateur.</p>
<dl class="section note"><dt>Note</dt><dd>Attention, dans cette question, on ne peut se contenter des itérateurs pour parcourir l'image, il faudra aussi faire des accès directs dans l'image avec des coordonnées pour obtenir la valeur du pixel (méthode <code><a class="el" href="classGrayLevelImage2D.html#a4f25298244f6cdb4a7dd9c3aaa5e60f8">GrayLevelImage2D::at</a></code>).</dd></dl>
<h1><a class="anchor" id="cpp_tp1_9"></a>
9 - Générateur de bruit</h1>
<p>Mais pourquoi voudrait-on abîmer les images ? Une raison académique: pour tester ensuite les algorithmes de filtrage de bruit et de restauration. Une autre raison est parfois esthétique, par exemple pour donner l'illusion qu'une image fabriquée par ordinateur est une vraie photo. Le code ci-dessous vous montre comment on a généré le bruit impulsionnel ci-dessus.</p>
<div class="fragment"><div class="line"><span class="comment">// bruit-impulsionnel.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;GrayLevelImage2D.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> rand01()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)random() / (double)RAND_MAX;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> GrayLevelImage2D::GrayLevel GrayLevel;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structGrayLevelImage2D_1_1Iterator.html">GrayLevelImage2D::Iterator</a> Iterator;</div>
<div class="line">  <span class="keywordflow">if</span> ( argc &lt; 3 ) </div>
<div class="line">    { </div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: bruit-impulsionnel &lt;input.pgm&gt; &lt;output.pgm&gt; &lt;prob&gt;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">  <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> img;</div>
<div class="line">  ifstream input( argv[1] ); <span class="comment">// récupère le 1er argument.</span></div>
<div class="line">  <span class="keywordtype">bool</span> ok = img.importPGM( input );</div>
<div class="line">  <span class="keywordflow">if</span> ( !ok )</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Error reading input file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">       <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  input.close();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> prob = (argc &gt; 3) ? atof( argv[ 3 ] ) : 0.01; <span class="comment">// récupère la probabilité de bruit</span></div>
<div class="line">  <span class="keywordflow">for</span> ( Iterator it = img.<a class="code hl_function" href="classGrayLevelImage2D.html#afda19a1d74371e81d40e7adb28ba3120">begin</a>(), itE = img.end(); it != itE; ++it )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> ( rand01() &lt; prob )</div>
<div class="line">        { <span class="comment">// sature dans un sens (noir=0) ou l&#39;autre (blanc=255)</span></div>
<div class="line">          *it = ( rand01() &lt; 0.5 ) ? 0 : 255;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">  ofstream output( argv[2] ); <span class="comment">// récupère le 2ème argument.</span></div>
<div class="line">  ok = img.exportPGM( output, <span class="keyword">false</span> );</div>
<div class="line">  <span class="keywordflow">if</span> ( !ok )</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Error writing output file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">       <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  output.close();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Il est plus réaliste d'appliquer un bruit Gaussien sur les images, c'est-à-dire une perturbation de la valeur de gris par un écart qui suit une loi normale (ou Gaussienne). La <a href="http://fr.wikipedia.org/wiki/M%C3%A9thode_de_Box-Muller">méthode de Box-Muller</a> est la plus simple pour le faire. Elle créé deux valeurs aléatoires qui suivent une loi normale à partir de deux valeurs qui suivent une loi uniforme (genre <code>rand01()</code>).</p>
<p>Ecrivez donc la commande <code>bruit-gaussien.cpp</code> en modifiant le fichier <code><a class="el" href="bruit-impulsionnel_8cpp_source.html">bruit-impulsionnel.cpp</a></code> ci-dessus. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 9 2023 11:45:38 for INFO702 - TPs by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
