<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INFO702 - TPs: TP0 Programmation objet et polymorphisme, scène graphique et collisions, librairie Qt</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INFO702 - TPs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP0 Programmation objet et polymorphisme, scène graphique et collisions, librairie Qt</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#cpp_tp0_1">1 - Objectifs, pointeurs utiles</a></li>
<li class="level1"><a href="#cpp_tp0_2">2 - Prise en main du code, compilation avec Qt</a></li>
<li class="level1"><a href="#cpp_tp0_3">3 - Premiers objets graphiques</a></li>
<li class="level1"><a href="#cpp_tp0_3_1">3.1 - classe Rectangle (graphique)</a></li>
<li class="level1"><a href="#cpp_tp0_3_2">3.2 - classe SpaceTruck</a></li>
<li class="level1"><a href="#cpp_tp0_4">4 - Objets complexes par assemblage de formes simples</a></li>
<li class="level1"><a href="#cpp_tp0_5">5 - Transformations géométriques</a></li>
<li class="level1"><a href="#cpp_tp0_6">6 - Des images, des figures</a></li>
<li class="level1"><a href="#cpp_tp0_7">7. Développements optionnels</a></li>
<li class="level1"><a href="#cpp_tp0_8">TP à rendre</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="cpp_tp0_1"></a>
1 - Objectifs, pointeurs utiles</h1>
<p>L'objectif de ce TP est de vous familiariser avec la programmation objet classique en C++. L'idée est de partir d'une base de code déjà conséquente et de l'enrichir progressivement. Le focus est sur le polymorphisme (donc les méthodes virtuelles). Le prétexte est de vous faire travailler sur un programme graphique temps réel, qui gère plein d'objets différents dont on devra détecter les collisions.</p>
<p>La généricité se fera donc au travers du polymorphisme. A l'issue de cette séance, vous maîtriserez:</p>
<ul>
<li>la déclaration d'une classe/structure, de ses constructeurs, de ses données membre</li>
<li>la définition des méthodes de la classe dans un fichier source</li>
<li>la rédéfinition de méthodes virtuelles</li>
<li>l'utilisation de certains éléments de la librairie graphique Qt</li>
</ul>
<p>Les sites suivants pourront être utile pendant le TP:</p><ul>
<li>[<a href="http://www.cppreference.com/">http://www.cppreference.com/</a> Site C/C++: références très complètes]</li>
<li>[<a href="http://www.cplusplus.com/">http://www.cplusplus.com/</a> Site C++: tutoriels, références]</li>
<li>[<a href="http://www.parashift.com/c++-faq-lite/index.html">http://www.parashift.com/c++-faq-lite/index.html</a> C++ FAQ]</li>
<li>[<a href="https://doc.qt.io/qt-5">https://doc.qt.io/qt-5</a> doc Qt5] [<a href="https://doc.qt.io/qt-6">https://doc.qt.io/qt-6</a> doc Qt6].</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Normalement le code fonctionne indifféremment sous Qt5 ou Qt6 (en tous cas sous MacOS).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Il n'y a pas d'IDE recommandé plus particulièrement qu'un autre, mais je constate:<ul>
<li>un étudiant sous Linux avec un éditeur de texte (vim, emacs, sublime text, gedit) et la compilation via <code>make</code> démarre le TP en 5 minutes.</li>
<li>un étudiant avec son IDE déjà bien configuré avant d'arriver en TP gagne 1h sur l'étudiant qui installe son IDE pendant le TP.</li>
<li>la plupart des étudiants utilisent CodeBlocks, parfois Eclipse, parfois Visual Studio C++ ou CLion</li>
<li>Windows entraîne des problèmes supplémentaires: bibliothèques manquantes, programme exécuté qui ne s'arrête jamais (vérifiez votre antivirus, certains avaient des problèmes avec AVAST), gestion des fichiers bizarre (Windows a deux modes: texte et binaire; il faut donc rajouter le mode <code>ios::binary</code> ou <code>ios::text</code> à l'ouverture des fichiers)</li>
<li>Ce [<a href="https://github.com/MASTER-UNIV-SMB/INFO702-ENVIRONNEMENT-WINDOWS">https://github.com/MASTER-UNIV-SMB/INFO702-ENVIRONNEMENT-WINDOWS</a> site], gracieusement écrit par un ancien de la promotion, peut vous aider à installer Qt correctement sur un système Windows.</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="cpp_tp0_2"></a>
2 - Prise en main du code, compilation avec Qt</h1>
<p>On va donne une archive avec quelques fichiers tout prêts:</p>
<ul>
<li>collider.pro décrit la configuration du projet pour Qt. C'est là qu'on précise les fichiers sources, les exécutables, les dépendances à d'autres bibliothèques, les options de compilation.</li>
<li>collider.qrc décrit les ressources propres au projet, ici quelques images. Si vous voulez rajouter des images au projet, listez-les aussi ici.</li>
<li><a class="el" href="collider_8cpp_source.html">collider.cpp</a> est le programme principal qui initialise l'application Qt et instancie les formes graphiques</li>
<li><a class="el" href="objects_8hpp_source.html">objects.hpp</a> est le fichier entête de <a class="el" href="objects_8cpp_source.html">objects.cpp</a>, qui définit quelques constantes ainsi que les classes abstraites et concrètes des formes graphiques.</li>
<li><a class="el" href="objects_8cpp_source.html">objects.cpp</a> est le fichier source donnant le corps des méthodes déclarées dans <a class="el" href="objects_8hpp_source.html">objects.hpp</a></li>
</ul>
<p>Pour compiler un projet Qt, on utilise <code>qmake</code>, qui va créer un fichier <code>Makefile</code>, puis <code>make</code>. Si vous avez installé Qt dans un répertoire exotique, il faut donne le chemin complet de <code>qmake</code>. Ensuite tout est bien configuré.</p>
<pre class="fragment">$ qmake
$ make
$ ./collider                              # sous Linux
$ ./collider.app/Contents/MacOS/collider  # sous MacOS</pre><p>Normalement, vous avez un programme qui vous affiche quelque chose du genre ci-dessous:</p>
<div class="image">
<img src="tp0-2.png" alt=""/>
<div class="caption">
Application Qt initiale</div></div>
<p>Prenez le temps de regarder le code fourni (en commençant par <a class="el" href="collider_8cpp_source.html">collider.cpp</a>, puis <a class="el" href="objects_8hpp_source.html">objects.hpp</a> and <a class="el" href="objects_8cpp_source.html">objects.cpp</a>) et éventuellement chercher quelques explications dans la doc Qt [<a href="https://doc.qt.io/qt-5">https://doc.qt.io/qt-5</a> doc Qt5] [<a href="https://doc.qt.io/qt-6">https://doc.qt.io/qt-6</a> doc Qt6].</p>
<p>On notera la hiérarchie suivante pour nos formes graphiques (cf. class <a class="el" href="structGraphicalShape.html" title="Abstract class that describes a graphical object with additional methods for testing collisions.">GraphicalShape</a>):</p>
<div class="image">
<img src="class-hierarchy.png" alt=""/>
<div class="caption">
Hiérarchie des classes utilisées pour représenter les éléments graphiques</div></div>
<p>Evidemment, Qt offre déjà pas mal de choses dans la classe QGraphicsItem, mais nous allons faire nos propres formes graphiques avec algorithme randomisé de détection de collisions.</p>
<ul>
<li>la classe <a class="el" href="structGraphicalShape.html" title="Abstract class that describes a graphical object with additional methods for testing collisions.">GraphicalShape</a> est la classe de base pour nos formes. C'est une classe abstraite, qui hérite de QGraphicsItem et qui définit les méthodes virtuelles pures GraphicalShape::isInside et GraphicalShape::randomPoint.</li>
<li>la classe <a class="el" href="structMasterShape.html" title="Polymorphic class that represents the top class of any complex shape.">MasterShape</a> hérite de <a class="el" href="structGraphicalShape.html" title="Abstract class that describes a graphical object with additional methods for testing collisions.">GraphicalShape</a> et définit une forme maître ou principale. C'est elle qui est chargée de détecter les collisions, de vérifier que la forme reste dans les limites de la fenêtre. Elle contient aussi un pointeur vers sa forme graphique fille, qui est l'assemblage des formes graphiques qui la compose.</li>
<li>la classe <a class="el" href="structAsteroid.html" title="An asteroid is a simple shape that moves linearly in some direction.">Asteroid</a> hérite de <a class="el" href="structMasterShape.html" title="Polymorphic class that represents the top class of any complex shape.">MasterShape</a> et définit un objet astéroïde tout simple, qui se compose d'un seul disque et qui se déplace toujours dans la même direction et à la même vitesse.</li>
<li>la classe <a class="el" href="structDisk.html" title="A disk is a simple graphical shape.">Disk</a> hérite de <a class="el" href="structGraphicalShape.html" title="Abstract class that describes a graphical object with additional methods for testing collisions.">GraphicalShape</a> et représente une forme graphique toute simple, un disque de rayon donné centré en (0,0). Notez que cette classe connaît sa <a class="el" href="structMasterShape.html" title="Polymorphic class that represents the top class of any complex shape.">MasterShape</a>, ce qui lui permet de changer de couleur si une collision a été détectée.</li>
<li>la classe <a class="el" href="structLogicalScene.html" title="A class to store master shapes and to test their possible collisions with a randomized algorithm.">LogicalScene</a> stocke les objets graphiques "maîtres" et fournit les méthodes pour détecter les collisions entre ces objets. Dans le code fourni, 100 points sont testés entre chaque paire d'objets.</li>
</ul>
<h1><a class="anchor" id="cpp_tp0_3"></a>
3 - Premiers objets graphiques</h1>
<h1><a class="anchor" id="cpp_tp0_3_1"></a>
3.1 - classe Rectangle (graphique)</h1>
<p>Vous allez définir deux classes. D'abord une classe <code>Rectangle</code>, qui, sur le modèle de <a class="el" href="structDisk.html" title="A disk is a simple graphical shape.">Disk</a>, hérite de <a class="el" href="structGraphicalShape.html" title="Abstract class that describes a graphical object with additional methods for testing collisions.">GraphicalShape</a>. Elle représente un rectangle quelconque. Pour afficher un rectangle avec Qt, on utilise la méthode QPainter::drawRect. N'oubliez pas de redéfinir toutes les méthodes abstraites (i.e. virtuelles pures) de <a class="el" href="structGraphicalShape.html" title="Abstract class that describes a graphical object with additional methods for testing collisions.">GraphicalShape</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// A rectangle is a simple graphical shape. It points to its master shape</span></div>
<div class="line"><span class="comment">// in order to know in which color it must be painted.</span></div>
<div class="line"><span class="keyword">struct </span>Rectangle : <span class="keyword">public</span> <a class="code hl_struct" href="structGraphicalShape.html">GraphicalShape</a></div>
<div class="line">{</div>
<div class="line">  Rectangle( QPointF lo, QPointF hi, <span class="keyword">const</span> <a class="code hl_struct" href="structMasterShape.html">MasterShape</a>* master_shape );</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span>    paint( QPainter *painter, <span class="keyword">const</span> QStyleOptionGraphicsItem *option,</div>
<div class="line">                         QWidget *widget) <span class="keyword">override</span>;</div>
<div class="line">  <span class="keyword">virtual</span> QPointF randomPoint() <span class="keyword">const override</span>;</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">bool</span>    isInside( <span class="keyword">const</span> QPointF&amp; p ) <span class="keyword">const override</span>;</div>
<div class="line">  <span class="keyword">virtual</span> QRectF  boundingRect() <span class="keyword">const override</span>;</div>
<div class="line">  <span class="keyword">const</span> QPointF      _lo, _hi;</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_struct" href="structMasterShape.html">MasterShape</a>* _master_shape;</div>
<div class="line">};</div>
<div class="ttc" id="astructGraphicalShape_html"><div class="ttname"><a href="structGraphicalShape.html">GraphicalShape</a></div><div class="ttdoc">Abstract class that describes a graphical object with additional methods for testing collisions.</div><div class="ttdef"><b>Definition</b> <a href="objects_8hpp_source.html#l00023">objects.hpp:24</a></div></div>
<div class="ttc" id="astructMasterShape_html"><div class="ttname"><a href="structMasterShape.html">MasterShape</a></div><div class="ttdoc">Polymorphic class that represents the top class of any complex shape.</div><div class="ttdef"><b>Definition</b> <a href="objects_8hpp_source.html#l00037">objects.hpp:38</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="cpp_tp0_3_2"></a>
3.2 - classe SpaceTruck</h1>
<p>Vous ferez ensuite une classe <code>SpaceTruck</code>, qui hérite de <a class="el" href="structMasterShape.html" title="Polymorphic class that represents the top class of any complex shape.">MasterShape</a>, et dont la représentation graphique est un rectangle vert, qui devient jaune lors d'une collision. Au niveau des mouvements, il se déplacera en avant et en tournant à droite en permanence. On utilisera opportunément les méthodes héritées de QGraphicsItem, <code>QGraphicsItem::rotation</code> et <code>QGraphicsItem::setRotation</code>, pour faire ce mouvement dans <code>SpaceTruck::advance</code>.</p>
<p>Voilà un résultat possible avec 10 astéroides, 5 space trucks de taille 100x20.</p>
<div class="image">
<img src="tp0-3s.png" alt=""/>
<div class="caption">
Astéroïdes et space trucks...</div></div>
<dl class="section note"><dt>Note</dt><dd>Le constructeur de Spacetruck s'occupe d'instancier le rectangle et d'appeler <code>this-&gt;setGraphicalShape</code> sur cet objet graphique.</dd>
<dd>
On observe que la rotation s'applique avant le déplacement.</dd>
<dd>
Pour le déplacement observez le code ci-dessous de <code>Asteroid::advance</code>. Le principe pour avancer tout droit est de faire un point (speed,0) (donc un peu à l'"avant" de la forme qui est centré en (0,0)), et de demander les coordonnées correspondantes dans le repère du parent. Comme on change la position via <code>setPos</code>, ça déplace l'astéroïde.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">Asteroid::advance(<span class="keywordtype">int</span> step)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!step) <span class="keywordflow">return</span>;</div>
<div class="line">  setPos( mapToParent( _speed, 0.0 ) ); <span class="comment">// avance dans le repère local</span></div>
<div class="line">  setRotation( rotation() + angle );    <span class="comment">// si vous voulez tourner, angle != 0</span></div>
<div class="line">  MasterShape::advance( step );         <span class="comment">// regarde si la forme a dépassé les bords</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="cpp_tp0_4"></a>
4 - Objets complexes par assemblage de formes simples</h1>
<p>On va fabriquer des formes plus complexes par assemblage de formes simples. Pour ce faire on va créer une forme graphique <code>Union</code>, qui hérite de <a class="el" href="structGraphicalShape.html" title="Abstract class that describes a graphical object with additional methods for testing collisions.">GraphicalShape</a>, et dont le seul rôle est de grouper deux <a class="el" href="structGraphicalShape.html" title="Abstract class that describes a graphical object with additional methods for testing collisions.">GraphicalShape</a>. On note les points suivants:</p>
<ul>
<li>dans <code>Union::randomPoint</code> : il faudra tirer une fois sur deux un point dans la forme 1 et un point dans la forme 2. Le plus simple est de tirer un entier aléatoire et d'appeler l'un ou l'autre en fonction de la parité. Une solution plus évoluée est de calculer les aires A1 et A2 des boites englobantes des deux formes, et de demander un point dans la forme 1, si <code>rand01() &lt; A1/(A1+A2</code>, sinon de demander le point dans la forme 2.</li>
<li>dans <code>Union::isInside</code> il faudra bien tester si le point appartient à une des formes.</li>
<li>dans &lsquo;Union::boundingRect&rsquo; on note que Qt donne un <code>operator|</code> sur les QRect pour calculer le rectangle englobant de deux rectangles.</li>
<li><p class="startli">dans <code>Union::Union</code> il faut préciser à Qt la hiérarchie d'objets graphiques pour qu'il s'occupe de leur affichage. On utiliser <code>setParentItem</code> ainsi:</p>
<div class="fragment"><div class="line">Union::Union( <a class="code hl_struct" href="structGraphicalShape.html">GraphicalShape</a>* f1, <a class="code hl_struct" href="structGraphicalShape.html">GraphicalShape</a>* f2 )</div>
<div class="line">  : _f1( f1 ), _f2( f2 )</div>
<div class="line">{</div>
<div class="line">  _f1-&gt;setParentItem( <span class="keyword">this</span> );</div>
<div class="line">  _f2-&gt;setParentItem( <span class="keyword">this</span> );</div>
<div class="line">}     </div>
</div><!-- fragment --></li>
<li>la méthode <code>Union::paint(...)</code> est alors définie, mais ne contient pas de code, car Qt (grâce à <code>setParentItem</code>) peut aller chercher tout seul les autres objets graphiques.</li>
</ul>
<p>On pourra ensuite mettre à jour <code>SpaceTruck</code> pour qu'il soit composé de formes simples différentes.</p>
<div class="fragment"><div class="line"><span class="comment">// In SpaceTruck constructor</span></div>
<div class="line">  Rectangle* d1 = <span class="keyword">new</span> Rectangle( QPointF( -80, -10 ), QPointF( 0, 10 ), <span class="keyword">this</span> );</div>
<div class="line">  Rectangle* d2 = <span class="keyword">new</span> Rectangle( QPointF( 10, -10 ), QPointF( 30, 10 ), <span class="keyword">this</span> );</div>
<div class="line">  Rectangle* d3 = <span class="keyword">new</span> Rectangle( QPointF( 0, -3 ), QPointF( 10, 3 ), <span class="keyword">this</span> );</div>
<div class="line">  Union*    u23 = <span class="keyword">new</span> Union( d2, d3 );</div>
<div class="line">  Union*      u = <span class="keyword">new</span> Union( d1, u23 );</div>
<div class="line">  <span class="comment">// Tells the space truck that it is composed of the union of the previous shapes.</span></div>
<div class="line">  this-&gt;setGraphicalShape( u );</div>
</div><!-- fragment --><div class="image">
<img src="tp0-4s.png" alt=""/>
<div class="caption">
De plus jolis space trucks...</div></div>
<h1><a class="anchor" id="cpp_tp0_5"></a>
5 - Transformations géométriques</h1>
<p>Pour composer des formes complexes, il nous reste à nous donner des transformations géométriques pour pouvoir tourner et placer nos formes. On va définir une classe <code>Transformation</code>, qui prendra en paramètre un <a class="el" href="structGraphicalShape.html" title="Abstract class that describes a graphical object with additional methods for testing collisions.">GraphicalShape</a> <em>f</em>, un vecteur de déplacement <em>dx</em> et un angle de rotation <em>angle:</em> </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Transformation: <span class="keyword">public</span> <a class="code hl_struct" href="structGraphicalShape.html">GraphicalShape</a> {</div>
<div class="line">  Transformation( <a class="code hl_struct" href="structGraphicalShape.html">GraphicalShape</a>* f, QPointF dx, qreal angle );</div>
<div class="line">  ...</div>
<div class="line">};</div>
</div><!-- fragment --><ul>
<li>dans le constructeur, ne pas oubliez le <code>setParentItem( _f )</code> puis utiliser <code>this-&gt;setPos</code> et <code>this-&gt;setRotation</code> pour placer <code>Transformation</code> correctement dans son repère. On mémorisera aussi en donnée membre, à la fois le déplacement <code>dx</code> et l'angle <code>angle</code>, voire même on peut précalculer <code>cos( angle * pi/180 )</code>et <code>sin( angle * pi/180 )</code>.</li>
</ul>
<p>On veillera ensuite à redéfinir les méthodes usuelles:</p>
<ul>
<li>dans <code>Transformation::randomPoint</code> : on tire le point aléatoire dans la forme <em>f</em>, puis on applique la rotation et enfin la translation.</li>
<li>dans <code>Transformation::isInside( p )</code> : on va dans l'autre sens, on soustrait le déplacement, on applique la rotation inverse et on demande à <em>f</em> si le point obtenu est dedans.</li>
<li>dans <code>Transformation::boundingRect</code> il suffit d'utiliser la méthode héritée <code>mapRectToParent</code> qui fait tout le calcul voulu de rotation d'une boite !</li>
<li>dans <code>Transformation::paint(...)</code> le code est vide, car Qt (grâce à <code>setParentItem</code>) peut aller chercher tout seul les autres objets graphiques.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>On rappelle qu'une rotation de centre \( (0,0) \) et d'angle <em>a</em> (en radian) d'un point \( p=(x,y) \) donne le point \(
  q=(x&#39;,y&#39;) \) ainsi:</dd></dl>
<p>\( x&#39; = x * \cos(a) - y * \sin(a),  \qquad y&#39; = x * \sin(a) + y * \cos(a) \).</p>
<p>On pourra alors s'amuser à faire des objets plus complexes en composant nos formes. On pourra ainsi créer un vaisseau spatial sous la forme d'une classe <code>Enterprise</code> qui hérite de <a class="el" href="structMasterShape.html" title="Polymorphic class that represents the top class of any complex shape.">MasterShape</a>. On choisira une couleur grise pour le vaisseau et rouge en cas de collision.</p>
<p>Le code suivant vous place les éléments graphiques dans le constructeur de <code>Enterprise</code>:</p>
<div class="fragment"><div class="line">Rectangle*      r1 = <span class="keyword">new</span> Rectangle( QPointF( -100, -8 ), QPointF( 0, 8 ), <span class="keyword">this</span> );</div>
<div class="line">Rectangle*      r2 = <span class="keyword">new</span> Rectangle( QPointF( -100, -8 ), QPointF( 0, 8 ), <span class="keyword">this</span> );</div>
<div class="line">Rectangle*      rb = <span class="keyword">new</span> Rectangle( QPointF( -40, -9 ), QPointF( 40, 9 ), <span class="keyword">this</span> );</div>
<div class="line">Rectangle*      s1 = <span class="keyword">new</span> Rectangle( QPointF( -25, -5 ), QPointF( 25, 5 ), <span class="keyword">this</span> );</div>
<div class="line">Rectangle*      s2 = <span class="keyword">new</span> Rectangle( QPointF( -25, -5 ), QPointF( 25, 5 ), <span class="keyword">this</span> );</div>
<div class="line"><a class="code hl_struct" href="structDisk.html">Disk</a>*            d = <span class="keyword">new</span> <a class="code hl_struct" href="structDisk.html">Disk</a>( 40.0, <span class="keyword">this</span> );</div>
<div class="line">Transformation* t1 = <span class="keyword">new</span> Transformation( r1, QPointF( 0., 40.0 ) );</div>
<div class="line">Transformation* t2 = <span class="keyword">new</span> Transformation( r2, QPointF( 0., -40.0 ) );</div>
<div class="line">Transformation* td = <span class="keyword">new</span> Transformation( d, QPointF( 70., 0.0 ) );</div>
<div class="line">Transformation*ts1 = <span class="keyword">new</span> Transformation( s1, QPointF(-30.0,0.0), 0.0 );</div>
<div class="line">Transformation*us1 = <span class="keyword">new</span> Transformation( ts1, QPointF(0.0,0.0), 45.0 );</div>
<div class="line">Transformation*ts2 = <span class="keyword">new</span> Transformation( s2, QPointF(-30.0,0.0), 0.0 );</div>
<div class="line">Transformation*us2 = <span class="keyword">new</span> Transformation( ts2, QPointF(0.0,0.0), -45.0 );</div>
<div class="line">Union*        back = <span class="keyword">new</span> Union( t1, t2 );</div>
<div class="line">Union*        head = <span class="keyword">new</span> Union( rb, td );</div>
<div class="line">Union*        legs = <span class="keyword">new</span> Union( us1, us2 );</div>
<div class="line">Union*        body = <span class="keyword">new</span> Union( legs, back );</div>
<div class="line">Union*         all = <span class="keyword">new</span> Union( head, body );</div>
<div class="line">this-&gt;setGraphicalShape( all );</div>
<div class="ttc" id="astructDisk_html"><div class="ttname"><a href="structDisk.html">Disk</a></div><div class="ttdoc">A disk is a simple graphical shape.</div><div class="ttdef"><b>Definition</b> <a href="objects_8hpp_source.html#l00074">objects.hpp:75</a></div></div>
</div><!-- fragment --><p>On pourra ensuite s'amuser à faire des déplacements un peu plus aléatoires pour le vaisseau. Vous devriez avoir maintenant une application qui ressemble à ça:</p>
<div class="image">
<img src="tp0-5s.png" alt=""/>
<div class="caption">
This is starship USS Enterprise NCC-1701 exploring new galaxies, but stalled in traffic jams...</div></div>
<h1><a class="anchor" id="cpp_tp0_6"></a>
6 - Des images, des figures</h1>
<p>En fait, on peut étendre le principe précédent à des images quelconques. L'idée est la suivante:</p>
<ul>
<li>Une image a une partie "pleine" (là où il y a des couleurs) et une partie "vide" (là où elle est transparente, c'est-à-dire là où son "alpha-channel" est à 0).</li>
<li>A partir du <code>QPixmap</code> de l'image, on fabrique un <code>QBitmap</code> qui est son masque plein/vide.</li>
<li>tirer un point aléatoire dans une telle image revient à tirer un point aléatoire dans l'image et à le retirer tant qu'on tombe dans un pixel vide du masque.</li>
<li>un point est dans l'image (<code>isInside</code>) lorsqu'il tombe dans un pixel plein du masque.</li>
</ul>
<p>Pour charger une image, il suffit de déclarer un <code>QPixmap</code> et de lui donner un nom de fichier listé dans les ressources (cf <code>collider.qrc</code>). On utilisera le format GIF qui peut stocker de la transparence.</p>
<div class="fragment"><div class="line"><span class="comment">// dans collider.cpp, le pixmap ne doit être chargé qu&#39;une fois.</span></div>
<div class="line">QPixmap asteroid_pixmap(<span class="stringliteral">&quot;:/images/asteroid.gif&quot;</span>);</div>
</div><!-- fragment --><p>On écrira donc ensuite une classe <code>ImageShape</code> qui hérite de <a class="el" href="structGraphicalShape.html" title="Abstract class that describes a graphical object with additional methods for testing collisions.">GraphicalShape</a>. On la construit en lui donnant un <code>QPixmap</code> et un <a class="el" href="structMasterShape.html" title="Polymorphic class that represents the top class of any complex shape.">MasterShape</a>. On suppose qu'elle occupe les coordonnées (0,0) -&gt; (w-1,h-1) où w et h sont la largeur et la hauteur de l'image.</p>
<div class="fragment"><div class="line">ImageShape::ImageShape( <span class="keyword">const</span> QPixmap &amp; pixmap, <span class="keyword">const</span> <a class="code hl_struct" href="structMasterShape.html">MasterShape</a>* master_shape )</div>
<div class="line">  : _pixmap( pixmap ), _master_shape( master_shape )</div>
<div class="line">{</div>
<div class="line">  _mask     = _pixmap.mask(); <span class="comment">// donnée membre QBitmap pour affichage</span></div>
<div class="line">  _mask_img = QImage( _mask.toImage().convertToFormat( QImage::Format_Mono ) );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Le <code>QBitmap</code> <code>_mask</code> servira lors des affichages de collision. C'est une structure optimisée pour l'affichage. Le <code>QImage</code> _mask_img est quant à lui optimisé pour les requêtes pixel par pixel et servira pour <code>ImageShape::randomPoint</code> et <code>ImageShape::isInside</code>.</p>
<p>Ecrivez ces méthodes selon le principe explicité ci-dessus. On utilisera la méthode <code>QImage::pixelIndex</code> qui retourne 0 sur du vide et 1 sur du plein.</p>
<dl class="section warning"><dt>Warning</dt><dd>Attention, <code>_mask_img.pixel( p )</code> fonctionne si le <code>QPoint p</code> est à l'intérieur de l'image. Dans la méthode <code>ImageShape::isInside</code>, on vérifie donc d'abord si le point est dans la boite englobante de l'image <code>ImageShape::boundingRect</code> avant de tester si ce point touche un pixel du masque de l'image.</dd></dl>
<p>Pour l'affichage, on peut utiliser le code suivant:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">ImageShape::paint(QPainter *painter, <span class="keyword">const</span> QStyleOptionGraphicsItem *, QWidget *)</div>
<div class="line">{</div>
<div class="line">  painter-&gt;drawPixmap( QPointF( 0.0, 0.0 ), _pixmap );</div>
<div class="line">  <span class="keywordflow">if</span> ( _master_shape-&gt;currentState() == MasterShape::Collision )</div>
<div class="line">    {</div>
<div class="line">      painter-&gt;setOpacity( 0.5 );</div>
<div class="line">      painter-&gt;setBackgroundMode( Qt::TransparentMode );</div>
<div class="line">      painter-&gt;setPen  ( _master_shape-&gt;currentColor() );</div>
<div class="line">      painter-&gt;drawPixmap( QPointF( 0.0, 0.0 ), _mask );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Il ne reste plus qu'à faire une classe <code>NiceAsteroid</code> qui s'occupe de créer un joli astéroïde tournant sur lui-même. Il aura besoin de deux transformations <code>t1</code> et <code>t2</code>. La première s'occupe de ramener l'image au centre (car celle-ci est entre les coordonnées (0,0) et (largeur,hauteur). La deuxième s'occupe juste de la rotation.</p>
<p>Dans <code>NiceAsteroid::advance</code> on augmentera régulièrement l'angle de la transformation <code>t2</code>, stockée dans la donnée membre <code>_t</code> ci-dessous:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> NiceAsteroid::advance(<span class="keywordtype">int</span> step)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!step) <span class="keywordflow">return</span>;</div>
<div class="line">  setPos( mapToParent( _speed, 0.0 ) );</div>
<div class="line">  _t-&gt;setAngle( _t-&gt;_angle + 2.0 );</div>
<div class="line">  MasterShape::advance( step );</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>on pourra ajouter des accesseurs <code>Transformation::setAngle</code> et <code>Transformation::angle</code> pour lire/changer l'angle d'une transformation.</dd></dl>
<p>Vous devez avoir maintenant quelque chose qui ressemble à ci-dessous, en ayant remplacé les <a class="el" href="structAsteroid.html" title="An asteroid is a simple shape that moves linearly in some direction.">Asteroid</a> par des <code>NiceAsteroid</code>.</p>
<div class="image">
<img src="tp0-6s.png" alt=""/>
<div class="caption">
Ca devient carrément encombré le coin !</div></div>
<h1><a class="anchor" id="cpp_tp0_7"></a>
7. Développements optionnels</h1>
<p>Vous avez toute une base pour développer un petit jeu ou des petites animations. On peut citer les développements suivants:</p>
<ul>
<li>combiner des images pour faire des vaisseaux jolis ou d'autres éléments.</li>
<li>avoir plusieurs images et animer certains éléments graphiques.</li>
<li>interactions avec la souris pour déplacer le vaisseau.</li>
<li>rajouter des tirs qui peuvent détruire les astéroïdes lors d'une collision.</li>
<li>ajout de forces/vitesse/accélération et de réactions à des collisions. On peut s'inspirer du TP3 d'INFO626.</li>
<li>optimiser les tests de collision en gérant les boîtes englobantes et en tenant compte de l'aire des formes.</li>
</ul>
<p>N'hésitez pas à me poser des questions si vous ne voyez pas comment démarrer.</p>
<h1><a class="anchor" id="cpp_tp0_8"></a>
TP à rendre</h1>
<ul>
<li>Vous écrirez un petit README (texte) dans lequel vous préciserez les points suivants :<ul>
<li>nom(s), prénom(s), groupe (monôme ou binôme)</li>
<li>Vous listerez d'abord les points du TP que vous avez abordés, en précisant si selon vous, vous avez traité complètement ou traité partiellement la question. Précisez aussi pour chaque question si votre code fonctionne ou dans quelle mesure il fonctionne.</li>
<li>vous placerez dans une archive (zip ou tar.gz) votre README ainsi que vos sources/entêtes/fichiers de config/images utiles, de façon à ce que je puisse tout recompiler en tapant "qmake" puis "make".</li>
<li>le nom de votre archive sera de la forme <code>TP-XXX-YYY.*</code> où <code>XXX</code> et <code>YYY</code> désignent les noms respectifs des étudiants du binôme.</li>
<li>vous m'enverrez votre archive via <a href="https://tplab.apps.math.cnrs.fr">TPLab </a>, une première version à la fin du TP, une autre avant le <b>mardi</b> <b>17</b> <b>octobre</b> <b>2023</b> <b>minuit</b>. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 19 2023 16:09:42 for INFO702 - TPs by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
