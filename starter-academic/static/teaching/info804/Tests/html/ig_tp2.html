<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INFO804 Introduction à l&#39;informatique graphique: TP2 Algorithme de rendu par lancer de rayons (ray-tracing ou eye-tracing)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INFO804 Introduction à l&#39;informatique graphique
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP2 Algorithme de rendu par lancer de rayons (ray-tracing ou eye-tracing)</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ig_tp2_1">1 - Objectifs, pointeurs utiles</a></li>
<li class="level1"><a href="#ig_tp2_2">2 - Prise en main du code</a><ul><li class="level2"><a href="#ig_tp2_2_1">2.1 - Code fourni</a></li>
<li class="level2"><a href="#ig_tp2_2_2">2.2 - Construire l&#39;application initiale</a></li>
<li class="level2"><a href="#ig_tp2_2_3">2.3 - Observation du code</a></li>
</ul>
</li>
<li class="level1"><a href="#ig_tp2_3">3 - Rendu primitif des sphères</a><ul><li class="level2"><a href="#ig_tp2_3_1">3.1 - Intersection rayon / sphère</a></li>
<li class="level2"><a href="#ig_tp2_3_2">3.2 - Rendu minimal, intersection avec l&#39;objet le plus proche sur le trajet du rayon.</a></li>
<li class="level2"><a href="#ig_tp2_3_3">3.3 - Couleur directe de l&#39;objet intersecté</a></li>
<li class="level2"><a href="#ig_tp2_3_4">3.4 - Couleurs diffuses</a></li>
<li class="level2"><a href="#ig_tp2_3_5">3.5 - Couleurs spéculaires</a></li>
<li class="level2"><a href="#ig_tp2_3_6">3.6 - Un fond moins triste</a></li>
</ul>
</li>
<li class="level1"><a href="#ig_tp2_4">4 - Ombres, réflexions, réfractions</a><ul><li class="level2"><a href="#ig_tp2_4_1">4.1 - Ombres portées</a></li>
<li class="level2"><a href="#ig_tp2_4_2">4.2 - Réflexions</a></li>
<li class="level2"><a href="#ig_tp2_4_3">4.3 - Réfractions</a></li>
<li class="level2"><a href="#ig_tp2_4_4">4.4 - De l&#39;influence de la profondeur de réflexion / réfraction</a></li>
<li class="level2"><a href="#ig_tp2_4_5">4.5 - Il est temps de jouer !</a></li>
</ul>
</li>
<li class="level1"><a href="#ig_tp2_5">5 - Allez plus loin, allez plus haut !</a><ul><li class="level2"><a href="#ig_tp2_5_1">5.1 Un nouvel objet graphique: le plan infini (*)</a></li>
<li class="level2"><a href="#ig_tp2_5_2">5.2 Une variante du plan infini, l&#39;eau calme (***)</a></li>
<li class="level2"><a href="#ig_tp2_5_3">5.3 Anti-aliasing et problèmes numériques (**)</a></li>
<li class="level2"><a href="#ig_tp2_5_4">5.4 Un nouvel objet graphique : le triangle (**)</a></li>
<li class="level2"><a href="#ig_tp2_5_5">5.5 Mettre des textures sur les triangles (***)</a></li>
<li class="level2"><a href="#ig_tp2_5_6">5.6 Rendu rapide par décision aléatoire (***)</a></li>
<li class="level2"><a href="#ig_tp2_5_7">5.7 Faire un film (**)</a></li>
<li class="level2"><a href="#ig_tp2_5_8">5.8 Faire un ciel (***)</a></li>
</ul>
</li>
<li class="level1"><a href="#ig_tp2_6">6 - Bétisier</a></li>
<li class="level1"><a href="#ig_tp2_7">7 - A rendre</a></li>
</ul>
</div>
<div class="textblock"><p><b>author:</b> <b>Jacques-Olivier</b> <b>Lachaud</b> </p>
<h1><a class="anchor" id="ig_tp2_1"></a>
1 - Objectifs, pointeurs utiles</h1>
<p>L'objectif de ce TP est de vous faire écrire un algorithme de rendu "réaliste" appelé lancer de rayons (<em>ray-tracing</em> ou <em>eye-tracing</em> en anglais).</p>
<p>Le principe est le suivant. On va calculer comment les rayons lumineux ont éclairé la scène observée. Ils ont rebondi ou traversé certains objets puis sont arrivés dans l'oeil. L'ensemble de ces rayons a donc formé une image sur notre rétine. Le problème de cette approche directe est que la plupart des rayons lumineux ne sont pas allés sur notre rétine mais sont allés ailleurs ! Il faudrait donc envoyer des milliards de milliards de rayons pour voir la scène se dessiner sur notre rétine.</p>
<p>L'idée du lancer de rayons est de calculer la couleur de chaque pixel indépendamment (un pixel étant un point sur la rétine) en reconstruisant le trajet <b>inverse</b> de la lumière. On part de l'oeil et on détecte où ce rayon va tomber dans la scène. Si ce rayon tombe sur un objet réfléchissant, on fait rebondir le rayon (<em>réflexion</em>) et on continue. Si ce rayon tombe sur un objet transparent, on le traverse (<em>réfraction</em>). Si ce rayon tombe sur un objet mat on calcule la couleur en regardant où sont les sources de lumière et on s'arrête (<em>diffusion</em>).</p>
<p>Les images ci-dessous vous donnent une idée de la qualité des rendus que l'on peut obtenir avec cet algorithme. Cela peut être très joli !</p>
<p>Les avantages de cet algorithme sont:</p>
<ul>
<li>Les résultats peuvent être magnifiques avec (relativement) peu d'efforts !</li>
<li>on rajoute de nouveaux types d'objets de façon très simple, et cela ne change pas l'algorithme !</li>
<li>on peut même rajouter des textures fixes ou procédurales sans efforts.</li>
<li>cet algorithme est naturellement parallèle.</li>
</ul>
<p>Les inconvénients de cet algorithme sont les suivants:</p>
<ul>
<li>lenteur: la complexité de l'algorithme augmente directement en fonction du nombre d'objets et du nombre de lumière, et encore plus lorsque l'on rajoute de la transparence ou de la réflexion.</li>
<li>les surfaces triangulées sont très coûteuses à rendre avec cet algorithme, surtout quand on compare à ce que font les cartes graphiques.</li>
<li>"réaliste": en fait ce n'est pas vraiment un rendu réaliste au sens physique du terme, ça donne des résultats jolis, éventuellement proches de vraies images. On ne peut parler de rendu physiquement réalistes pour plusieurs raisons: (i) il faudrait ne pas travailler en RGB mais en longueurs d'onde de lumière (faisable quand même en lancer de rayon, mais coûteux), (ii) les spécularités et ombres sont traitées de façon approchées (et sont fausses en présence de miroir et autres).</li>
<li>erreurs numériques: les réflexions/réfractions successives des rayons et leurs intersections avec les objets donnent lieu à des erreurs numériques. On est en réalité obligé d'envoyer plusieurs rayons par pixel avec des méthodes d'échantillonnage non triviales (type quasi-Montecarlo).</li>
</ul>
<p>A l'issue de cette séance, vous vous serez bien amusés ! Plus sérieusement, vous aurez manipulé:</p>
<ul>
<li>du C++, avec pas mal de classes, du polymorphisme dynamique pour représenter les objets graphiques</li>
<li>un peu d'OpenGL et de libQGLViewer pour afficher vos objets graphiques, placer la caméra, faire des films...</li>
<li>de la géométrie dans l'espace pour calculer les intersections des rayons avec des objets, calculer les normales ou les rayons réfléchis.</li>
<li>des matériaux: comprendre les différences entre des objets mats ou brillants, des objets transparents, les couleurs diffuses ou spéculaires.</li>
</ul>
<p>L'objectif du TP est:</p>
<ul>
<li>implémenter un algorithme assez complet de lancer de rayons</li>
<li>créer plusieurs objets graphiques: sphères, plans infinis, triangles, etc.</li>
<li>créer plusieurs matériaux pour varier vos scènes.</li>
<li>éventuellement, aller jusqu'à faire un film ou une animation.</li>
</ul>
<p>Les sites suivants pourront être utile pendant le TP:</p><ul>
<li>[<a href="https://github.com/GillesDebunne/libQGLViewer">https://github.com/GillesDebunne/libQGLViewer</a> Site libQGLViewer: exemples, doc, références]</li>
<li>[<a href="https://en.cppreference.com/w/">https://en.cppreference.com/w/</a> Référence C++: description détaillée des bibliothèques]</li>
<li>[<a href="http://www.parashift.com/c++-faq-lite/index.html">http://www.parashift.com/c++-faq-lite/index.html</a> C++ FAQ]</li>
<li>[<a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work">https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work</a> Learn computer graphics from scratch]</li>
</ul>
<div class="image">
<img src="image-1-small.png" alt=""/>
<div class="caption">
Objectif du TP avec un peu tous les effets en même temps</div></div>
<h1><a class="anchor" id="ig_tp2_2"></a>
2 - Prise en main du code</h1>
<h2><a class="anchor" id="ig_tp2_2_1"></a>
2.1 - Code fourni</h2>
<p>Afin de vous faciliter au mieux le travail et de vous concentrer sur la partie "graphique" du TP, on vous donne tout un ensemble de classes pour avoir un logiciel minimaliste pour démarrer:</p>
<ul>
<li>des classes de bases pour la géométrie: Point3 et Vector3 (fichier <a class="el" href="PointVector_8h.html">PointVector.h</a>), <a class="el" href="structrt_1_1Ray.html">Ray</a> (fichier <a class="el" href="Ray_8h.html">Ray.h</a>)</li>
<li>une classe <a class="el" href="structrt_1_1Color.html">Color</a> pour représenter les couleurs (fichier <a class="el" href="Color_8h.html">Color.h</a>)</li>
<li>une classe <a class="el" href="structrt_1_1Material.html">Material</a> pour représenter les matériaux (fichier <a class="el" href="Material_8h.html">Material.h</a>)</li>
<li>une classe <a class="el" href="classrt_1_1Viewer.html">Viewer</a> pour pré-visualiser la scène et placer la caméra et les lumières (fichiers Viewer.h et Viewer.cpp)</li>
<li>des classes abstraites pour décrire l'interface d'un objet graphique (<a class="el" href="structrt_1_1GraphicalObject.html">GraphicalObject</a>, fichier <a class="el" href="GraphicalObject_8h.html">GraphicalObject.h</a>) et d'une source de lumière (<a class="el" href="structrt_1_1Light.html" title="Lights are used to give lights in a scene.">Light</a>, fichier <a class="el" href="Light_8h.html">Light.h</a>).</li>
<li>une classe concrète <a class="el" href="structrt_1_1Sphere.html" title="A sphere is a concrete GraphicalObject that represents a sphere in 3D space.">Sphere</a>, un modèle de <a class="el" href="structrt_1_1GraphicalObject.html">GraphicalObject</a>, pour représenter une sphère (fichiers <a class="el" href="Sphere_8h.html">Sphere.h</a> et <a class="el" href="Sphere_8cpp.html">Sphere.cpp</a>)</li>
<li>une classe concrète <a class="el" href="structrt_1_1PointLight.html">PointLight</a>, un modèle de <a class="el" href="structrt_1_1Light.html" title="Lights are used to give lights in a scene.">Light</a>, pour représenter un source ponctuelle de lumière (fichier <a class="el" href="PointLight_8h.html">PointLight.h</a>)</li>
<li>une classe <a class="el" href="structrt_1_1Renderer.html" title="This structure takes care of rendering a scene.">Renderer</a> pour calculer le rendu étant donné un point de vue (fichier <a class="el" href="Renderer_8h.html">Renderer.h</a>)</li>
<li>des classes pour représenter une image couleur (<a class="el" href="classrt_1_1Image2D.html" title="Classe générique pour représenter des images 2D.">Image2D</a>, fichier <a class="el" href="classrt_1_1Image2D.html#ad4a70703393ebfc23eccb5e678a119f9">Image2D.h</a>) et l'écrire sous forme de fichier PPM (<a class="el" href="classrt_1_1Image2DWriter.html">Image2DWriter</a>, fichier <a class="el" href="Image2DWriter_8h_source.html">Image2DWriter.h</a>)</li>
<li>un exécutable <a class="el" href="ray-tracer_8cpp_source.html">ray-tracer.cpp</a> pour lancer l'application</li>
<li>un fichier de configuration <a class="el" href="ray-tracer_8pro_source.html">ray-tracer.pro</a> pour fabriquer le <code>Makefile</code> (avec <code>qmake</code>)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Tout le code est dans le namespace <code>rt</code>.</dd></dl>
<h2><a class="anchor" id="ig_tp2_2_2"></a>
2.2 - Construire l'application initiale</h2>
<p>En plus d'un compilateur C++ (version c++11 au moins), il faut que vous ayez Qt (<a href="https://www.qt.io/">https://www.qt.io/</a>) et libQGLViewer (<a href="https://github.com/GillesDebunne/libQGLViewer">https://github.com/GillesDebunne/libQGLViewer</a>) installés pour que l'application fournie fonctionne. Ce n'est pas obligatoire d'avoir tout ça pour faire du ray-tracing mais c'est tellement plus agréable de placer sa caméra et ses lumières de façon interactive !</p>
<p>Pour faire le <code>Makefile</code>: </p><pre class="fragment">$ qmake
</pre><p>Si <code>qmake</code> ne marche pas, modifiez le fichier <code><a class="el" href="ray-tracer_8pro_source.html">ray-tracer.pro</a></code> pour votre système.</p>
<p>Pour compiler: </p><pre class="fragment">$ make
</pre><p>Pour exécuter: </p><pre class="fragment">$ ./ray-tracer
</pre><p>Pour le moment, vous devriez avoir une fenêtre avec 2 lumières et deux sphères. Si vous tapez sur <b>Ctrl+R</b>, cela calculera un rendu par rapport au point de vue actuel. Le résultat est enregistré dans le fichier <code>output.ppm</code>. Pour le moment l'image est noire !</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-2-small.png" alt=""/>
<div class="caption">
Application ray-tracer</div></div>
  </td><td><div class="image">
<img src="image-2b-small.png" alt=""/>
<div class="caption">
Rendu noir pour le moment</div></div>
  </td></tr>
</table>
<p>C'est normal que le rendu soit noir.</p>
<dl class="section note"><dt>Note</dt><dd>Vous pouvez déplacer les lumières avec la souris (passez dessus avec la souris, puis déplacement avec bouton droit ou la molette).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Vous avez normalement 2 warnings, liés aux méthodes <a class="el" href="structrt_1_1Scene.html#a3a72879a8e5988b69352a3e5f00235b1">rt::Scene::rayIntersection</a> et <a class="el" href="structrt_1_1Sphere.html#aa6c3f41a30ad7cdee39d6396d8270467">rt::Sphere::rayIntersection</a>. C'est normal, vous devez écrire du code à ces deux endroits.</dd></dl>
<h2><a class="anchor" id="ig_tp2_2_3"></a>
2.3 - Observation du code</h2>
<p>Tout le code est nécessaire, mais vous devez regarder avec attention notamment ces parties du code:</p>
<ul>
<li><p class="startli">méthode <a class="el" href="classrt_1_1Viewer.html#a151e08b88af52eb4a1b80de42b5c6d8e" title="Celled when pressing a key.">Viewer::keyPressEvent(QKeyEvent *e)</a></p>
<p class="startli">Cette méthode permet de lancer le rendu (en appuyant sur <b>R</b> avec possiblement Shift, Ctrl). Elle est intéressante car elle montre comment on utilise QGLViewer pour nous donner les rayons qui partent de l'observateur vers la scène. Les 4 vecteurs construits (<code>dirUL</code>, <code>dirUR</code>, <code>dirLL</code>, <code>dirLR</code>) correspondent aux rayons lumineux partant de l'oeil (<code>origin</code>) vers les 4 coins de la fenêtre. Le reste du code paramètre l'objet qui s'occupe du rendu et sauvegarde l'image.</p>
</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> w = camera()-&gt;screenWidth();</div>
<div class="line"><span class="keywordtype">int</span> h = camera()-&gt;screenHeight();</div>
<div class="line">Renderer renderer( *ptrScene );</div>
<div class="line">qglviewer::Vec orig, dir;</div>
<div class="line">camera()-&gt;convertClickToLine( QPoint( 0,0 ), orig, dir );</div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> origin( orig );</div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> dirUL( dir );</div>
<div class="line">camera()-&gt;convertClickToLine( QPoint( w,0 ), orig, dir );</div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> dirUR( dir );</div>
<div class="line">camera()-&gt;convertClickToLine( QPoint( 0, h ), orig, dir );</div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> dirLL( dir );</div>
<div class="line">camera()-&gt;convertClickToLine( QPoint( w, h ), orig, dir );</div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> dirLR( dir );</div>
<div class="line"><span class="comment">// Paramètre le renderer, puis le lance, et sauvegarde l&#39;image.</span></div>
<div class="line">renderer.setViewBox( origin, dirUL, dirUR, dirLL, dirLR );</div>
<div class="line"><span class="keywordflow">if</span> ( modifiers == Qt::ShiftModifier ) { w /= 2; h /= 2; }</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> ( modifiers == Qt::NoModifier ) { w /= 8; h /= 8; }</div>
<div class="line">Image2D&lt;Color&gt; image( w, h );</div>
<div class="line">renderer.setResolution( image.w(), image.h() );</div>
<div class="line">renderer.render( image, maxDepth );</div>
<div class="line">ofstream output( <span class="stringliteral">&quot;output.ppm&quot;</span> );</div>
<div class="line">Image2DWriter&lt;Color&gt;::write( image, output, <span class="keyword">true</span> );</div>
<div class="line">output.close();</div>
<div class="ttc" id="anamespacert_html_aafd88fe1113c5fe48274a138510492ec"><div class="ttname"><a href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">rt::Vector3</a></div><div class="ttdeci">PointVector&lt; Real, 3 &gt; Vector3</div><div class="ttdoc">The type for representing a 3d point.</div><div class="ttdef"><b>Definition</b> <a href="PointVector_8h_source.html#l00210">PointVector.h:210</a></div></div>
</div><!-- fragment --><ul>
<li><p class="startli">méthode <a class="el" href="structrt_1_1Renderer.html#aeca19cc2de6839aada6f4524e63bb45f" title="The main rendering routine.">Renderer::render</a></p>
<p class="startli">Cette méthode s'occupe de lancer dans la scène 1 rayon par pixel de l'image en entrée. On voit comment la drection du rayon de chaque pixel est interpolée (i.e. moyenne pondérée) à partir des directions des 4 rayons correspondant aux 4 coins de l'image. Pour chaque rayon/pixel, on appelle la méthode Render::trace qui est l'algorithme de lancer de rayon proprement dit. Le résultat est ensuite mis dans l'image de sortie.</p>
</li>
</ul>
<div class="fragment"><div class="line">image = Image2D&lt;Color&gt;( myWidth, myHeight );</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> y = 0; y &lt; myHeight; ++y ) </div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a>    ty   = (<a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a>) y / (<a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a>)(myHeight-1);</div>
<div class="line">    progressBar( std::cout, ty, 1.0 );</div>
<div class="line">    <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> dirL = (1.0f - ty) * myDirUL + ty * myDirLL;</div>
<div class="line">    <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> dirR = (1.0f - ty) * myDirUR + ty * myDirLR;</div>
<div class="line">    dirL        /= dirL.norm();</div>
<div class="line">    dirR        /= dirR.norm();</div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> x = 0; x &lt; myWidth; ++x ) </div>
<div class="line">      {</div>
<div class="line">        <a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a>    tx   = (<a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a>) x / (<a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a>)(myWidth-1);</div>
<div class="line">        <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> dir  = (1.0f - tx) * dirL + tx * dirR;</div>
<div class="line">        Ray eye_ray  = Ray( myOrigin, dir, max_depth );</div>
<div class="line">        Color result = trace( eye_ray );</div>
<div class="line">        image.at( x, y ) = result.clamp();</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="ttc" id="anamespacert_html_a31304cdacdb1cd0eaab05bcd2e641242"><div class="ttname"><a href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">rt::Real</a></div><div class="ttdeci">float Real</div><div class="ttdoc">the type for representing a real number.</div><div class="ttdef"><b>Definition</b> <a href="PointVector_8h_source.html#l00206">PointVector.h:206</a></div></div>
</div><!-- fragment --><ul>
<li>l'interface <a class="el" href="structrt_1_1GraphicalObject.html">GraphicalObject</a> décrit quels services doivent satisfaire les objets que l'on placera dans la scène. Pour le moment, on a juste la classe <a class="el" href="structrt_1_1Sphere.html" title="A sphere is a concrete GraphicalObject that represents a sphere in 3D space.">Sphere</a> qui satisfait cette interface. Notez que la moitié de l'interface sert juste à afficher l'objet dans la fenêtre QGLViewer. Les trois seules méthodes utiles pour le lancer de rayon sont:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">/// @return the normal vector at point \a p on the object (\a p</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// should be on or close to the sphere).</span></div>
<div class="line"><span class="comment"></span><span class="keyword">virtual</span> <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> getNormal( <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a> p ) = 0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// @return the material associated to this part of the object</span></div>
<div class="line"><span class="comment"></span><span class="keyword">virtual</span> Material getMaterial( <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a> p ) = 0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// @param[in] ray the incoming ray</span></div>
<div class="line"><span class="comment">/// @param[out] returns the point of intersection with the object</span></div>
<div class="line"><span class="comment">/// (if any), or the closest point to it.</span></div>
<div class="line"><span class="comment">///</span></div>
<div class="line"><span class="comment">/// @return either a real &lt; 0.0 if there is an intersection, or a</span></div>
<div class="line"><span class="comment">/// kind of distance to the closest point of intersection.</span></div>
<div class="line"><span class="comment"></span><span class="keyword">virtual</span> <a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> rayIntersection( <span class="keyword">const</span> Ray&amp; ray, <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>&amp; p ) = 0;</div>
<div class="ttc" id="anamespacert_html_a82b401d949a79dfd801b458fc7363214"><div class="ttname"><a href="namespacert.html#a82b401d949a79dfd801b458fc7363214">rt::Point3</a></div><div class="ttdeci">PointVector&lt; Real, 3 &gt; Point3</div><div class="ttdoc">The type for representing a 3d vector;.</div><div class="ttdef"><b>Definition</b> <a href="PointVector_8h_source.html#l00212">PointVector.h:212</a></div></div>
</div><!-- fragment --><table class="doxtable">
<tr>
<td><div class="image">
<img src="projperspective.gif" alt=""/>
<div class="caption">
Projection perspective (calculé par `camera()-&gt;convertClickToLine`)</div></div>
  </td><td><div class="image">
<img src="rt-pixel-render.gif" alt=""/>
<div class="caption">
Rendu par pixel obtenu en lançant un rayon par pixel (méthode Renderer::render)</div></div>
  </td></tr>
</table>
<h1><a class="anchor" id="ig_tp2_3"></a>
3 - Rendu primitif des sphères</h1>
<p>Avant de se préoccuper trop des couleurs, on va se préoccuper de savoir quand un rayon touche un objet dans la scène.</p>
<h2><a class="anchor" id="ig_tp2_3_1"></a>
3.1 - Intersection rayon / sphère</h2>
<p>On voit que la méthode <a class="el" href="structrt_1_1Sphere.html#aa6c3f41a30ad7cdee39d6396d8270467">Sphere::rayIntersection</a> est vide. Reprenez l'exercice du TD pour calculer quand un rayon intersecte une sphère. On rappelle les points-clés, si [o,u) est le rayon d'origin o et de direction u, et la sphère est de centre c et rayon r:</p>
<ul>
<li>calculez la distance au carré entre c et la droite contenant le rayon [o,u)</li>
<li>si cette distance au carré est plus grande que r^2, alors il n'y pas d'intersection et on retourne un nombre positif.</li>
<li>sinon, il y a intersection entre la sphère et la droite contenant [o,u)<ul>
<li>on calcule les deux intersections en paramétrant [o,u) sous le forme o+t*u et en cherchant les 2 t_i tels que o+t_i*u est sur la sphère</li>
<li>on vérifie que le rayon ne démarre pas au-delà de l'objet (sinon intersection vide)</li>
<li>on choisit quelle est la bonne intersection (t_1 ou t_2).</li>
<li>et on retourne un nombre négatif.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="ig_tp2_3_2"></a>
3.2 - Rendu minimal, intersection avec l'objet le plus proche sur le trajet du rayon.</h2>
<p>Pour le moment, rien n'a changé à l'affichage normalement. En effet la méthode <a class="el" href="structrt_1_1Scene.html#a3a72879a8e5988b69352a3e5f00235b1">Scene::rayIntersection</a> est vide aussi. On l'écrit ainsi:</p>
<ul>
<li>On fait une boucle sur tous les objets de la scène<ul>
<li>si le rayon intersecte l'objet, alors<ul>
<li>on calcule la distance entre l'origine et le point d'intersection.</li>
<li>si cette distance est plus courte que la précédente, l'objet courant devient l'objet intersecté.</li>
</ul>
</li>
</ul>
</li>
<li>si le rayon n'a pas touché d'objets, on retourne un nombre positif, sinon on retourne un nombre négatif, et <code>object</code> et <code>p</code> correspondent à l'intersection la plus proche.</li>
</ul>
<p>Vous devriez maintenant obtenir un rendu comme ceci:</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-3-small.png" alt=""/>
<div class="caption">
Application ray-tracer</div></div>
  </td><td><div class="image">
<img src="image-3b-small.png" alt=""/>
<div class="caption">
Rendu noir et blanc pour le moment (après Q3.2)</div></div>
  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Pour un rayon <code>[o,u)</code>, avec <code>u</code> vecteur unitaire, on peut calculer la distance entre le point <code>p</code> d'intersection et le point <code>o</code> de départ du rayon simplement en calculant le produit scalaire <code>u.(p-o)</code>. Cela évite de potentiels problèmes de signe.</dd></dl>
<h2><a class="anchor" id="ig_tp2_3_3"></a>
3.3 - Couleur directe de l'objet intersecté</h2>
<p>Une fois que le premier objet touché par le rayon a été trouvé, on peut tout simplement afficher sa couleur ambiente (une sorte de couleur d'émission) et sa couleur diffuse. Il suffit d'aller modifier la méthode <a class="el" href="structrt_1_1Renderer.html#a9e6a3e7879649ff7d80d8c038dc471a6">Renderer::trace</a>. On voit qu'elle n'affiche que blanc ou noir pour le moment:</p>
<div class="fragment"><div class="line">Color result = Color( 0.0, 0.0, 0.0 );</div>
<div class="line">GraphicalObject* obj_i = 0; <span class="comment">// pointer to intersected object</span></div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>           p_i;       <span class="comment">// point of intersection</span></div>
<div class="line"><span class="comment">// Look for intersection in this direction.</span></div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> ri = ptrScene-&gt;rayIntersection( ray, obj_i, p_i );</div>
<div class="line"><span class="comment">// Nothing was intersected</span></div>
<div class="line"><span class="keywordflow">if</span> ( ri &gt;= 0.0f ) <span class="keywordflow">return</span> result; <span class="comment">// should be some background color</span></div>
<div class="line"><span class="keywordflow">return</span> Color( 1.0, 1.0, 1.0 );</div>
</div><!-- fragment --><p>On voit qu'il faut modifier la dernière ligne. Comme on a un objet, il suffit de demander à cet objet son <a class="el" href="structrt_1_1Material.html">Material</a> (via <a class="el" href="structrt_1_1GraphicalObject.html#a26e737f6816e3465206d925efe2790f2">GraphicalObject::getMaterial</a>) au point d'intersection. A partir du "Material", on pourra calculer la somme des couleurs diffuses et ambientes. Cela donne:</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-3-small.png" alt=""/>
<div class="caption">
Application ray-tracer</div></div>
  </td><td><div class="image">
<img src="image-3c-small.png" alt=""/>
<div class="caption">
Rendu couleur simple (après Q3.3). Une des boules est devant l'autre.</div></div>
  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Notez que vous pouvez sommer directement des couleurs, grâce aux nombreuses surcharges d'opérateurs dans la classe <a class="el" href="structrt_1_1Color.html">Color</a>.</dd></dl>
<h2><a class="anchor" id="ig_tp2_3_4"></a>
3.4 - Couleurs diffuses</h2>
<p>Evidemment, le rendu précédent est très grossier. On voudrait prendre en compte les sources de lumières, car on sait qu'elles vont changer la couleur perçue des objets. Dans le modèle usuel d'illumination, la couleur diffuse d'un objet ne dépend que de l'orientation de la normale et de la position de la source de lumière.</p>
<div class="image">
<img src="reflection-model-small.png" alt=""/>
<div class="caption">
Modèle d'illumination de Phong</div></div>
<p>On va donc écrire une méthode Renderer::illumination qui va s'occuper pour le moment des parties ambientes et diffuses.</p>
<div class="fragment"><div class="line"><span class="comment">/// Calcule l&#39;illumination de l&#39;objet \a obj au point \a p, sachant que l&#39;observateur est le rayon \a ray.</span></div>
<div class="line">Color rt::Renderer::illumination( <span class="keyword">const</span> Ray&amp; ray, GraphicalObject* obj, Point p );</div>
</div><!-- fragment --><p>Le principe sera le suivant:</p><ul>
<li>on récupère le matériau <em>m</em> de l'objet courant</li>
<li>la couleur résultante sera <em>C</em> </li>
<li>Pour chaque source de lumière <em>l</em> <ul>
<li>On récupère sa direction <em>L</em> </li>
<li>On calcule l'irradiance \( k_d \) comme le cosinus de l'angle entre <em>L</em> et la normale <em>N</em> au point <em>p</em> , i.e. \( k_d \leftarrow  \vec{L} \cdot \vec{N} \), ( \( k_d = 0.0 \) si négatif)</li>
<li>On ajoute à C la couleur produit entre la couleur de la lumière B, la couleur diffuse du matériau D et son coefficient de diffusion \( k_d \). <p class="formulaDsp">
\[ C \leftarrow C + k_d D * B  \]
</p>
</li>
</ul>
</li>
<li>On ajoute à C la couleur ambiente et on retourne le résultat.</li>
</ul>
<p>Cela donne qqchose du genre:</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-3-small.png" alt=""/>
<div class="caption">
Application ray-tracer</div></div>
  </td><td><div class="image">
<img src="image-3d-small.png" alt=""/>
<div class="caption">
Rendu avec diffusion (après Q3.4). </div></div>
  </td></tr>
</table>
<p>Vous pouvez jouer à déplacer les lumières pour voir les changements. On a l'impression de matériaux mats. On peut aussi rajouter d'autres sources de lumière.</p>
<h2><a class="anchor" id="ig_tp2_3_5"></a>
3.5 - Couleurs spéculaires</h2>
<p>Quand on observe une scène éclairée par une forte source de lumière, on s'aperçoit qu'il y a des taches très brillantes qui apparaissent. Ces taches correspondent à la réflexion de la source de lumière sur des matériaux brillants.</p>
<div class="image">
<img src="shiny-balls.png" alt=""/>
<div class="caption">
Taches spéculaires sur des matériaux brillants (les points blancs)</div></div>
<p>On va simuler plus tard la réflexion des rayons, mais comme on ne simulera qu'un seul rebondissement de rayons, on ne pourra pas obtenir ces taches. En effet, physiquement, il faut bien imaginer que les rayons ne sont pas exactement réfléchis, et ces variations aléatoires créent ces taches. On va donc "tricher", et simuler directement ces taches comme on le fait en OpenGL, en calculant ce qu'on appelle la couleur <b>spéculaire</b>.</p>
<p>On met à jour la fonction <code>Renderer::illumination</code>:</p><ul>
<li>soit <em>V</em> la direction du rayon <em>ray</em> venant de l'oeil</li>
<li>pour chaque source de lumière <em>l</em> <ul>
<li>on calcule la direction miroir <em>W</em> de <em>V</em> par rapport à la normale <em>N</em> au point <em>p</em> </li>
<li>on calcule le cosinus \( \beta \) de l'angle entre <em>W</em> et la direction <em>L</em> de la lumière <em>l</em> </li>
<li>si il est négatif il n'y a pas de spécularité.</li>
<li>on utilise la brillance <em>s</em> du matériau (<em>shinyness</em>) pour régler la taille de la tache</li>
<li>le coefficient de spécularité \( k_s \leftarrow \beta^s \) (utilisez <code>pow</code>)</li>
<li>On ajoute à C la couleur produit entre la couleur de la lumière, la couleur spéculaire du matériau et son coefficient de spécularité \( k_s \), tout ça multiplié encore par l'irradiance (déjà calculé pour la couleur diffuse).</li>
</ul>
</li>
</ul>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-3-small.png" alt=""/>
<div class="caption">
Application ray-tracer</div></div>
  </td><td><div class="image">
<img src="image-3e-small.png" alt=""/>
<div class="caption">
Rendu avec diffusion + spécularité (après Q3.5). </div></div>
  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>On écrira une fonction qui calcule le vecteur réfléchi selon une normale <em>N</em> donnée. Notez que si \( W \cdot N \) est positif, cela veut dire que le rayon vient de l'intérieur. Pour la réflexion, cela ne posera pas de problème. <div class="fragment"><div class="line"><span class="comment">/// Calcule le vecteur réfléchi à W selon la normale N.</span></div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> reflect( <span class="keyword">const</span> <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a>&amp; W, <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> N ) <span class="keyword">const</span></div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="ig_tp2_3_6"></a>
3.6 - Un fond moins triste</h2>
<p>Pour le moment, on n'a pas grand chose de mieux que ce que le simple rendu OpenGL peut donner. Par exemple, on n'a pas les ombres portées, la réflexion ou la réfraction, ni le fond. On commence par le plus simple, un fond moins triste.</p>
<p>Il faut modifier la méthode <a class="el" href="structrt_1_1Renderer.html#a9e6a3e7879649ff7d80d8c038dc471a6">Renderer::trace</a> pour que, lorsque le rayon n'intersecte pas d'objet, une couleur spécifique soit renvoyée plutôt que la couleur noire. Ecrivez donc une structure <code>Background</code> qui comportera une méthode (virtuelle) pour retourner la couleur dans une direction <em>ray</em> donnée.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Background {</div>
<div class="line">  <span class="keyword">virtual</span> Color backgroundColor( <span class="keyword">const</span> Ray&amp; ray ) = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyBackground : <span class="keyword">public</span> Background {</div>
<div class="line">  Color backgroundColor( <span class="keyword">const</span> Ray&amp; ray )</div>
<div class="line">  { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Pour faire un dégradé pour le ciel, il suffit de regarder seulement la composante z de la <b>direction</b> du rayon <em>ray</em>. Par exemple, si z est entre 0 et 0.5, on retourne une couleur entre blanc (<code>Color(1,1,1)</code>) et bleu (<code><a class="el" href="structrt_1_1Color.html">Color</a>(0.0,0.0,1.0)</code>), puis si z est entre 0.5 et 1.0, on retourne une couleur entre bleu (<code><a class="el" href="structrt_1_1Color.html">Color</a>(0.0,0.0,1.0)</code>) et noir ((<code><a class="el" href="structrt_1_1Color.html">Color</a>(0.0,0.0,0.0)</code>). On rappelle que l'on peut mélanger des couleurs avec des multiplications, par exemple: </p><div class="fragment"><div class="line"> <span class="comment">// Mélange</span></div>
<div class="line">2/5*rouge et 3/5*jaune Color orange = 0.4 * Color(1,0,0) + 0.6 *</div>
<div class="line">Color(1,1,0); </div>
</div><!-- fragment --><p>Ensuite, on associe un objet <code>Background</code> au <a class="el" href="structrt_1_1Renderer.html" title="This structure takes care of rendering a scene.">Renderer</a> à sa création (dans <code>Renderer::Renderer</code> donc). Enfin, on rajoute la méthode <code>Renderer::background</code> qui s'occupe d'afficher les sources de lumière et votre fond:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Renderer { </div>
<div class="line"> ...</div>
<div class="line">    <span class="comment">// On rajoute un pointeur vers un objet Background</span></div>
<div class="line">    Background* ptrBackground;</div>
<div class="line"> ...</div>
<div class="line">    <span class="comment">// Affiche les sources de lumières avant d&#39;appeler la fonction qui</span></div>
<div class="line">    <span class="comment">// donne la couleur de fond.</span></div>
<div class="line">    Color background( <span class="keyword">const</span> Ray&amp; ray )</div>
<div class="line">    {</div>
<div class="line">      Color result = Color( 0.0, 0.0, 0.0 );</div>
<div class="line">      <span class="keywordflow">for</span> ( Light* light : <a class="code hl_variable" href="structrt_1_1Renderer.html#a960f2d4bf657536ad5b52b3818e43f71">ptrScene</a>-&gt;myLights )</div>
<div class="line">        {</div>
<div class="line">          <a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> cos_a = light-&gt;direction( ray.origin ).dot( ray.direction );</div>
<div class="line">          <span class="keywordflow">if</span> ( cos_a &gt; 0.99f )</div>
<div class="line">            {</div>
<div class="line">              <a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> a = acos( cos_a ) * 360.0 / M_PI / 8.0;</div>
<div class="line">              a = std::max( 1.0f - a, 0.0f );</div>
<div class="line">              result += light-&gt;color( ray.origin ) * a * a;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">if</span> ( ptrBackground != 0 ) result += ptrBackground-&gt;backgroundColor( ray );</div>
<div class="line">      <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">...</div>
<div class="line">};</div>
<div class="ttc" id="astructrt_1_1Renderer_html_a960f2d4bf657536ad5b52b3818e43f71"><div class="ttname"><a href="structrt_1_1Renderer.html#a960f2d4bf657536ad5b52b3818e43f71">rt::Renderer::ptrScene</a></div><div class="ttdeci">Scene * ptrScene</div><div class="ttdoc">The scene to render.</div><div class="ttdef"><b>Definition</b> <a href="Renderer_8h_source.html#l00052">Renderer.h:52</a></div></div>
</div><!-- fragment --><p>Il ne reste plus qu'à appeler <code>Renderer::background</code> depuis <code><a class="el" href="structrt_1_1Renderer.html#a9e6a3e7879649ff7d80d8c038dc471a6">Renderer::trace</a></code> lorsque le rayon n'intersecte rien.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-4a-small.png" alt=""/>
<div class="caption">
Application ray-tracer</div></div>
  </td><td><div class="image">
<img src="image-4b-small.png" alt=""/>
<div class="caption">
Rendu avec le fond (après Q3.6). </div></div>
  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>On peut reprendre le bout de code suivant lorsque z est négatif pour faire le damier. A vous de le modifier si vous voulez être plus original que le voisin.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> x = -0.5f * ray.direction[ 0 ] / ray.direction[ 2 ];</div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> y = -0.5f * ray.direction[ 1 ] / ray.direction[ 2 ];</div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> d = sqrt( x*x + y*y );</div>
<div class="line"><a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> t = std::min( d, 30.0f ) / 30.0f;</div>
<div class="line">x -= floor( x );</div>
<div class="line">y -= floor( y );</div>
<div class="line"><span class="keywordflow">if</span> ( ( ( x &gt;= 0.5f ) &amp;&amp; ( y &gt;= 0.5f ) ) || ( ( x &lt; 0.5f ) &amp;&amp; ( y &lt; 0.5f ) ) )</div>
<div class="line">  result += (1.0f - t)*Color( 0.2f, 0.2f, 0.2f ) + t * Color( 1.0f, 1.0f, 1.0f );</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  result += (1.0f - t)*Color( 0.4f, 0.4f, 0.4f ) + t * Color( 1.0f, 1.0f, 1.0f );</div>
</div><!-- fragment --><h1><a class="anchor" id="ig_tp2_4"></a>
4 - Ombres, réflexions, réfractions</h1>
<p>On peut maintenant rentrer dans le vif du sujet. On va s'occuper de rendre plus réaliste le rendu en simulant le trajet des rayons lumineux.</p>
<h2><a class="anchor" id="ig_tp2_4_1"></a>
4.1 - Ombres portées</h2>
<p>Actuellement, pour calculer le rendu en un point <em>p</em> d'un objet, on regarde les sources de lumières et on additionne les couleurs diffuses et spéculaires correspondantes. Or, si un autre objet se situe entre <em>p</em> et la source de lumière, il devrait y avoir occultation. Autrement dit, le point <em>p</em> est dans l'ombre par rapport à la source de lumière.</p>
<div class="image">
<img src="rt-lighting-shadow.gif" alt=""/>
<div class="caption">
Que signifie 'être dans l'ombre' ?</div></div>
<p>On va donc créer une méthode <code>Renderer::shadow</code> qui va calculer un coefficient d'ombrage dans une direction vers une source de lumière. Le principe est d'atténuer la lumière si le rayon intersecte des objets en allant vers la lumière (atténuation complète si un objet traversé est opaque, partielle sinon en fonction de la transparence de l'objet (réfraction) et de sa couleur).</p>
<div class="fragment"><div class="line"><span class="comment">/// Calcule la couleur de la lumière (donnée par light_color) dans la</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// direction donnée par le rayon. Si aucun objet n&#39;est traversé,</span></div>
<div class="line"><span class="comment">/// retourne light_color, sinon si un des objets traversés est opaque,</span></div>
<div class="line"><span class="comment">/// retourne du noir, et enfin si les objets traversés sont</span></div>
<div class="line"><span class="comment">/// transparents, attenue la couleur.</span></div>
<div class="line"><span class="comment"></span>Color shadow( <span class="keyword">const</span> Ray&amp; ray, Color light_color );</div>
</div><!-- fragment --><ul>
<li>En entrée, le rayon par de <em>p</em> et va vers <em>L</em> (direction lumière)</li>
<li>Soit C &lt;- couleur de lumière en entrée.</li>
<li>Tant que C.max() &gt; 0.003f faire // tant que c'est pas noir<ul>
<li>on déplace légèrement p vers L pour éviter d'intersecter l'objet initial.</li>
<li>si ce rayon [p,L) intersecte un autre objet (<a class="el" href="structrt_1_1Scene.html#a3a72879a8e5988b69352a3e5f00235b1">Scene::rayIntersection</a>)<ul>
<li>on récupère le matériau m de l'objet au point p' d'intersection</li>
<li>C est multiplié par la couleur diffuse et le coefficient de refraction de m</li>
<li>p &lt;- p'</li>
</ul>
</li>
<li>sinon break</li>
</ul>
</li>
<li>on retourne C.</li>
</ul>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-5a-small.png" alt=""/>
<div class="caption">
Application ray-tracer</div></div>
  </td><td><div class="image">
<img src="image-5b-small.png" alt=""/>
<div class="caption">
Rendu avec ombrage (après Q4.1). Notez que la boule de bronze est opaque, et donc que l'ombre est franche. La boule émeraude est-elle un peu transparente. Son ombre prend donc sa couleur diffuse et attenue la lumière.</div></div>
  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Pour le moment, on n'a pas d'ombre sur le damier. C'est normal, il faut imaginer qu'il est très loin (à l'infini en fait). On règlera ce problème en rajoutant un plan infini pour faire le sol (voir question 5.1).</dd></dl>
<h2><a class="anchor" id="ig_tp2_4_2"></a>
4.2 - Réflexions</h2>
<p>Que serait un ray-tracer sans les reflets ? Pas grand chose. En réalité les couleurs proviennent toujours d'une réflexion d'un rayon lumineux ou de sa transmission par transparence. La notion de couleur diffuse (ou mat) et de spécularité sont des approximations bien commodes pour du rendu rapide, mais traduisent en réalité des moyennes pour des zillions de rayons lumineux qui touchent le point observé.</p>
<p>On va simplifier beaucoup tout ça en ne calculant au maximum qu'<b>un</b> rayon réfléchi (et dans la question suivante <b>un</b> rayon réfracté). De plus, on ne va réfléchir le rayon qu'un nombre fini de fois (la fameuse profondeur maximale ou <code>max_depth</code> donnée à <a class="el" href="structrt_1_1Renderer.html#aeca19cc2de6839aada6f4524e63bb45f" title="The main rendering routine.">Renderer::render</a>).</p>
<div class="image">
<img src="rt-reflection-refraction.gif" alt=""/>
<div class="caption">
Réflexion et réfraction de rayons</div></div>
<p>On va mettre à jour la méthode <a class="el" href="structrt_1_1Renderer.html#a9e6a3e7879649ff7d80d8c038dc471a6">Renderer::trace</a>. Le principe de la réflexion est très simple. Au point <em>p</em> d'intersection, si le matériau est réfléchissant (coef_reflexion != 0 ), on lance un rayon dans la direction réfléchie en appelant <a class="el" href="structrt_1_1Renderer.html#a9e6a3e7879649ff7d80d8c038dc471a6">Renderer::trace</a> <b>récursivement</b>. Si le matériau n'est pas réfléchissant ou si la profondeur maximale est atteinte, on retourne <code>Renderer::illumination</code> comme avant. En pseudo-code, <a class="el" href="structrt_1_1Renderer.html#a9e6a3e7879649ff7d80d8c038dc471a6">Renderer::trace</a> devient:</p>
<ul>
<li>C &lt;- noir</li>
<li>Si le rayon <em>ray</em> ne touche aucun objet alors on retourne <code>background( ray )</code></li>
<li>Si ray.depth &gt; 0 et le matériau <em>m</em> est réfléchissant au point <em>p</em> d'intersection<ul>
<li>On calcule ray_refl le rayon réfléchi (avec une profondeur décrémentée)</li>
<li>C_refl &lt;- trace( ray_refl )</li>
<li>C += C_refl * m.specular * m.coef_reflexion</li>
</ul>
</li>
<li>C += illumination( ray ... )</li>
<li>retourne C</li>
</ul>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-5a-small.png" alt=""/>
<div class="caption">
Application ray-tracer</div></div>
  </td><td><div class="image">
<img src="image-6-small.png" alt=""/>
<div class="caption">
Rendu avec reflets (après Q4.2). Notez que le 'bronze' a été créé très brillant (c'est plus du cuivre). On voit bien les reflets sur tous les objets, mais beaucoup moins sur les objets très mats.</div></div>
  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>La scène ci-dessus est juste écrite ainsi dans <a class="el" href="ray-tracer_8cpp_source.html">ray-tracer.cpp</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Light at infinity</span></div>
<div class="line">Light* light0 = <span class="keyword">new</span> PointLight( GL_LIGHT0, Point4( 0,0,1,0 ),</div>
<div class="line">                                  Color( 1.0, 1.0, 1.0 ) );</div>
<div class="line">Light* light1 = <span class="keyword">new</span> PointLight( GL_LIGHT1, Point4( -10,-4,2,1 ),</div>
<div class="line">                                Color( 1.0, 1.0, 1.0 ) );</div>
<div class="line">scene.addLight( light0 );</div>
<div class="line">scene.addLight( light1 );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Objects</span></div>
<div class="line">Sphere* sphere1 = <span class="keyword">new</span> Sphere( <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>( 0, 0, 0), 2.0, Material::bronze() );</div>
<div class="line">Sphere* sphere2 = <span class="keyword">new</span> Sphere( <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>( 0, 4, 0), 1.0, Material::emerald() );</div>
<div class="line">Sphere* sphere3 = <span class="keyword">new</span> Sphere( <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>( 6, 6, 0), 3.0, Material::whitePlastic() );</div>
<div class="line">scene.addObject( sphere1 );</div>
<div class="line">scene.addObject( sphere2 );</div>
<div class="line">scene.addObject( sphere3 );</div>
</div><!-- fragment --><h2><a class="anchor" id="ig_tp2_4_3"></a>
4.3 - Réfractions</h2>
<p>La réfraction de la lumière est le principe physique qui fait qu'une partie des rayons lumineux traverse certains matériaux plutôt que de rebondir dessus. Contrairement à la réflexion, la direction du rayon réfracté dépend du milieu physique en entrée et en sortie. Ainsi, l'eau déforme les rayons lumineux qui viennent de l'air. C'est pourquoi on a l'impression que le fond de l'eau est grossi.</p>
<p>De façon générale, cela provient du fait que la lumière change de vitesse selon la matériau. La lumière est plus lente dans l'eau que dans l'air par exemple. On modélise tout cela simplement à l'aide d'un nombre, l'<b>index</b> <b>de</b> <b>réfraction</b>. Par exemple, l'air a un indice de 1 environ, l'eau liquide de 1.33, le verre de 1.5, etc.</p>
<p>Ensuite, le ratio \( r=n1/n2 \) entre l'indice de réfraction du milieu en entrée <em>n1</em> et celui du milieu de sortie <em>n2</em>, influence la direction du rayon réfracté (en fait sa vitesse aussi, mais on ne s'en occupe pas ici). La loi de Snell s'écrit alors, si <em>V</em> est la direction du rayon en entrée et <em>N</em> la normale:</p>
<p class="formulaDsp">
\[ V_{refract} = r V + \left( rc - \sqrt{1 - r^2( 1 - c^2 )} \right) N \]
</p>
<p>avec \( c = - N \cdot V \). Ecrivez donc d'abord la méthode <code>Renderer::refractionRay</code> qui calcule le rayon réfracté, de prototype suivant:</p>
<div class="fragment"><div class="line">Ray refractionRay( <span class="keyword">const</span> Ray&amp; aRay, <span class="keyword">const</span> <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>&amp; p, <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a> N, <span class="keyword">const</span> Material&amp; m );</div>
</div><!-- fragment --><p>Il ne suffit plus alors qu'à faire la même chose que pour la réflexion, en appelant <b>récursivement</b> <a class="el" href="structrt_1_1Renderer.html#a9e6a3e7879649ff7d80d8c038dc471a6">Renderer::trace</a> avec le rayon réfracté et en sommant la couleur résultante en tenant compte du coefficient de réfraction et de la couleur diffuse.</p>
<dl class="section note"><dt>Note</dt><dd>1. Pour chaque materiau, on a définit un indice de réfraction en entrée et un autre en sortie. On voit donc qu'on modélise une <b>interface</b> entre 2 milieux. Si vous voulez faire une bulle en verre (genre bulle de savon), il faut créer une sphère extérieure d'interface air/verre et une sphère intérieure de rayon très légèrement inférieur et d'interface verre/air.</dd>
<dd>
2. Faites attention aussi dans cette méthode au fait que le rayon peut venir de l'<b>intérieur</b> de l'objet (si \( V.N \) est positif). Dans ce cas là, il faut <b>adapter</b> <b>la</b> formule et les indices de réfraction.</dd></dl>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-Q4-3a.png" alt=""/>
<div class="caption">
Premier résultat: vous devriez voir une bulle beaucoup trop blanche !</div></div>
  </td><td><div class="image">
<img src="image-Q4-3b.png" alt=""/>
<div class="caption">
Rendu avec reflets et réfractions corrigé (après Q4.3). En fait, on a oublié à gauche de multiplier l'illumination (`Renderer::illumination`) par le coefficient de diffusion du matériau (très faible pour le verre).</div></div>
  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>1. Il faut multiplier le résultat de l'illumination par le coefficient de diffusion du matériau <b>sauf</b> <b>si</b> on est arrivé à la profondeur 0.</dd>
<dd>
2. Voilà un bout de code pour ajouter des bulles dans <a class="el" href="ray-tracer_8cpp_source.html">ray-tracer.cpp</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> addBubble( Scene&amp; scene, <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a> c, <a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> r, Material transp_m )</div>
<div class="line">{</div>
<div class="line">  Material revert_m = transp_m;</div>
<div class="line">  std::swap( revert_m.in_refractive_index, revert_m.out_refractive_index );</div>
<div class="line">  Sphere* sphere_out = <span class="keyword">new</span> Sphere( c, r, transp_m );</div>
<div class="line">  Sphere* sphere_in  = <span class="keyword">new</span> Sphere( c, r-0.02f, revert_m );</div>
<div class="line">  scene.addObject( sphere_out );</div>
<div class="line">  scene.addObject( sphere_in );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// dans main</span></div>
<div class="line">  addBubble( scene, <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>( -5, 4, -1 ), 2.0, Material::glass() );</div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="ig_tp2_4_4"></a>
4.4 - De l'influence de la profondeur de réflexion / réfraction</h2>
<p>Vous devez observer que les temps de calcul ont fortement augmenté depuis l'introduction de la réfraction et de matériaux transparents. C'est normal, maintenant les rayons se divisent sur de tels surfaces, et un rayon devient l'addition de \( 2^d \) rayons, où <em>d</em> est la profondeur maximum. Notez que le paramètre <code>max_depth</code> est important dans certaines scènes, et doit parfois être augmenté. Voilà ci-dessous une même scène visualisée avec un paramètre de profondeur maximale croissant:</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-Q4-4-d1.png" alt=""/>
<div class="caption">
Max depth = 1</div></div>
  </td><td><div class="image">
<img src="image-Q4-4-d2.png" alt=""/>
<div class="caption">
Max depth = 2</div></div>
   </td></tr>
<tr>
<td><div class="image">
<img src="image-Q4-4-d3.png" alt=""/>
<div class="caption">
Max depth = 3</div></div>
  </td><td><div class="image">
<img src="image-Q4-4-d4.png" alt=""/>
<div class="caption">
Max depth = 4</div></div>
   </td></tr>
<tr>
<td><div class="image">
<img src="image-Q4-4-d5.png" alt=""/>
<div class="caption">
Max depth = 5</div></div>
  </td><td><div class="image">
<img src="image-Q4-4-d6.png" alt=""/>
<div class="caption">
Max depth = 6</div></div>
   </td></tr>
<tr>
<td><div class="image">
<img src="image-Q4-4-d8.png" alt=""/>
<div class="caption">
Max depth = 8</div></div>
  </td><td><div class="image">
<img src="image-Q4-4-d12.png" alt=""/>
<div class="caption">
Max depth = 12</div></div>
   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Vous disposez des touches <b>D</b> et <b>Shift</b> <b>+</b> <b>D</b> pour augmenter / diminuer la profondeur maximale.</dd></dl>
<h2><a class="anchor" id="ig_tp2_4_5"></a>
4.5 - Il est temps de jouer !</h2>
<p>Vous avez maintenant une bonne base pour commencer à faire de jolies images. Ajoutez des sphères, modifiez des matériaux et proposez-en de nouveaux. Placez des lumières, etc. Modifiez les couleurs du fond pour un effet nuit / aube / plein jour. Un peu de créativité et vous pouvez faire de très jolies images ...</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-Q4-5a.png" alt=""/>
<div class="caption">
Le cuivre donne l'impression de reflets à l'infini.</div></div>
  </td><td><div class="image">
<img src="image-Q4-5b.png" alt=""/>
<div class="caption">
On voit ici que la profondeur utilisée (10) n'est pas suffisante pour traverser cet amas de bulles.</div></div>
   </td></tr>
</table>
<h1><a class="anchor" id="ig_tp2_5"></a>
5 - Allez plus loin, allez plus haut !</h1>
<p>Cette section propose diverses extensions, améliorations et enrichissement à votre ray-tracer. Tout n'est pas à faire, c'est juste pour vous donner des idées d'extensions possibles. Si vous avez d'autres idées, n'hésitez pas non plus. Chaque amélioration proposée est en général indépendante des autres et, soit elle améliore le rendu, soit elle l'accélère, soit elle l'enrichit avec de nouvelles primitives géométriques. Le nombre d'étoiles (*, **, ***) indique la "difficulté" de l'extension.</p>
<h2><a class="anchor" id="ig_tp2_5_1"></a>
5.1 Un nouvel objet graphique: le plan infini (*)</h2>
<p>Pour le moment, on n'a pas de sol à nos scènes. On va en rajouter en définissant un nouveau <a class="el" href="structrt_1_1GraphicalObject.html">GraphicalObject</a>, que l'on appelera <code>PeriodicPlane</code>. Pourquoi périodique ? C'est juste qu'on pourra définir le matériau en un point périodiquement en fonction de ses coordonnées dans le plan. Son constructeur ressemblera à</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PeriodicPlane : <span class="keyword">public</span> GraphicalObject <span class="comment">// Vous devez dériver de GraphicalObject</span></div>
<div class="line">{<span class="comment"></span></div>
<div class="line"><span class="comment">  /// Creates a periodic infinite plane passing through \a c and</span></div>
<div class="line"><span class="comment">  /// tangent to \a u and \a v. Then \a w defines the width of the</span></div>
<div class="line"><span class="comment">  /// band around (0,0) and its period to put material \a band_m,</span></div>
<div class="line"><span class="comment">  /// otherwise \a main_m is used.</span></div>
<div class="line"><span class="comment"></span>  PeriodicPlane( Point3 c, Vector3 u, Vector3 v,</div>
<div class="line">                 Material main_m, Material band_m, Real w);</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p>Le plan ainsi créé est un plan passant par le point <em>c</em>, avec deux vecteurs orthogonaux tangents <em>u</em> et <em>v</em> qui vont définir les coordonnées du point d'intersection dans le plan. Maintenant, si <em>p</em> est le point d'intersection entre un rayon et le plan, <em>p</em> pourra aussi être défini à l'aide des deux coordonnées <em>x</em> et <em>y</em> selon les vecteurs <em>u</em> et <em>v</em>.</p>
<p>Ensuite les deux matériaux servent à définir l'aspect du plan infini. Si le point <em>p</em> a des coordonnées <em>x</em> ou <em>y</em> proche d'un entier, alors on utilise le matériau pour les bandes (<em>band_m</em>), sinon on utilise le matériau principal (<em>main_m</em>). Le réel <em>w</em>, plus petit que 1, est l'épaisseur de la bande.</p>
<p>Vous écrirez une méthode pour calculer les coordonnées d'un point dans le plan. </p><div class="fragment"><div class="line"><span class="comment">/// Etant donné un point \a p dans le plan, retourne ses coordonnées \a x et \a y selon \a u et \a v.</span></div>
<div class="line"><span class="keywordtype">void</span> PeriodicPlane::coordinates( <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a> p, <a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a>&amp; x, <a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a>&amp; y );</div>
</div><!-- fragment --><p>Il faut maintenant implémenter toutes les méthodes de <a class="el" href="structrt_1_1GraphicalObject.html">GraphicalObject</a>:</p><ul>
<li><a class="el" href="structrt_1_1GraphicalObject.html#a7e44e4ceb4562f25aca3864840f06e22">GraphicalObject::init</a>: rien à faire, ou un peu de précalcul</li>
<li><a class="el" href="structrt_1_1GraphicalObject.html#a82b3b7e9ce32eb5ac22247cf5dc21f62">GraphicalObject::draw</a>: affichez juste 2 grands triangles dans le plan avec OpenGL.</li>
<li><a class="el" href="structrt_1_1GraphicalObject.html#a7f300384fd59f774502658151628cae0">GraphicalObject::getNormal</a>: c'est trivial car c'est juste le produit vectoriel entre <em>u</em> et <em>v</em>.</li>
<li><a class="el" href="structrt_1_1GraphicalObject.html#a26e737f6816e3465206d925efe2790f2">GraphicalObject::getMaterial</a>: il suffit de calculer les coordonnées x,y du point d'intersection, et retourner <em>main_m</em> ou <em>band_m</em> selon où tombe (x,y).</li>
<li><a class="el" href="structrt_1_1GraphicalObject.html#a07ad12a1053712028353e5d89dbd47c4">GraphicalObject::rayIntersection</a>: il s'agit de l'intersection entre un rayon et un plan.</li>
</ul>
<p>Avec votre nouvelle classe, on peut facilement créer des sols ou des murs variés: </p><div class="fragment"><div class="line"><span class="comment">// Un sol noir et blanc</span></div>
<div class="line">PeriodicPlane* pplane = <span class="keyword">new</span> PeriodicPlane( <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>( 0, 0, 0 ), <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a>( 5, 0, 0 ), <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a>( 0, 5, 0 ),</div>
<div class="line">                                           Material::whitePlastic(), Material::blackMatter(), 0.05f );</div>
<div class="line"><span class="comment">// Un mur de building &quot;moderne&quot; à gauche.</span></div>
<div class="line">PeriodicPlane* pplane = <span class="keyword">new</span> PeriodicPlane( <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>( -10, 0, 0 ), <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a>( 0, 2, 0 ), <a class="code hl_typedef" href="namespacert.html#aafd88fe1113c5fe48274a138510492ec">Vector3</a>( 0, 0, 4 ),</div>
<div class="line">                                           Material::mirror(), Material::blackMatter(), 0.025f );</div>
<div class="line">...</div>
</div><!-- fragment --><table class="doxtable">
<tr>
<td><div class="image">
<img src="image-Q5-1a.png" alt=""/>
<div class="caption">
Un sol noir et blanc avec bille miroir, bulle et billes en cuivre.</div></div>
  </td><td><div class="image">
<img src="image-Q5-1b.png" alt=""/>
<div class="caption">
Mur de building infini réfléchissant à gauche, et plan infini 'eau' en bas.</div></div>
   </td></tr>
</table>
<h2><a class="anchor" id="ig_tp2_5_2"></a>
5.2 Une variante du plan infini, l'eau calme (***)</h2>
<p>On peut adapter le plan infini pour faire de l'eau calme. L'idée est de garder la géométrie du plan infini (donc un simple plan), mais de perturber les <b>normales</b> selon des sommes de sinusoïdes. En gros, <code>WaterPlane::getNormal( Point p )</code> dépend des coordonnées <em>x</em> et <em>y</em> de <em>p</em> dans le plan.</p>
<p>Pour l'eau, on utilise le <a class="el" href="structrt_1_1Material.html">Material</a> suivant: </p><div class="fragment"><div class="line"><span class="comment">// Dans struct Material {</span></div>
<div class="line">    <span class="keyword">static</span> Material blueWater() </div>
<div class="line">    {</div>
<div class="line">      Material m;</div>
<div class="line">      m.ambient   = Color( 0.1, 0.1, 0.2 );</div>
<div class="line">      m.diffuse   = Color( 0.1, 0.6, 0.8 );</div>
<div class="line">      m.specular  = Color( 1.0, 1.0, 1.0 );</div>
<div class="line">      m.shinyness = 70.0f;</div>
<div class="line">      m.coef_diffusion  = 0.01f;</div>
<div class="line">      m.coef_reflexion  = 0.2f;</div>
<div class="line">      m.coef_refraction = 0.8f;</div>
<div class="line">      m.in_refractive_index  = 1.3f;</div>
<div class="line">      m.out_refractive_index = 1.0f;</div>
<div class="line">      <span class="keywordflow">return</span> m;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Les sinusoïdes s'écrivent sous la forme:</p>
<p class="formulaDsp">
\[ t(x,y) = x \cos a + y \sin a \]
</p>
 <p class="formulaDsp">
\[ f(x,y) = r \cos( 2 \pi t(x,y) / l + \phi ) \]
</p>
<p>avec:</p><ul>
<li><em>r</em> : amplitude de l'onde</li>
<li><em>a</em> : angle de propagation par rapport à l'axe <em>u</em> du plan</li>
<li><em>l</em> : la longueur d'onde (inverse de la fréquence)</li>
<li>\( \phi \): la phase, ou l'angle lorsque t vaut 0</li>
</ul>
<p>Vous écrirez votre <code>WaterPlane::getNormal</code> en retournant le vecteur normal à ces sommes de sinusoïdes.</p>
<p>Ce système de perturber les normales marche pour plein de matériaux !!</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-Q5-2a.png" alt=""/>
<div class="caption">
L'eau fait toujours de jolis reflets avec un soleil proche de l'horizon.</div></div>
  </td><td><div class="image">
<img src="image-Q5-2b.png" alt=""/>
<div class="caption">
L'eau fait toujours de jolis reflets avec un soleil proche de l'horizon.</div></div>
   </td></tr>
</table>
<h2><a class="anchor" id="ig_tp2_5_3"></a>
5.3 Anti-aliasing et problèmes numériques (**)</h2>
<p>Pour le moment, on envoie un seul rayon par pixel. Cela marche très bien tant que la couleur en ce pixel n'est pas trop dépendante d'une petite déviation de la direction du rayon. En revanche, vous pouvez voir qu'à certains endroits (aux bords des objets notamment, ou lorsqu'il y a une brusque variation du matériau), on observe des petits défauts dans l'algorithme de rendu. A ces endroits, on a à la fois des effets d'aliasing (pixelisation) et des erreurs numériques (dans les calculs des rebonds de rayons).</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-Q5-3a.png" alt=""/>
<div class="caption">
Petits effets d'aliasing sur les transitions noirs/blancs et sur le haut de la boule en bronze.</div></div>
  </td><td><div class="image">
<img src="image-Q5-3b.png" alt=""/>
<div class="caption">
On corrige en envoyant plusieurs rayons par pixel avec des petites déviations aléatoires.</div></div>
   </td></tr>
</table>
<p>Pour corriger ce problème, vous pouvez écrire une fonction <code>Renderer::randomRender</code> qui, au lieu d'envoyer un rayon par pixel, envoie plusieurs rayons au hasard dans le pixel (entre 10 et 20). On fait ensuite la moyenne des couleurs pour l'affecter au pixel. On peut accélérer le processus en observant l'écart entre la couleur moyenne actuelle et la couleur donnée par le dernier lancer de rayon. Si il est très proche et que c'est au moins le 5ème, on stoppe de suite. Ce nouvel algorithme de rendu est en général entre 5 et 10 fois plus lent que le précédent, mais le rendu est de meilleure qualité.</p>
<h2><a class="anchor" id="ig_tp2_5_4"></a>
5.4 Un nouvel objet graphique : le triangle (**)</h2>
<p>Sur le même principe que le plan infini, on peut définir une classe <code>Triangle</code> comm nouveau <a class="el" href="structrt_1_1GraphicalObject.html">GraphicalObject</a>. Le triangle est défini tout simplement par 3 points <em>A</em>, <em>B</em> et <em>C</em> dans l'espace. Les deux vecteurs \( \vec{AB} \) et \( \vec{AC} \) définissent le plan tangent au triangle, et la normale \( \vec{N} \) est obtenue par leur produit vectoriel. Pour savoir si un point <em>p</em> appartenant au plan tangent est à l'intérieur du triangle, on résoud le petit système suivant:</p>
<p class="formulaDsp">
\[ \alpha \vec{AB} + \beta \vec{AC} + \gamma \vec{N} = p - A \]
</p>
<p>En fait si <em>p</em> appartient au plan, \( \gamma = 0 \). Ensuite, on prend le vecteur \( \vec{V} \) orthogonal à \( \vec{AB} \) et à \( \vec{N}
\) (calculé par produit vectoriel), et on fait son produit scalaire avec le système précédent. Comme \( \vec{AB} \cdot \vec{V} = 0 \) Il reste:</p>
<p class="formulaDsp">
\[ \beta \vec{AC}\cdot \vec{V} = (p - A) \cdot \vec{V} \]
</p>
<p>On déduit directement \( \beta \). En le réinjectant dans l'équation au-dessus, on trouve \( \alpha \). Or <em>p</em> appartient au triangle si et seulement si </p><p class="formulaDsp">
\[ 0 \le \alpha, 0 \le \beta, \alpha + \beta \le 1. \]
</p>
<p>En assemblant des triangles, on peut faire des pyramides ou des surfaces triangulées complexes. Le code ci-dessous construit une pyramide avec 4 triangles.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> pyramid( Scene&amp; scene, <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a> C, <a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> side, Material main, Material band, <a class="code hl_typedef" href="namespacert.html#a31304cdacdb1cd0eaab05bcd2e641242">Real</a> w )</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a> A1 = C + <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>( -side/2.0f, -side/2.0f, 0.0f );</div>
<div class="line">  <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a> A2 = C + <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>(  side/2.0f, -side/2.0f, 0.0f );</div>
<div class="line">  <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a> A3 = C + <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>(  side/2.0f,  side/2.0f, 0.0f );</div>
<div class="line">  <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a> A4 = C + <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>( -side/2.0f,  side/2.0f, 0.0f );</div>
<div class="line">  <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a> T  = C + <a class="code hl_typedef" href="namespacert.html#a82b401d949a79dfd801b458fc7363214">Point3</a>(       0.0f,       0.0f, sqrt(2.0f)*side/2.0f );</div>
<div class="line">  scene.addObject( <span class="keyword">new</span> Triangle( A1, A2, T, main, band, w ) );</div>
<div class="line">  scene.addObject( <span class="keyword">new</span> Triangle( A2, A3, T, main, band, w ) );</div>
<div class="line">  scene.addObject( <span class="keyword">new</span> Triangle( A3, A4, T, main, band, w ) );</div>
<div class="line">  scene.addObject( <span class="keyword">new</span> Triangle( A4, A1, T, main, band, w ) );</div>
<div class="line">}</div>
</div><!-- fragment --><table class="doxtable">
<tr>
<td><div class="image">
<img src="image-Q5-4a.png" alt=""/>
<div class="caption">
Un parfum d'Egypte ?</div></div>
   </td></tr>
</table>
<h2><a class="anchor" id="ig_tp2_5_5"></a>
5.5 Mettre des textures sur les triangles (***)</h2>
<p>C'est en fait assez facile de faire un <code>TexturedTriangle</code> une fois que la question 5.4 est traitée. Il s'agit de créer un <a class="el" href="structrt_1_1Material.html">Material</a> qui est associé à une image couleur (utilisez la classe <a class="el" href="classrt_1_1Image2D.html" title="Classe générique pour représenter des images 2D.">Image2D</a> et votre Image2DReader du TP C++ pour charger une image de texture). Ensuite, on place les coordonnées (0,0) en haut à gauche de l'image, le (1,0) en haut à droite, le (0,1) en bas à gauche et le (1,1) en bas à droite. Maintenant, dans la classe triangle, vous devez calculer \(
\alpha \) et \( \beta \) pour savoir si vous êtes dans le triangle. Or il s'agit exactement de coordonnées dans l'image de texture. Du coup, au lieu de retourner tout le temps le même matériau au point considéré, vous retournez un matériau dont la couleur diffuse est la couleur de la texture aux coordonnées \( (\alpha, \beta) \).</p>
<h2><a class="anchor" id="ig_tp2_5_6"></a>
5.6 Rendu rapide par décision aléatoire (***)</h2>
<p>On peut adapter la question 5.3 d'une autre manière pour à la fois éliminer l'anti-aliasing et faire un algorithme dont la complexité n'explose pas avec la profondeur, et qui est beaucoup plus rapide en pratique. L'idée est simple: notons <em>a</em> le coefficient de diffusion du matériau, <em>b</em> son coefficient de réflexion et <em>c</em> son coefficient de réfraction. Il faut que \( a+b+c=1 \) (c'est assez normal, sinon le matériau crée de l'énergie). Pour le moment, vous calculer la couleur diffuse et vous l'atténuez avec le coefficient <em>a</em>, puis vous lancez potentiellement un rayon réfléchi que vous atténuez avec <em>b</em>, et enfin vous lancez potentiellement un rayon réfracté que vous atténuez avec <em>c</em>. On voit qu'à chaque profondeur il y a risque de doubler le nombre de rayons.</p>
<p>La tactique de rendu que l'on propose de faire maintenant est en un sens presque plus simple. A chaque fois que vous rentrez dans <code><a class="el" href="structrt_1_1Renderer.html#a9e6a3e7879649ff7d80d8c038dc471a6">Renderer::trace</a></code>, vous allez tirer un nombre aléatoire <em>x</em> entre 0 et 1 et vous calculez alors:</p><ul>
<li>si \( x \le a \) alors vous retournez la couleur diffuse,</li>
<li>si \( a \le x \le a+b \) alors vous retournez le résultat du lancer du rayon réfléchi,</li>
<li>si \( a+b \le x \le 1 \) alors vous retournez le résultat du lancer du rayon réfracté.</li>
</ul>
<p>Ensuite, comme vous lancez maintenant une centaine de rayons par pixel, la moyenne des couleurs fera bien le même résultats que l'algorithme de la question 5.3.</p>
<h2><a class="anchor" id="ig_tp2_5_7"></a>
5.7 Faire un film (**)</h2>
<p>La bibliothèque libQGLViewer permet très facilement d'enregistrer un déplacement de caméra, puis de le rejouer. Vous pouvez regarder l'aide de votre application pour voir comment le faire. On peut aussi facilement jouer une animation (voir l'example sur le site). En dérivant de Viewer::animate(), vous pouvez donc placer une routine qui génère un rendu à chaque pas d'animation.</p>
<h2><a class="anchor" id="ig_tp2_5_8"></a>
5.8 Faire un ciel (***)</h2>
<p>On peut utiliser des photos de ciel pour faire un Background plus joli. L'idée est d'utiliser une photo "fish-eye", puis selon la direction du rayon, on renvoie la valeur d'un pixel de la photo.</p>
<div class="image">
<img src="image-Q5-7-sky.png" alt=""/>
<div class="caption">
Image fish-eye de ciel (pas terrible, mais bon...)</div></div>
<p>Il y a malheureusement des petites subtilités dans la transformation (me demander) et il faut aussi faire de l'interpolation linéaire dans l'image. De façon plus générale, on utilise souvent des images de fonds dans les ray-tracer, pour le ciel et pour le sol.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-Q5-7a-small.png" alt=""/>
<div class="caption">
Un ciel nuageux.</div></div>
  </td><td><div class="image">
<img src="image-Q5-7b-small.png" alt=""/>
<div class="caption">
Un ciel nuageux avec building</div></div>
   </td></tr>
</table>
<h1><a class="anchor" id="ig_tp2_6"></a>
6 - Bétisier</h1>
<p>On ne fait pas d'omelettes sans casser des oeufs. Vous allez voir que vous allez avoir des résultats surprenants de rendu. Les erreurs sont aussi formatrices, donc gardez vos meilleures erreurs pour le CR. En voici quelques unes de ma part:</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-Q6-1.png" alt=""/>
<div class="caption">
Mauvais indice de rédraction lorsque le rayon ressort de la bulle (Q4.3).</div></div>
  </td><td><div class="image">
<img src="image-Q6-2.png" alt=""/>
<div class="caption">
Calcul erroné des sources de lumière dans `Renderer::background` (Q3.6)</div></div>
   </td></tr>
<tr>
<td><div class="image">
<img src="image-Q6-3.png" alt=""/>
<div class="caption">
Plan infini raté (Q5.1).</div></div>
  </td><td><div class="image">
<img src="image-Q6-4.png" alt=""/>
<div class="caption">
Une mauvaise combinaison des calcul d'ombrage donne une ombre plus claire qu'une partie éclairée (Q4.1).</div></div>
   </td></tr>
<tr>
<td><div class="image">
<img src="image-Q6-5.png" alt=""/>
<div class="caption">
Pas de prise en compte des coefficiens de réfraction et diffusion dans le calcul des ombres (Q4.1 et Q4.3).</div></div>
   </td></tr>
</table>
<h1><a class="anchor" id="ig_tp2_7"></a>
7 - A rendre</h1>
<p>Vous me remettrez votre TP via <a href="https://tplab.apps.math.cnrs.fr">TPLab</a> à la fin de la séance du mardi 3 mars et la version finale avant le <b>jeudi</b> <b>5</b> <b>mars</b> <b>2026</b> minuit.</p>
<p>L'archive doit contenir:</p><ul>
<li>tous les sources .cpp, en-têtes .h, configuration .pro, et votre exécutable <a class="el" href="ray-tracer_8cpp_source.html">ray-tracer.cpp</a> (éventuellement le fichier .qglviewer pour avoir la position de la caméra),</li>
<li>qmake, puis make doivent créer l'exécutable sans erreur,</li>
<li>un README qui précise toutes les questions traitées (ce qui marche, ce qui ne marche pas),</li>
<li>si vous avez généré de jolis images (et/ou des bêtises), mettez-les sur un site web, et mettez-moi son lien http dans le README,</li>
<li>votre exécutable <a class="el" href="ray-tracer_8cpp_source.html">ray-tracer.cpp</a> doit générer ce que vous pensez être votre plus beau résultat.</li>
<li>une image éventuellement</li>
</ul>
<p>Une partie de la note est liée aux extensions réalisées et à votre créativité graphique. Les plus belles réalisations seront mis en ligne dans le wiki pour les générations futures.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="image-Q7a-small.png" alt=""/>
<div class="caption">
Apparition à l'aube.</div></div>
   </td></tr>
</table>
<p>Pour voir quelques résultats des promotions précédentes, c'est ici : <a class="el" href="ig_tp2_etds.html">Quelques images faites par les étudiants sur le tp ray-tracing</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 12 2026 14:01:38 for INFO804 Introduction à l&#39;informatique graphique by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
