<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INFO702 - TPs: TP2 Traitement d&#39;images en niveaux de gris et couleurs avec généricité (classes patrons, spécialisation, itérateurs).</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INFO702 - TPs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">TP2 Traitement d'images en niveaux de gris et couleurs avec généricité (classes patrons, spécialisation, itérateurs).</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#cpp_tp2_1">1 - Objectifs, pointeurs utiles</a></li>
<li class="level1"><a href="#cpp_tp2_2">2 - Définition d&#39;une classe pour représenter des images arbitraires</a></li>
<li class="level1"><a href="#cpp_tp2_3">3 - Introduction des images couleurs.</a></li>
<li class="level1"><a href="#cpp_tp2_4">4 - Premier itérateur sur images quelconques.</a></li>
<li class="level1"><a href="#cpp_tp2_5">5 - Un importeur / exporteur PBM générique</a></li>
<li class="level1"><a href="#cpp_tp2_6">6 Premier test: on inverse les canaux rouge et bleu</a></li>
<li class="level1"><a href="#cpp_tp2_7">7 On rajoute les accesseurs et un itérateur générique</a></li>
<li class="level1"><a href="#cpp_tp2_8">8 Créer les nouveaux accesseurs à la composante rouge et bleue</a></li>
<li class="level1"><a href="#cpp_tp2_9">9 Itérateurs génériques non constants</a></li>
<li class="level1"><a href="#cpp_tp2_10">10 Espace TSV (HSV) et histogramme d&#39;une image couleur</a></li>
<li class="level1"><a href="#cpp_tp2_11">11 Egalisation d&#39;image couleur</a></li>
<li class="level1"><a href="#cpp_tp2_12">12 Un peu d&#39;imagination</a></li>
<li class="level1"><a href="#cpp_tp2_13">13 TP à rendre</a></li>
</ul>
</div>
<div class="textblock"><p>( Archive images PPM: <a href="https:./images.zip">https:./images.zip</a> )</p>
<h1><a class="anchor" id="cpp_tp2_1"></a>
1 - Objectifs, pointeurs utiles</h1>
<p>L'objectif de ce TP est de vous familiariser avec la programmation générique en C++. A l'issue de cette séance, vous aurez pratiquer:</p>
<ul>
<li>l'écriture de classes génériques via les patrons de classe</li>
<li>la définition de concepts et l'écriture de modèle satisfaisant les concepts</li>
<li>l'écriture de nouveaux itérateurs.</li>
<li>l'écriture de fonctions génériques avec des itérateurs.</li>
</ul>
<p>Le fil conducteur est l'écriture d'une classe générique pour représenter des images 2D quelconques, c'est-à-dire ici des images couleurs (24bits) et des images en niveaux de gris (8bits). Vous développerez un certain nombre de services autour de ces images:</p>
<ul>
<li>création d'image vide</li>
<li>lecture/écriture d'images PGM et PPM (le format le plus simple possible de stockage)</li>
<li>inversion des couleurs.</li>
<li>extraction des composantes rouges, vertes ou bleues.</li>
<li>vision "vieille télé" des images</li>
<li>histogramme(s) de l'image</li>
<li>correction de contraste d'images couleurs et niveaux de gris par égalisation d'histogramme(s)</li>
</ul>
<p>Les sites suivants pourront être utile pendant le TP:</p><ul>
<li>[<a href="http://www.cplusplus.com/">http://www.cplusplus.com/</a> Site C++: tutoriels, références]</li>
<li>[<a href="https://en.cppreference.com/w/">https://en.cppreference.com/w/</a> Site C++: références très complètes]</li>
<li>[<a href="http://www.parashift.com/c++-faq-lite/index.html">http://www.parashift.com/c++-faq-lite/index.html</a> C++ FAQ]</li>
</ul>
<p>Note: Tout bon logiciel de manipulation d'image peut importer ou exporter du portable pixmap (PBM, PGM, PPM). Le logiciel ImageMagick (commandes <code>convert</code> et <code>display</code> notamment) est bien pratique pour convertir en ligne de commande une image:</p>
<pre class="fragment">   prompt&gt; convert toto.jpg toto.ppm
   prompt&gt; display toto.ppm </pre><h1><a class="anchor" id="cpp_tp2_2"></a>
2 - Définition d'une classe pour représenter des images arbitraires</h1>
<p>Nous cherchons à représenter des images dont le type des valeurs peut être défini à l'instanciation. Par exemple, on voudra écrire:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classImage2D.html">Image2D&lt;unsigned char&gt;</a> img_niv_de_gris( 256, 256, 0 );  <span class="comment">// image en niveaux de gris, noire au début</span></div>
<div class="line"><a class="code hl_class" href="classImage2D.html">Image2D&lt;Color&gt;</a> img_couleur( 512, 512, <a class="code hl_struct" href="structColor.html">Color</a>(0,255,0) ); <span class="comment">// image en couleur, verte au début</span></div>
<div class="ttc" id="aclassImage2D_html"><div class="ttname"><a href="classImage2D.html">Image2D</a></div><div class="ttdoc">Classe générique pour représenter des images 2D.</div><div class="ttdef"><b>Definition</b> <a href="Image2D_8hpp_source.html#l00008">Image2D.hpp:8</a></div></div>
<div class="ttc" id="astructColor_html"><div class="ttname"><a href="structColor.html">Color</a></div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00009">Color.hpp:9</a></div></div>
</div><!-- fragment --><p>Nous allons utiliser les patrons de classe avec le type de la valeur de chaque pixel comme paramètre. Comme dans le TP1 (<a class="el" href="cpp_tp1.html">TP1 Traitement d'images en niveaux de gris (POO simple, surcharge d'opérateurs, entrées/sorties).</a>), on utilisera le conteneur <a href="http://www.cplusplus.com/reference/vector/vector/">std::vector</a> pour stocker le tableau de taille W*H, avec W et H la largeur et la hauteur de l'image. Un extrait du fichier entête donne:</p>
<div class="fragment"><div class="line"><span class="comment">// file Image2D.hpp</span></div>
<div class="line"><span class="preprocessor">#ifndef _IMAGE2D_HPP_</span></div>
<div class="line"><span class="preprocessor">#define _IMAGE2D_HPP_</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// Classe générique pour représenter des images 2D.</span></div>
<div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TValue&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classImage2D.html">Image2D</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classImage2D.html">Image2D&lt;TValue&gt;</a>    Self;      <span class="comment">// le type de *this</span></div>
<div class="line">  <span class="keyword">typedef</span> TValue             Value;     <span class="comment">// le type pour la valeur des pixels</span></div>
<div class="line">  <span class="keyword">typedef</span> std::vector&lt;Value&gt; Container; <span class="comment">// le type pour stocker les valeurs des pixels de l&#39;image.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constructeur par défaut</span></div>
<div class="line">  <a class="code hl_class" href="classImage2D.html">Image2D</a>();</div>
<div class="line">  <span class="comment">// Constructeur avec taille w x h. Remplit tout avec la valeur g</span></div>
<div class="line">  <span class="comment">// (par défaut celle donnée par le constructeur par défaut).</span></div>
<div class="line">  <a class="code hl_class" href="classImage2D.html">Image2D</a>( <span class="keywordtype">int</span> <a class="code hl_function" href="classImage2D.html#aff8813c066adc87fb9fe93f3d72926a8">w</a>, <span class="keywordtype">int</span> <a class="code hl_function" href="classImage2D.html#a6d09f340df0f5e4f15b1827253114d4c">h</a>, Value g = Value() );</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Remplit l&#39;image avec la valeur \a g.</span></div>
<div class="line">  <span class="keywordtype">void</span> fill( Value g );</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// @return la largeur de l&#39;image.</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">int</span> <a class="code hl_function" href="classImage2D.html#aff8813c066adc87fb9fe93f3d72926a8">w</a>() <span class="keyword">const</span>;<span class="comment"></span></div>
<div class="line"><span class="comment">  /// @return la hauteur de l&#39;image.</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">int</span> <a class="code hl_function" href="classImage2D.html#a6d09f340df0f5e4f15b1827253114d4c">h</a>() <span class="keyword">const</span>;</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Accesseur read-only à la valeur d&#39;un pixel.</span></div>
<div class="line"><span class="comment">  /// @return la valeur du pixel(i,j)</span></div>
<div class="line"><span class="comment"></span>  Value <a class="code hl_function" href="classImage2D.html#aaca38f7c267caf66ca12d882848d74b1">at</a>( <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j ) <span class="keyword">const</span>;</div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// Accesseur read-write à la valeur d&#39;un pixel.</span></div>
<div class="line"><span class="comment">  /// @return une référence à la valeur du pixel(i,j)</span></div>
<div class="line"><span class="comment"></span>  Value&amp; <a class="code hl_function" href="classImage2D.html#aaca38f7c267caf66ca12d882848d74b1">at</a>( <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j );</div>
<div class="line">  </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  Container m_data; <span class="comment">// mes données; évitera de faire les allocations dynamiques</span></div>
<div class="line">  <span class="keywordtype">int</span> m_width; <span class="comment">// ma largeur</span></div>
<div class="line">  <span class="keywordtype">int</span> m_height; <span class="comment">// ma hauteur</span></div>
<div class="line">  <span class="comment"></span></div>
<div class="line"><span class="comment">  /// @return l&#39;index du pixel (x,y) dans le tableau \red m_data.</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">int</span> index( <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j ) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// _IMAGE2D_HPP_</span></div>
<div class="ttc" id="aclassImage2D_html_a6d09f340df0f5e4f15b1827253114d4c"><div class="ttname"><a href="classImage2D.html#a6d09f340df0f5e4f15b1827253114d4c">Image2D::h</a></div><div class="ttdeci">int h() const</div></div>
<div class="ttc" id="aclassImage2D_html_aaca38f7c267caf66ca12d882848d74b1"><div class="ttname"><a href="classImage2D.html#aaca38f7c267caf66ca12d882848d74b1">Image2D::at</a></div><div class="ttdeci">Value at(int i, int j) const</div></div>
<div class="ttc" id="aclassImage2D_html_aff8813c066adc87fb9fe93f3d72926a8"><div class="ttname"><a href="classImage2D.html#aff8813c066adc87fb9fe93f3d72926a8">Image2D::w</a></div><div class="ttdeci">int w() const</div></div>
</div><!-- fragment --><p>On utilisera la classe <a href="http://www.cplusplus.com/reference/vector/vector/">std::vector</a> de la STL. Cela nous évitera toute allocation dynamique ! Il suffit soit de l'initialiser avec la bonne taille (i.e. donc <code>largeur * hauteur</code>), soit d'appeler <code>vector::resize</code> pour changer la taille. Ecrivez donc cette première version de la classe <a class="el" href="classImage2D.html" title="Classe générique pour représenter des images 2D.">Image2D</a>, avec les deux constructeurs précisés. Faut-il réécrire le constructeur par copie et l'affectation ?</p>
<dl class="section note"><dt>Note</dt><dd>Faites des copier/coller avec votre classe <a class="el" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> du TP précédent.</dd>
<dd>
les méthodes seront aussi écrites dans le fichier entête <a class="el" href="Image2D_8hpp_source.html">Image2D.hpp</a>, soit directement, soit après la définition de la classe. Par exemple, on pourra écrire: <div class="fragment"><div class="line"><span class="keywordtype">int</span> w()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_width; }</div>
</div><!-- fragment --></dd></dl>
<p>On testera les méthodes précédents en créant un fichier <code>testGrayLevelImage2D.cpp</code> avec (au moins) les lignes suivantes.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Image2D.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> GrayLevel;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classImage2D.html">Image2D&lt;GrayLevel&gt;</a> <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>;</div>
<div class="line">  <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> img( 8, 8, 5 ); <span class="comment">// imagette 8x8 remplie de 5</span></div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> y = 0; y &lt; img.h(); ++y )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> x = 0; x &lt; img.w(); ++x )</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; (<span class="keywordtype">int</span>) img.at( x, y ); <span class="comment">// la conversion permet de voir les caractères sous forme d&#39;entiers.</span></div>
<div class="line">      std::cout &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassGrayLevelImage2D_html"><div class="ttname"><a href="classGrayLevelImage2D.html">GrayLevelImage2D</a></div><div class="ttdef"><b>Definition</b> <a href="GrayLevelImage2D_8hpp_source.html#l00009">GrayLevelImage2D.hpp:9</a></div></div>
</div><!-- fragment --><p>Vous pourrez utiliser le <code>Makefile</code> suivant:</p>
<pre class="fragment">LD=g++
CXX=g++ -g -c

EXEC_SRC=\
	testGrayLevelImage2D.cpp

MODULE_SRC=\

MODULE_OBJ=${MODULE_SRC:.cpp=.o}
EXEC_OBJ=${EXEC_SRC:.cpp=.o}

EXEC_PRG=${EXEC_SRC:.cpp=}

all: ${EXEC_PRG} ${MODULE_OBJ} ${EXEC_OBJ}

testGrayLevelImage2D: testGrayLevelImage2D.o ${MODULE_OBJ}
	${LD} ${MODULE_OBJ} $&lt; -o $@

.cpp.o: 
	${CXX} $&lt;

clean:
	rm -f ${EXEC_PRG} ${MODULE_OBJ} ${EXEC_OBJ}

</pre><p>Il vous suffira alors à vous de taper la commande <code>make</code> dans votre terminal pour que tout soit compilé. L'exécution affiche</p>
<pre class="fragment">   5 5 5 5 5 5 5 5 
   5 5 5 5 5 5 5 5 
   5 5 5 5 5 5 5 5 
   5 5 5 5 5 5 5 5 
   5 5 5 5 5 5 5 5 
   5 5 5 5 5 5 5 5 
   5 5 5 5 5 5 5 5 
   5 5 5 5 5 5 5 5</pre><p>En un sens, vous avez transformé votre classe non générique <a class="el" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> en une classe générique <a class="el" href="classImage2D.html" title="Classe générique pour représenter des images 2D.">Image2D</a>, puis vous avez paramétré <a class="el" href="classImage2D.html" title="Classe générique pour représenter des images 2D.">Image2D</a> de manière à représenter des images en niveaux de gris. Pour le moment, vous devez avoir l'impression d'avoir fait du boulot pour pas grand chose. C'est normal, mais ça va s'arranger.</p>
<h1><a class="anchor" id="cpp_tp2_3"></a>
3 - Introduction des images couleurs.</h1>
<p>On va instancier une image couleur. Pour ce faire, il faut avoir une classe qui représente une couleur. C'est la classe <a class="el" href="structColor.html">Color</a> (fichier <a class="el" href="Color_8hpp_source.html">Color.hpp</a>) donnée ci-dessous.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef _COLOR_HPP_</span></div>
<div class="line"><span class="preprocessor">#define _COLOR_HPP_</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment">   Représente une couleur avec un codage RGB. Ce codage utilise 3</span></div>
<div class="line"><span class="comment">   octets, le premier octet code l&#39;intensité du rouge, le deuxième</span></div>
<div class="line"><span class="comment">   l&#39;intensité du vert, le troisième l&#39;intensité du bleu.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structColor.html">Color</a> {</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Byte;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Code les 3 canaux RGB sur 3 octets.</span></div>
<div class="line"><span class="comment"></span>  Byte <a class="code hl_variable" href="structColor.html#af84e8322aff195c692b0e5cf9ed01fe1">red</a>, green, blue;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structColor.html">Color</a>() {}<span class="comment"></span></div>
<div class="line"><span class="comment">  /// Crée la couleur spécifiée par (_red,_green,_blue).</span></div>
<div class="line"><span class="comment"></span>  <a class="code hl_struct" href="structColor.html">Color</a>( Byte _red, Byte _green, Byte _blue )</div>
<div class="line">    : <a class="code hl_variable" href="structColor.html#af84e8322aff195c692b0e5cf9ed01fe1">red</a>( _red ), green( _green ), blue( _blue ) {}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// @return l&#39;intensité de rouge (entre 0.0 et 1.0)</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">float</span> <a class="code hl_function" href="structColor.html#acf37af858b317db5b9295b0fb4d6cc51">r</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ( (<span class="keywordtype">float</span>) <a class="code hl_variable" href="structColor.html#af84e8322aff195c692b0e5cf9ed01fe1">red</a> ) / 255.0; }<span class="comment"></span></div>
<div class="line"><span class="comment">  /// @return l&#39;intensité de vert (entre 0.0 et 1.0)</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">float</span> <a class="code hl_function" href="structColor.html#a09a7c4d10a387bf59823d52eb0bc0173">g</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ( (<span class="keywordtype">float</span>) green ) / 255.0; }<span class="comment"></span></div>
<div class="line"><span class="comment">  /// @return l&#39;intensité de bleu (entre 0.0 et 1.0)</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">float</span> <a class="code hl_function" href="structColor.html#a1d70a9e2386aa5d25cac60c9201b6269">b</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ( (<span class="keywordtype">float</span>) blue ) / 255.0; }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Sert à désigner un canal.</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">enum</span> <a class="code hl_enumeration" href="structColor.html#a3448cb532aae0ec54346036251d2e8db">Channel</a> { Red, Green, Blue };<span class="comment"></span></div>
<div class="line"><span class="comment">  /// @return le canal le plus intense.</span></div>
<div class="line"><span class="comment"></span>  <a class="code hl_enumeration" href="structColor.html#a3448cb532aae0ec54346036251d2e8db">Channel</a> <a class="code hl_function" href="structColor.html#a599f81b59dd9f1b3a1b2aac0476cab31">argmax</a>()<span class="keyword"> const </span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">if</span> ( <a class="code hl_variable" href="structColor.html#af84e8322aff195c692b0e5cf9ed01fe1">red</a> &gt;= green ) <span class="keywordflow">return</span> <a class="code hl_variable" href="structColor.html#af84e8322aff195c692b0e5cf9ed01fe1">red</a> &gt;= blue ? Red : Blue;</div>
<div class="line">    <span class="keywordflow">else</span>                <span class="keywordflow">return</span> green &gt;= blue ? Green : Blue;</div>
<div class="line">  }<span class="comment"></span></div>
<div class="line"><span class="comment">  /// @return l&#39;intensité maximale des canaux</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">float</span> <a class="code hl_function" href="structColor.html#a34675116a2b47a2fa653f80a348742db">max</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::max( std::max( <a class="code hl_function" href="structColor.html#acf37af858b317db5b9295b0fb4d6cc51">r</a>(), <a class="code hl_function" href="structColor.html#a09a7c4d10a387bf59823d52eb0bc0173">g</a>() ), <a class="code hl_function" href="structColor.html#a1d70a9e2386aa5d25cac60c9201b6269">b</a>() ); }<span class="comment"></span></div>
<div class="line"><span class="comment">  /// @return l&#39;intensité minimale des canaux</span></div>
<div class="line"><span class="comment"></span>  <span class="keywordtype">float</span> <a class="code hl_function" href="structColor.html#aee2b1830c034579b09e21d72d7ca8016">min</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::min( std::min( <a class="code hl_function" href="structColor.html#acf37af858b317db5b9295b0fb4d6cc51">r</a>(), <a class="code hl_function" href="structColor.html#a09a7c4d10a387bf59823d52eb0bc0173">g</a>() ), <a class="code hl_function" href="structColor.html#a1d70a9e2386aa5d25cac60c9201b6269">b</a>() ); }<span class="comment"></span></div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">     Convertit la couleur RGB en le modèle HSV (TSV en français).</span></div>
<div class="line"><span class="comment">     @param h la teinte de la couleur (entre 0 et 359), hue en anglais.</span></div>
<div class="line"><span class="comment">     @param s la saturation de la couleur (entre 0.0 et 1.0)</span></div>
<div class="line"><span class="comment">     @param v la valeur ou brillance de la couleur (entre 0.0 et 1.0).</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="structColor.html#ae36aabe5c53a92dee8c49044b70dd91d">getHSV</a>( <span class="keywordtype">int</span> &amp; h, <span class="keywordtype">float</span> &amp; s, <span class="keywordtype">float</span> &amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="comment">// Taking care of hue</span></div>
<div class="line">    <span class="keywordflow">if</span> ( <a class="code hl_function" href="structColor.html#a34675116a2b47a2fa653f80a348742db">max</a>() == <a class="code hl_function" href="structColor.html#aee2b1830c034579b09e21d72d7ca8016">min</a>() ) h = 0;</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">switch</span> ( <a class="code hl_function" href="structColor.html#a599f81b59dd9f1b3a1b2aac0476cab31">argmax</a>() ) {</div>
<div class="line">      <span class="keywordflow">case</span> Red:   h = ( (int) ( 60.0 * ( <a class="code hl_function" href="structColor.html#a09a7c4d10a387bf59823d52eb0bc0173">g</a>() - <a class="code hl_function" href="structColor.html#a1d70a9e2386aa5d25cac60c9201b6269">b</a>() ) / ( <a class="code hl_function" href="structColor.html#a34675116a2b47a2fa653f80a348742db">max</a>() - <a class="code hl_function" href="structColor.html#aee2b1830c034579b09e21d72d7ca8016">min</a>() ) + 360.0 ) ) % 360;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> Green: h = ( (int) ( 60.0 * ( <a class="code hl_function" href="structColor.html#a1d70a9e2386aa5d25cac60c9201b6269">b</a>() - <a class="code hl_function" href="structColor.html#acf37af858b317db5b9295b0fb4d6cc51">r</a>() ) / ( <a class="code hl_function" href="structColor.html#a34675116a2b47a2fa653f80a348742db">max</a>() - <a class="code hl_function" href="structColor.html#aee2b1830c034579b09e21d72d7ca8016">min</a>() ) + 120.0 ) );</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> Blue:  h = ( (int) ( 60.0 * ( <a class="code hl_function" href="structColor.html#acf37af858b317db5b9295b0fb4d6cc51">r</a>() - <a class="code hl_function" href="structColor.html#a09a7c4d10a387bf59823d52eb0bc0173">g</a>() ) / ( <a class="code hl_function" href="structColor.html#a34675116a2b47a2fa653f80a348742db">max</a>() - <a class="code hl_function" href="structColor.html#aee2b1830c034579b09e21d72d7ca8016">min</a>() ) + 240.0 ) );</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Taking care of saturation</span></div>
<div class="line">    s = <a class="code hl_function" href="structColor.html#a34675116a2b47a2fa653f80a348742db">max</a>() == 0.0 ? 0.0 : 1.0 - <a class="code hl_function" href="structColor.html#aee2b1830c034579b09e21d72d7ca8016">min</a>() / <a class="code hl_function" href="structColor.html#a34675116a2b47a2fa653f80a348742db">max</a>();</div>
<div class="line">    <span class="comment">// Taking care of value</span></div>
<div class="line">    v = <a class="code hl_function" href="structColor.html#a34675116a2b47a2fa653f80a348742db">max</a>();</div>
<div class="line">  }<span class="comment"></span></div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">     TODO: Convertit la couleur donnée avec le modèle HSV (TSV en</span></div>
<div class="line"><span class="comment">     français) en une couleur RGB.</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="structColor.html#ae134ffc8127610be421018c041e1bff5">setHSV</a>( <span class="keywordtype">int</span> h, <span class="keywordtype">float</span> s, <span class="keywordtype">float</span> v )</div>
<div class="line">  {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">//_COLOR_HPP_</span></div>
<div class="ttc" id="astructColor_html_a09a7c4d10a387bf59823d52eb0bc0173"><div class="ttname"><a href="structColor.html#a09a7c4d10a387bf59823d52eb0bc0173">Color::g</a></div><div class="ttdeci">float g() const</div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00023">Color.hpp:23</a></div></div>
<div class="ttc" id="astructColor_html_a1d70a9e2386aa5d25cac60c9201b6269"><div class="ttname"><a href="structColor.html#a1d70a9e2386aa5d25cac60c9201b6269">Color::b</a></div><div class="ttdeci">float b() const</div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00025">Color.hpp:25</a></div></div>
<div class="ttc" id="astructColor_html_a3448cb532aae0ec54346036251d2e8db"><div class="ttname"><a href="structColor.html#a3448cb532aae0ec54346036251d2e8db">Color::Channel</a></div><div class="ttdeci">Channel</div><div class="ttdoc">Sert à désigner un canal.</div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00028">Color.hpp:28</a></div></div>
<div class="ttc" id="astructColor_html_a34675116a2b47a2fa653f80a348742db"><div class="ttname"><a href="structColor.html#a34675116a2b47a2fa653f80a348742db">Color::max</a></div><div class="ttdeci">float max() const</div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00036">Color.hpp:36</a></div></div>
<div class="ttc" id="astructColor_html_a599f81b59dd9f1b3a1b2aac0476cab31"><div class="ttname"><a href="structColor.html#a599f81b59dd9f1b3a1b2aac0476cab31">Color::argmax</a></div><div class="ttdeci">Channel argmax() const</div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00030">Color.hpp:30</a></div></div>
<div class="ttc" id="astructColor_html_acf37af858b317db5b9295b0fb4d6cc51"><div class="ttname"><a href="structColor.html#acf37af858b317db5b9295b0fb4d6cc51">Color::r</a></div><div class="ttdeci">float r() const</div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00021">Color.hpp:21</a></div></div>
<div class="ttc" id="astructColor_html_ae134ffc8127610be421018c041e1bff5"><div class="ttname"><a href="structColor.html#ae134ffc8127610be421018c041e1bff5">Color::setHSV</a></div><div class="ttdeci">void setHSV(int h, float s, float v)</div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00068">Color.hpp:68</a></div></div>
<div class="ttc" id="astructColor_html_ae36aabe5c53a92dee8c49044b70dd91d"><div class="ttname"><a href="structColor.html#ae36aabe5c53a92dee8c49044b70dd91d">Color::getHSV</a></div><div class="ttdeci">void getHSV(int &amp;h, float &amp;s, float &amp;v) const</div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00045">Color.hpp:45</a></div></div>
<div class="ttc" id="astructColor_html_aee2b1830c034579b09e21d72d7ca8016"><div class="ttname"><a href="structColor.html#aee2b1830c034579b09e21d72d7ca8016">Color::min</a></div><div class="ttdeci">float min() const</div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00038">Color.hpp:38</a></div></div>
<div class="ttc" id="astructColor_html_af84e8322aff195c692b0e5cf9ed01fe1"><div class="ttname"><a href="structColor.html#af84e8322aff195c692b0e5cf9ed01fe1">Color::red</a></div><div class="ttdeci">Byte red</div><div class="ttdoc">Code les 3 canaux RGB sur 3 octets.</div><div class="ttdef"><b>Definition</b> <a href="Color_8hpp_source.html#l00013">Color.hpp:13</a></div></div>
</div><!-- fragment --><p>Ecrivez un petit programme de test <code>testColorImage2D.cpp</code> sur le modèle de <code>testGrayLevelImage2D.cpp</code> afin de tester l'instanciation d'une image couleur sous la forme</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Color.hpp&quot;</span></div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classImage2D.html">Image2D&lt;Color&gt;</a> ColorImage2D;</div>
<div class="line">ColorImage2D img( 8, 8, <a class="code hl_struct" href="structColor.html">Color</a>( 255, 0, 255 ) ); <span class="comment">// imagette 8x8 remplie de magenta</span></div>
<div class="line"><span class="comment">//...</span></div>
</div><!-- fragment --><h1><a class="anchor" id="cpp_tp2_4"></a>
4 - Premier itérateur sur images quelconques.</h1>
<p>On repart du modèle des itérateurs que l'on avait fait au TP1, c'est-à-dire qu'on va définir un itérateur dans une image comme une classe dérivée d'un itérateur sur un <code>std::vector</code>. Cela donne ce genre de code:</p>
<div class="fragment"><div class="line"><span class="comment">/// Un itérateur (non-constant) simple sur l&#39;image.</span></div>
<div class="line"><span class="keyword">struct </span>Iterator : <span class="keyword">public</span> Container::iterator {</div>
<div class="line">  Iterator( Self &amp; image, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y ) </div>
<div class="line">    : Container::iterator( image.m_data.begin() + image.index( x, y ) )</div>
<div class="line">  {}</div>
<div class="line">};</div>
</div><!-- fragment --><p>On rajoute aussi les méthodes usuelles <code>begin</code>, <code>end</code>, <code>start</code>.</p>
<div class="fragment"><div class="line"><span class="comment">/// @return un itérateur pointant sur le début de l&#39;image</span></div>
<div class="line">Iterator begin() { <span class="keywordflow">return</span> start( 0, 0 ); }<span class="comment"></span></div>
<div class="line"><span class="comment">/// @return un itérateur pointant après la fin de l&#39;image</span></div>
<div class="line"><span class="comment"></span>Iterator end()   { <span class="keywordflow">return</span> start( 0, h() ); }<span class="comment"></span></div>
<div class="line"><span class="comment">/// @return un itérateur pointant sur le pixel (x,y).</span></div>
<div class="line"><span class="comment"></span>Iterator start( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y ) { <span class="keywordflow">return</span> Iterator( *<span class="keyword">this</span>, x, y ); }</div>
</div><!-- fragment --><p>Maintenant le code suivant vous génère une image avec pleins de couleurs et l'exporte en PPM.</p>
<div class="fragment"><div class="line"><span class="comment">// file testColorImage2D.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Image2D.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Color.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classImage2D.html">Image2D&lt;Color&gt;</a> ColorImage2D;</div>
<div class="line">  <span class="keyword">typedef</span> ColorImage2D::Iterator Iterator;</div>
<div class="line">  ColorImage2D img( 256, 256, <a class="code hl_struct" href="structColor.html">Color</a>( 0, 0, 0 ) );</div>
<div class="line">  Iterator it = img.begin();</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> y = 0; y &lt; 256; ++y )</div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> x = 0; x &lt; 256; ++x )</div>
<div class="line">      {</div>
<div class="line">        *it++ = <a class="code hl_struct" href="structColor.html">Color</a>( y, x, (2*x+2*y) % 256 );</div>
<div class="line">      }</div>
<div class="line">  <span class="comment">// ios::binary est nécessaire pour les systèmes Windows, optionnel</span></div>
<div class="line">  <span class="comment">// sur les autres systèmes.</span></div>
<div class="line">  std::ofstream output( <span class="stringliteral">&quot;colors.ppm&quot;</span>, ios::binary ); </div>
<div class="line">  output &lt;&lt; <span class="stringliteral">&quot;P6&quot;</span> &lt;&lt; std::endl; <span class="comment">// PPM raw</span></div>
<div class="line">  output &lt;&lt; <span class="stringliteral">&quot;# Generated by You !&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  output &lt;&lt; img.w() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; img.h() &lt;&lt; std::endl;</div>
<div class="line">  output &lt;&lt; <span class="stringliteral">&quot;255&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span> ( Iterator it = img.begin(), itE = img.end(); it != itE; ++it ) <span class="comment">// (*)</span></div>
<div class="line">    { </div>
<div class="line">      <a class="code hl_struct" href="structColor.html">Color</a> c = *it;</div>
<div class="line">      <span class="comment">// c.red, c.green et c.blue sont des `unsigned char`, donc la ligne ci-dessous</span></div>
<div class="line">      <span class="comment">// écrit 3 octets sur le flux de sortie `output`.</span></div>
<div class="line">      output &lt;&lt; c.<a class="code hl_variable" href="structColor.html#af84e8322aff195c692b0e5cf9ed01fe1">red</a> &lt;&lt; c.green &lt;&lt; c.blue;</div>
<div class="line">    }</div>
<div class="line">  output.close();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
</div><!-- fragment --><p>qui doit vous afficher:</p>
<div class="image">
<img src="colors.png" alt=""/>
<div class="caption">
Votre première image couleur.</div></div>
<p>Ecrivez ensuite une version <code>const</code> de la classe Image2D::Iterator. Vous appelerez cette classe <code>Image2D::ConstIterator</code> et vous écrirez alors les versions <code>const</code> des méthodes <code>begin</code>, <code>end</code>, <code>start</code>.</p>
<dl class="section note"><dt>Note</dt><dd>La classe Image2D::ConstIterator dérive de <code>Container::const_iterator</code> (donc des itérateurs non mutables de la classe <code>vector&lt;T&gt;</code>).</dd></dl>
<p>Notez maintenant que la boucle <code></code>(*) du programme précédent peut être réécrite avec <code>ConstIterator</code> sous la forme suivante:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ColorImage2D&amp; cimg = img; <span class="comment">// Vue &quot;constante&quot; sur l&#39;image img.</span></div>
<div class="line"><span class="keywordflow">for</span> ( ConstIterator it = cimg.begin(), itE = cimg.end(); it != itE; ++it ) <span class="comment">// (*)</span></div>
<div class="line">  { </div>
<div class="line">    <a class="code hl_struct" href="structColor.html">Color</a> c = *it;</div>
<div class="line">    output &lt;&lt; c.<a class="code hl_variable" href="structColor.html#af84e8322aff195c692b0e5cf9ed01fe1">red</a> &lt;&lt; c.green &lt;&lt; c.blue;</div>
<div class="line">  }</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>A partir de C++11, on écrirait aussi les méthodes <code>cbegin()</code> et <code>cend()</code> (et <code>cstart</code> ici) pour récupérer un const-itérateur, que l'on utiliserait si l'on veut forcer leur usage.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 2eme façon (plus C++11)</span></div>
<div class="line"><span class="keywordflow">for</span> ( ConstIterator it = img.cbegin(), itE = img.cend(); it != itE; ++it ) <span class="comment">// (*)</span></div>
<div class="line"> { </div>
<div class="line">   <a class="code hl_struct" href="structColor.html">Color</a> c = *it;</div>
<div class="line">   output &lt;&lt; c.<a class="code hl_variable" href="structColor.html#af84e8322aff195c692b0e5cf9ed01fe1">red</a> &lt;&lt; c.green &lt;&lt; c.blue;</div>
<div class="line"> }</div>
<div class="line"> <span class="comment">// 3eme façon avec (:)</span></div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">const</span> <span class="keyword">auto</span> c : img )</div>
<div class="line">{</div>
<div class="line">   output &lt;&lt; c.red &lt;&lt; c.green &lt;&lt; c.blue;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="cpp_tp2_5"></a>
5 - Un importeur / exporteur PBM générique</h1>
<p>Il est clair qu'on ne peut pas écrire le même code pour lire/écrire du PGM (image niveaux de gris) ou du PPM (image couleur). Cela va <em>a</em> <em>priori</em> à l'encontre de la généricité de <a class="el" href="classImage2D.html" title="Classe générique pour représenter des images 2D.">Image2D</a>. Ce n'est pas un problème ici, on va juste utiliser la spécialisation des classes. Comme on ne veut pas spécialiser tout <a class="el" href="classImage2D.html" title="Classe générique pour représenter des images 2D.">Image2D</a>, on va plutôt créer des classes à part pour importer ou exporter les images. Par exemple, pour exporter/sauvegarder une image, on définit une classe et ses spécialisations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TValue&gt; <span class="keyword">struct </span>Image2DWriter { ... };</div>
<div class="line"><span class="comment">// spécialisée ensuite</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>Image2DWriter&lt;unsigned char&gt; { ... }; <span class="comment">// PGM</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>Image2DWriter&lt;<a class="code hl_struct" href="structColor.html">Color</a>&gt; { ... };         <span class="comment">// PPM</span></div>
</div><!-- fragment --><p>Plus précisément, complétez le code suivant</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef _IMAGE2DWRITER_HPP_</span></div>
<div class="line"><span class="preprocessor">#define _IMAGE2DWRITER_HPP_</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Color.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Image2D.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TValue&gt;</div>
<div class="line"><span class="keyword">class </span>Image2DWriter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> TValue Value;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classImage2D.html">Image2D&lt;Value&gt;</a> Image;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> write( <span class="keyword">const</span> Image &amp; img, std::ostream &amp; output, <span class="keywordtype">bool</span> ascii )</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;[Image2DWriter&lt;TValue&gt;::write] NOT IMPLEMENTED.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// Specialization for gray-level images.</span></div>
<div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">class </span>Image2DWriter&lt;unsigned char&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Value;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classImage2D.html">Image2D&lt;Value&gt;</a> Image;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> write( <span class="keyword">const</span> Image &amp; img, std::ostream &amp; output, <span class="keywordtype">bool</span> ascii )</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Reprenez votre code du TP1.</span></div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// Specialization for color images.</span></div>
<div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">class </span>Image2DWriter&lt;<a class="code hl_struct" href="structColor.html">Color</a>&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structColor.html">Color</a> Value;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classImage2D.html">Image2D&lt;Value&gt;</a> Image;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> write( <span class="keyword">const</span> Image &amp; img, std::ostream &amp; output, <span class="keywordtype">bool</span> ascii )</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Reprenez la partie sauvegarde de l&#39;exemple précédent testColorImage2D.cpp</span></div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// _IMAGE2DWRITER_HPP_</span></div>
</div><!-- fragment --><p>Maintenant, dans l'exemple testColorImage2D.cpp, vous pouvez sauvegarder l'image couleur <code>"colors.ppm"</code> ainsi:</p>
<div class="fragment"><div class="line">ofstream output( <span class="stringliteral">&quot;colors.ppm&quot;</span> );</div>
<div class="line"><span class="keywordtype">bool</span> ok2 = Image2DWriter&lt;Color&gt;::write( img, output, <span class="keyword">false</span> );</div>
<div class="line"><span class="keywordflow">if</span> ( !ok2 ) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error writing output file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line">output.close();</div>
</div><!-- fragment --><p>Il ne vous reste plus qu'à écrire la classe <code>Image2DReader</code> pour lire/importer une image en niveaux de gris ou une image couleur. On procède exactement de la même manière.</p>
<dl class="section warning"><dt>Warning</dt><dd>Attention, il faut passer l'image en référence dans <code>static bool Image2DReader&lt;TValue&gt;::read(Image &amp; img, std::istream &amp; input )</code>, i.e. non const, car vous allez modifier cette image dans cette méthode de classe.</dd></dl>
<h1><a class="anchor" id="cpp_tp2_6"></a>
6 Premier test: on inverse les canaux rouge et bleu</h1>
<p>Comme on peut lire/écrire des images PPM, on peut maintenant faire du traitement d'image. Ecrivez un petit programme <code>invert-red-blue.cpp</code> en ligne de commande qui inverse les canaux rouge et bleu d'une image donnée en paramètre, puis sauve le résultat. On l'appelerait ainsi:</p>
<pre class="fragment">prompt$ g++ invert-red-blue.cpp -o invert-red-blue
prompt$ ./invert-red-blue kowloon.ppm kowloon-inv.ppm
</pre><p>L'idée est de parcourir l'image par pixel par pixel, et d'inverser les canaux rouge et bleu de chaque pixel. Cela donne:</p>
<table class="doxtable">
<tr>
<td><img src="./kowloon.png" alt="" width="500" height="328" class="inline"/>  </td><td><img src="./kowloon-inv-red-blue.png" alt="" width="500" height="328" class="inline"/>   </td></tr>
<tr>
<td>kowloon.ppm </td><td>kowloon-inv.ppm   </td></tr>
</table>
<p>On note ici que la généricité n'est pas essentielle, elle a juste permis de factoriser le code pour représenter les images en niveaux de gris et couleur.</p>
<h1><a class="anchor" id="cpp_tp2_7"></a>
7 On rajoute les accesseurs et un itérateur générique</h1>
<p>Il est délicat de manipuler les images couleur de la même façon que les images en niveaux de gris, car l'information couleur a plus de degrés de liberté que l'information niveaux de gris. Pourtant, on peut aussi "linéariser" la couleur (i.e. la voir comme un axe) de différentes façons:</p>
<ul>
<li>on ne regarde qu'une composante (rouge, vert, bleu). Dans ce cas, la composante concernée est une sorte d'image en niveaux de gris</li>
<li>on ne regarde que la valeur de la couleur dans le modèle TSV de couleur. Dans ce cas là, on ne regarde que la brillance de la couleur, pas sa teinte.</li>
<li>on pourrait regarder d'autres modèles de couleur et ne garder qu'un seul axe.</li>
</ul>
<p>Or, nos itérateurs (<code>ConstIterator</code> et <code>Iterator</code>) sont un peu simplets. Leur valeur pointée est toujours une couleur. On va définir des itérateurs <b>sélectifs</b> qui ne voient qu'une composante de la couleur (en lecture et en écriture). Plutôt que de les réécrire à chaque fois, on définit la notion d'accesseur, puis nos nouveaux itérateurs seront paramétrés par un accesseur.</p>
<p>Dans ce TP, nos accesseurs n'auront même pas besoin d'instance pour fonctionner (e.g., sélectionner le canal rouge ne nécessite pas d'information propre). Leur méthodes <code>access</code> seront donc des méthodes de classe (mot-clé <code>static</code>) et non d'instance. Voilà ci-dessous deux exemples d'accesseur:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef _ACCESSOR_HPP_</span></div>
<div class="line"><span class="preprocessor">#define _ACCESSOR_HPP_</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;Color.hpp&quot;</span><span class="comment"></span></div>
<div class="line"><span class="comment">/// Accesseur trivial générique</span></div>
<div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TValue&gt;</div>
<div class="line"><span class="keyword">struct </span>TrivialAccessor {</div>
<div class="line">  <span class="keyword">typedef</span> TValue Value;</div>
<div class="line">  <span class="keyword">typedef</span> Value Argument;</div>
<div class="line">  <span class="keyword">typedef</span> Value&amp; Reference;</div>
<div class="line">  <span class="comment">// Acces en lecture.</span></div>
<div class="line">  <span class="keyword">static</span> Value access( <span class="keyword">const</span> Argument &amp; arg ) </div>
<div class="line">  { <span class="keywordflow">return</span> arg; }</div>
<div class="line">  <span class="comment">// Acces en écriture.</span></div>
<div class="line">  <span class="keyword">static</span> Reference access( Argument &amp; arg ) </div>
<div class="line">  { <span class="keywordflow">return</span> arg; }</div>
<div class="line">};</div>
<div class="line">   </div>
<div class="line"><span class="comment">// Accesseur trivial pour une image en niveaux de gris</span></div>
<div class="line"><span class="keyword">typedef</span> TrivialAccessor&lt;unsigned char&gt; GrayLevelTrivialAccessor; </div>
<div class="line"><span class="comment">// Accesseur trivial pour une image en couleur.</span></div>
<div class="line"><span class="keyword">typedef</span> TrivialAccessor&lt;Color&gt; ColorTrivialAccessor; </div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/// Accesseur à la composante verte.</span></div>
<div class="line"><span class="comment"></span><span class="keyword">struct </span>ColorGreenAccessor {</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Value;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structColor.html">Color</a> Argument;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">  /// Même astuce que pour les références à un bit dans un tableau de bool.</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">struct </span>ColorGreenReference {</div>
<div class="line">    Argument &amp; arg;</div>
<div class="line">    ColorGreenReference( Argument &amp; someArg ) : arg( someArg ) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accesseur lvalue (écriture)</span></div>
<div class="line">    <span class="comment">// permet d&#39;écrire *it = 120 pour changer l&#39;intensité du vert</span></div>
<div class="line">    ColorGreenReference&amp; operator=( Value val )</div>
<div class="line">    {</div>
<div class="line">      arg.green = val;</div>
<div class="line">      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accesseur rvalue (lecture)</span></div>
<div class="line">    <span class="comment">// permet d&#39;écrire *it pour récupérer l&#39;intensité du vert</span></div>
<div class="line">    <span class="keyword">operator</span> Value()<span class="keyword"> const </span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> arg.green;  <span class="comment">// arg.green est de type Value.</span></div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">typedef</span> ColorGreenReference Reference;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Acces en lecture.</span></div>
<div class="line">  <span class="keyword">static</span> Value access( <span class="keyword">const</span> Argument &amp; arg ) </div>
<div class="line">  { <span class="keywordflow">return</span> arg.green; }</div>
<div class="line">  <span class="comment">// Acces en écriture.</span></div>
<div class="line">  <span class="keyword">static</span> Reference access( Argument &amp; arg ) </div>
<div class="line">  { <span class="keywordflow">return</span> ColorGreenReference( arg ); }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// _ACCESSOR_HPP_</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Observez-bien l'accesseur à la composante verte (ColorGreenAccessor). Cet accesseur nous permettra de tranformer un itérateur <code>it</code> sur image de couleur (donc <code>*it</code> est la couleur de pixel, de type <a class="el" href="structColor.html">Color</a>) en un itérateur sur image couleur mais où <code>it</code> est la composante verte du pixel, de type <code>unsigned</code> <code>char</code>.</dd></dl>
<p>Comment se servir des accesseurs dans les itérateurs ? On va "simplement" définir un itérateur générique (paramétré par un type <code>Accessor</code>), qui hérite de votre itérateur <code>ConstIterator</code>, et qui utilise l'accesseur au moment du déréférencement (<code>operator*</code>). Un extrait du code donne donc:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TValue&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_class" href="classImage2D.html">Image2D</a> {</div>
<div class="line">...</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TAccessor&gt; </div>
<div class="line">  <span class="keyword">struct </span>GenericConstIterator : <span class="keyword">public</span> ConstIterator {</div>
<div class="line">    <span class="keyword">typedef</span> TAccessor Accessor;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Accessor::Argument  ImageValue; <span class="comment">// Color ou unsigned char</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Accessor::Value     Value;      <span class="comment">// unsigned char (pour ColorGreenAccessor)</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Accessor::Reference Reference;  <span class="comment">// ColorGreenReference (pour ColorGreenAccessor)</span></div>
<div class="line"> </div>
<div class="line">    GenericConstIterator( <span class="keyword">const</span> <a class="code hl_class" href="classImage2D.html">Image2D&lt;ImageValue&gt;</a>&amp; image, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Accès en lecture (rvalue)</span></div>
<div class="line">    Value operator*()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> Accessor::access( ConstIterator::operator*() ); } <span class="comment">//&lt; Appel de op* de votre itérateur</span></div>
<div class="line"> </div>
<div class="line">  };</div>
<div class="line">...</div>
</div><!-- fragment --><p>Complétez le constructeur de <code>GenericConstIterator</code> (qui doit appeler sa super-classe <code>ConstIterator</code>). Ensuite surchargez les méthodes <code>begin</code>, <code>end</code>, <code>start</code> de <a class="el" href="classImage2D.html" title="Classe générique pour représenter des images 2D.">Image2D</a> avec des patrons de méthodes. Par exemple, un <code>start</code> générique peut s'écrire ainsi:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Accessor&gt;</div>
<div class="line">GenericConstIterator&lt; Accessor &gt; start( <span class="keywordtype">int</span> x = 0, <span class="keywordtype">int</span> y = 0 )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{ <span class="keywordflow">return</span> GenericConstIterator&lt; Accessor &gt;( *<span class="keyword">this</span>, x, y ); }</div>
</div><!-- fragment --><p>Le code suivant doit maintenant fonctionner. Il charge une image couleur et sauve sa composante verte sous forme d'image en niveaux de gris.</p>
<div class="fragment"><div class="line"><span class="comment">// save-green-channel.cpp</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Image2D.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Image2DReader.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Image2DWriter.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Accessor.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv )</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classImage2D.html">Image2D&lt;Color&gt;</a> ColorImage2D;</div>
<div class="line">  <span class="keyword">typedef</span> Image2DReader&lt;Color&gt; ColorImage2DReader;</div>
<div class="line">  <span class="keyword">typedef</span> ColorImage2D::Iterator ColorIterator;</div>
<div class="line">  <span class="keywordflow">if</span> ( argc &lt; 3 ) </div>
<div class="line">    { </div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: save-green-channel &lt;input.ppm&gt; &lt;output.pgm&gt;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">  ColorImage2D img;</div>
<div class="line">  std::ifstream input( argv[1] ); <span class="comment">// récupère le 1er argument.</span></div>
<div class="line">  <span class="keywordtype">bool</span> ok = ColorImage2DReader::read( img, input );</div>
<div class="line">  <span class="keywordflow">if</span> ( !ok )</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Error reading input file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">       <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  input.close();</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="classImage2D.html">Image2D&lt;unsigned char&gt;</a> <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a>;</div>
<div class="line">  <span class="keyword">typedef</span> Image2DWriter&lt;unsigned char&gt; GrayLevelImage2DWriter;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structGrayLevelImage2D_1_1Iterator.html">GrayLevelImage2D::Iterator</a> GrayLevelIterator;</div>
<div class="line">  <a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> img2( img.w(), img.h() );</div>
<div class="line">  </div>
<div class="line">  <span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line">  <span class="comment">// vvvvvvvvv Toute la transformation couleur -&gt; canal vert est ici vvvvvvvvvvvv</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Servira à parcourir la composante verte de l&#39;image couleur.</span></div>
<div class="line">  <span class="keyword">typedef</span> ColorImage2D::GenericConstIterator&lt; ColorGreenAccessor &gt; ColorGreenConstIterator;</div>
<div class="line">  <span class="comment">// Notez comment on appelle la méthode \b générique `begin` de `Image2D`.</span></div>
<div class="line">  ColorGreenConstIterator itGreen = img.begin&lt; ColorGreenAccessor &gt;();</div>
<div class="line">  <span class="comment">// On écrit la composante verte dans l&#39;image en niveaux de gris.</span></div>
<div class="line">  <span class="keywordflow">for</span> ( GrayLevelIterator it = img2.begin(), itE = img2.end();</div>
<div class="line">        it != itE; ++it )</div>
<div class="line">    {</div>
<div class="line">      *it = *itGreen;</div>
<div class="line">      ++itGreen;</div>
<div class="line">      <span class="comment">// NB: si on veut faire *itGreen++, il faut redéfinir GenericConstIterator&lt;T&gt;::operator++(int).</span></div>
<div class="line">    }</div>
<div class="line">  <span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line">  std::ofstream output( argv[2] ); <span class="comment">// récupère le 2eme argument.</span></div>
<div class="line">  <span class="keywordtype">bool</span> ok2 = GrayLevelImage2DWriter::write( img2, output, <span class="keyword">false</span> );</div>
<div class="line">  <span class="keywordflow">if</span> ( !ok2 )</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Error writing output file.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">       <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  output.close();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="astructGrayLevelImage2D_1_1Iterator_html"><div class="ttname"><a href="structGrayLevelImage2D_1_1Iterator.html">GrayLevelImage2D::Iterator</a></div><div class="ttdef"><b>Definition</b> <a href="GrayLevelImage2D_8hpp_source.html#l00020">GrayLevelImage2D.hpp:20</a></div></div>
</div><!-- fragment --><pre class="fragment">prompt$ ./save-green-channel papillon.ppm papillon-green.pgm
</pre><table class="doxtable">
<tr>
<td><img src="./papillon.png" alt="" width="500" height="328" class="inline"/>  </td><td><img src="./papillon-green.png" alt="" width="500" height="328" class="inline"/>   </td></tr>
<tr>
<td>Image papillon.ppm </td><td>Sa composante verte vue comme une image en niveaux de gris  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>La pré-incrémentation seule <code>++itGreen</code> marche car on n'exploite pas la valeur de l'itérateur. On peut donc directement appeler cet opérateur écrit dans la super-classe <code>ConstIterator</code>.</dd>
<dd>
Si on veut écrire une expression comme <code>*itGreen++</code> alors l'opérateur de post-incrémentation (<code>operator++(int)</code>) par défaut de <code>Container::const_iterator</code> n'est pas correct (il retourne un <code>Container::const_iterator</code> au lieu d'un <code>GenericConstIterator</code>). On écrirait donc les lignes suivantes:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Post-incrémentation de l&#39;itérateur.</span></div>
<div class="line">GenericConstIterator operator++( <span class="keywordtype">int</span> <span class="comment">/* dummy_parameter */</span> )</div>
<div class="line">{ </div>
<div class="line">  GenericConstIterator tmp = *<span class="keyword">this</span>; <span class="comment">// sauve la position courante.</span></div>
<div class="line">  Container::const_iterator::operator++(); <span class="comment">// avance avec Container::const_iterator::op++()</span></div>
<div class="line">  <span class="keywordflow">return</span> tmp; <span class="comment">// retourne la position précédente</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="cpp_tp2_8"></a>
8 Créer les nouveaux accesseurs à la composante rouge et bleue</h1>
<p>Ecrivez maintenant deux nouvelles classes <code>ColorRedAccessor</code> et <code>ColorBlueAccessor</code>. Ecrire alors un nouveau programme <code>save-channels.cpp</code> qui prend une image en entrée et sauvegarde 3 images en sortie, une par composante couleur. Ainsi,</p>
<pre class="fragment">prompt$ ./save-channels papillon.ppm
</pre><table class="doxtable">
<tr>
<td><img src="./papillon.png" alt="" width="500" height="328" class="inline"/>  </td><td><img src="./papillon_red.png" alt="" width="500" height="328" class="inline"/>   </td></tr>
<tr>
<td>Image papillon.ppm </td><td>Sa composante rouge (papillon_red.pgm)  </td></tr>
<tr>
<td><img src="./papillon_green.png" alt="" width="500" height="328" class="inline"/>  </td><td><img src="./papillon_blue.png" alt="" width="500" height="328" class="inline"/>   </td></tr>
<tr>
<td>Sa composante verte (papillon_green.pgm)</td><td>Sa composante bleue (papillon_blue.pgm)  </td></tr>
</table>
<p>Les insectes butineurs (abeilles, guêpes, papillons) voient beaucoup mieux le bleu que nous (et d'ailleurs ils voient aussi un peu dans l'ultra-violet). L'image en composante bleue montre combien les fleurs (violettes) ressortent par rapport au fond vert, ceci afin d'attirer les insectes butineurs.</p>
<h1><a class="anchor" id="cpp_tp2_9"></a>
9 Itérateurs génériques non constants</h1>
<p>Nous avons fait l'itérateur générique en lecture. Il faut faire maintenant l'itérateur générique en lecture/écriture (i.e. non <code>const</code>). Ce n'est pas difficile, il suffit de créer une classe générique <code>GenericIterator</code> sur le même modèle que <code>GenericConstIterator</code>, mais en dérivant cette fois de <code>Iterator</code>. L'opérateur de déréférencement pour les lvalue (lecture/écriture) s'écrit ainsi:</p>
<div class="fragment"><div class="line"><span class="comment">// Accès en écriture (lvalue)</span></div>
<div class="line">Reference operator*()</div>
<div class="line">{ <span class="keywordflow">return</span> Accessor::access( Container::iterator::operator*() ); }</div>
</div><!-- fragment --><p>La seule différence avec l'opérateur lecture seule est le type retourné. Il ne vous reste plus qu'à écrire les méthodes génériques <code>begin</code>, <code>end</code>, et <code>start</code> sur le même modèle que précédemment.</p>
<p>A titre d'illustration, l'extrait de code suivant transforme une image couleur de façon à donner l'illusion de la voir sur les vieux écrans cathodiques couleur. Sur ces écrans, on voyait nettement que les composantes rouge, vert et bleu étaient affichées côte à côte. Le code visite l'image couleur, et ne garde qu'une composante à chaque pixel, en alternant rouge, vert et bleu, les autres étant mises à zéro.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ColorImage2D::GenericIterator&lt; ColorRedAccessor &gt;   ColorRedConstIterator;</div>
<div class="line"><span class="keyword">typedef</span> ColorImage2D::GenericIterator&lt; ColorGreenAccessor &gt; ColorGreenConstIterator;</div>
<div class="line"><span class="keyword">typedef</span> ColorImage2D::GenericIterator&lt; ColorBlueAccessor &gt;  ColorBlueConstIterator;</div>
<div class="line">ColorRedConstIterator   itRed   = img.begin&lt; ColorRedAccessor &gt;();</div>
<div class="line">ColorGreenConstIterator itGreen = img.begin&lt; ColorGreenAccessor &gt;();</div>
<div class="line">ColorBlueConstIterator  itBlue  = img.begin&lt; ColorBlueAccessor &gt;();</div>
<div class="line"><span class="comment">// On écrit la composante verte dans l&#39;image en niveaux de gris.</span></div>
<div class="line"><span class="keywordtype">int</span> x = 0;</div>
<div class="line"><span class="keywordflow">for</span> ( ColorIterator it = img.begin(), itE = img.end();</div>
<div class="line">      it != itE; ++it )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">switch</span> ( x % 3 ) {</div>
<div class="line">    <span class="keywordflow">case</span> 0: *itGreen = *itBlue  = 0; <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 1: *itRed   = *itBlue  = 0; <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 2: *itRed   = *itGreen = 0; <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    ++itRed; ++itGreen; ++itBlue;</div>
<div class="line">    x = ( x+1 ) % img.w();</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Cela donne pour l'image kowloon.ppm:</p>
<table class="doxtable">
<tr>
<td><img src="./kowloon-old-tv.png" alt="" width="500" height="328" class="inline"/>  </td><td><img src="./kowloon-old-tv-zoom.png" alt="" width="500" height="328" class="inline"/>   </td></tr>
<tr>
<td>Image kowloon comme sur les vieux écrans </td><td>Zoom dessus   </td></tr>
</table>
<p>Vérifiez donc que vos itérateurs fonctionnent correctement en créant ce petit programme.</p>
<h1><a class="anchor" id="cpp_tp2_10"></a>
10 Espace TSV (HSV) et histogramme d'une image couleur</h1>
<p>Au TP précédent, vous avez vu comment calculer l'histogramme d'une image en niveaux de gris (voir <a class="el" href="cpp_tp1.html#cpp_tp1_7">7 - Histogramme et Histogramme cumulé d'une image.</a>). Qu'en est-il d'une image couleur ? Tel quel, cela n'a pas vraiment de sens de calculer l'histogramme dans l'espace RGB. En revanche, cela a plus de sens dans un autre espace de couleurs appelé Teinte Saturation Valeur (TSV) ou Hue Saturation Value (HSV) en anglais. La page [<a href="http://fr.wikipedia.org/wiki/Teinte_Saturation_Valeur">http://fr.wikipedia.org/wiki/Teinte_Saturation_Valeur</a> Wikipedia TSV] décrit cet espace de couleur ainsi que les fonctions pour transformer RGB vers TSV et réciproquement.</p>
<p>Nous allons définir l'histogramme d'une image couleur comme l'histogramme des <b>valeurs</b> (au sens de TSV) des pixels. Pour ce faire, il faut d'abord enrichir la classe <a class="el" href="structColor.html">Color</a>, car elle ne comporte la méthode <a class="el" href="structColor.html#ae36aabe5c53a92dee8c49044b70dd91d">Color::getHSV</a> pour convertir RGB vers TSV, mais pas l'inverse. Ecrivez donc la méthode de <a class="el" href="structColor.html">Color</a> qui réalise la transformation TSV vers RGB, dont le prototype sera:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="structColor.html#ae134ffc8127610be421018c041e1bff5">Color::setHSV</a>( <span class="keywordtype">int</span> h, <span class="keywordtype">float</span> s, <span class="keywordtype">float</span> v ) { ... };</div>
</div><!-- fragment --><p>Ensuite, nous pouvons maintenant écrire un nouvel accesseur vers la <b>valeur</b> d'une couleur. Sa structure est ainsi, qu'il s'agit de compléter:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ColorValueAccessor {</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> Value;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_struct" href="structColor.html">Color</a> Argument;</div>
<div class="line">  <span class="keyword">struct </span>ColorValueReference {</div>
<div class="line">    <span class="comment">// Référence vers la variable Color donnée à l&#39;objet à sa construction</span></div>
<div class="line">    Argument &amp; arg; <span class="comment"></span></div>
<div class="line"><span class="comment">    /// Constructeur permettant à cet objet de référencer la variable</span></div>
<div class="line"><span class="comment">    /// Color donnée en paramètre.</span></div>
<div class="line"><span class="comment"></span>    ColorValueReference( Argument &amp; someArg ) : arg( someArg ) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Cette fonction sera appelée lors d&#39;un `*it = ...`.</span></div>
<div class="line">    <span class="comment">// S&#39;occupe de changer la valeur de la couleur arg </span></div>
<div class="line">    <span class="comment">// en fonction de la valeur donnée val.</span></div>
<div class="line">    <span class="comment">// Il faut utiliser arg.getHSV et arg.setHSV.</span></div>
<div class="line">    ColorValueReference&amp; operator=( Value val ) </div>
<div class="line">    { ... }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// S&#39;occupe de retourner la valeur de la couleur arg (sans la changer).</span></div>
<div class="line">    <span class="comment">// Un simple appel à arg.getHSV suffira.</span></div>
<div class="line">    <span class="keyword">operator</span> Value()<span class="keyword"> const </span></div>
<div class="line"><span class="keyword">    </span>{ ... }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> ColorValueReference Reference;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Il s&#39;agit d&#39;un simple accès en lecture à la valeur de la couleur arg.</span></div>
<div class="line">  <span class="comment">// Un simple appel à arg.getHSV suffira.</span></div>
<div class="line">  <span class="keyword">static</span> Value access( <span class="keyword">const</span> Argument &amp; arg ) </div>
<div class="line">  { ... } </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Il suffit de créer et retourner un objet de type ColorValueReference référençant arg.</span></div>
<div class="line">  <span class="keyword">static</span> Reference access( Argument &amp; arg ) </div>
<div class="line">  { ... }</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p>Il reste maintenant à écrire l'algorithme qui calcule l'histogramme et l'histogramme cumulé des valeurs de l'image couleur. Ecrivez donc une classe <code>Histogramme</code> qui contiendra deux tableaux de 256 entrées double, l'un pour l'histogramme \(h_I\), l'autre pour l'histograme cumulé \(H_I\). Pour calculer l'histogramme sur des images arbitraires, cette classe aura une méthode générique</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt; <span class="keywordtype">void</span> init( InputIterator it, InputIterator itE ) { ... }</div>
</div><!-- fragment --><p>qui parcourera l'intervalle [it,itE) pour calculer son histogramme et son histogramme cumulé. Ainsi on pourra se servir des histogrammes indifféremment pour les images couleurs et niveaux de gris, comme ci-dessous:</p>
<div class="fragment"><div class="line">Histogramme H;</div>
<div class="line"><a class="code hl_class" href="classGrayLevelImage2D.html">GrayLevelImage2D</a> img( 512, 512 );</div>
<div class="line">H.init( img.begin(), img.end() ); <span class="comment">// fonctionne, car l&#39;itérateur a une valeur de type unsigned char.</span></div>
<div class="line">ColorImage2D img2( 512, 512 );</div>
<div class="line">H.init( img2.begin&lt; ColorValueAccessor &gt;(),</div>
<div class="line">        img2.end&lt; ColorValueAccessor &gt;() );  <span class="comment">// fonctionne, car l&#39;itérateur a une valeur de type unsigned char.</span></div>
</div><!-- fragment --><p>Ecrivez maintenant le programme <code>histogramme</code> qui prend en entrée une image couleur et qui sauvegarde une image en niveaux de gris qui représente l'histogramme des valeurs de l'image couleur.</p>
<pre class="fragment">prompt$ ./histogramme kowloon.ppm kowloon-h.pgm
</pre><table class="doxtable">
<tr>
<td><img src="./kowloon.png" alt="" width="500" height="328" class="inline"/>  </td><td><img src="./kowloon-h.png" alt="" width="512" height="328" class="inline"/>   </td></tr>
<tr>
<td>Image kowloon.ppm </td><td>Histogramme (à gauche) et histogramme cumulé (à droite)  </td></tr>
</table>
<p>On note que l'image <code>kowloon.ppm</code> n'est pas parfaitement bien balancée.</p>
<h1><a class="anchor" id="cpp_tp2_11"></a>
11 Egalisation d'image couleur</h1>
<p>D'après le TP précédent (<a class="el" href="cpp_tp1.html#cpp_tp1_7">7 - Histogramme et Histogramme cumulé d'une image.</a>), dès que l'on a un histogramme cumulé d'une image, il est maintenant facile d'égaliser l'image pour la rendre bien balancée. On reprendra donc la formule du TP précédent pour écrire la méthode <code>int egalisation( int i ) const</code> de la classe <code>Histogramme</code>.</p>
<p>On utilisera cette fonction d'égalisation mais sur les <b>valeurs</b> des couleurs, via nos itérateurs génériques avec accesseur ColorValueAccessor. Vous écrirez donc le programme <code>egaliseur-couleur.cpp</code> qui réalise cette égalisation d'une image couleur. Par exemple</p>
<pre class="fragment">prompt$ ./egaliseur-couleur kowloon.ppm kowloon-eg.ppm
prompt$ ./egaliseur-couleur papillon.ppm papillon-eg.ppm
</pre><table class="doxtable">
<tr>
<td><img src="./kowloon.png" alt="" width="500" height="328" class="inline"/>  </td><td><img src="./kowloon-v-eg.png" alt="" width="500" height="328" class="inline"/>   </td></tr>
<tr>
<td>Image kowloon.ppm </td><td>Image kowloon.ppm dont les valeurs sont égalisées  </td></tr>
<tr>
<td><img src="./kowloon-h.png" alt="" width="512" height="256" class="inline"/>  </td><td><img src="./kowloon-v-eg-h.png" alt="" width="512" height="256" class="inline"/>   </td></tr>
<tr>
<td>Histogramme (à gauche) et histogramme cumulé (à droite) </td><td>Histogramme (à gauche) et histogramme cumulé (à droite)  </td></tr>
<tr>
<td><img src="./papillon.png" alt="" width="500" height="328" class="inline"/>  </td><td><img src="./papillon-v-eg.png" alt="" width="500" height="328" class="inline"/>   </td></tr>
<tr>
<td>Image papillon.ppm </td><td>Image papillon.ppm dont les valeurs sont égalisées  </td></tr>
<tr>
<td><img src="./papillon-h.png" alt="" width="512" height="256" class="inline"/>  </td><td><img src="./papillon-v-eg-h.png" alt="" width="512" height="256" class="inline"/>   </td></tr>
<tr>
<td>Histogramme (à gauche) et histogramme cumulé (à droite) </td><td>Histogramme (à gauche) et histogramme cumulé (à droite)  </td></tr>
</table>
<h1><a class="anchor" id="cpp_tp2_12"></a>
12 Un peu d'imagination</h1>
<p>Proposez un traitement quelconque (effet artistique, transformation sepia, flou, filtrage de bruit, fusion de photos, tourner les couleurs de 60°, saturer (rendre criard) ou désaturer (rendre pastel) une image, ...) et mettez-le en oeuvre avec vos classes génériques.</p>
<p>Voici quelques exemples obtenus en faisant des filtres différenciés suivant les canaux (R,G,B ou H,S,V).</p>
<ul>
<li>5 dilations morphologiques sur les 3 canaux RGB (élément structurant carré 3x3), suivis de 5 érosions morphologiques sur les 3 canaux RGB, suivi d'un rehaussement de contraste (alpha=5) sur le canal V.</li>
</ul>
<table class="doxtable">
<tr>
<td><img src="./kowloon.png" alt="" width="500" class="inline"/>  </td><td><img src="./kowloon-e4.png" alt="" width="500" class="inline"/>   </td></tr>
</table>
<ul>
<li>dilation morphologique sur le canal V (élément structurant disque de rayon 5), suivis d'une ériosion morphologique sur ce même canal, suivi d'un rehaussement de contraste (alpha=1) sur le canal V.</li>
</ul>
<table class="doxtable">
<tr>
<td><img src="./papillon.png" alt="" width="500" class="inline"/>  </td><td><img src="./papillon-e1.png" alt="" width="500" class="inline"/>  </td></tr>
<tr>
<td><img src="./lena-color.png" alt="" width="500" class="inline"/>  </td><td><img src="./lena-e1.png" alt="" width="500" class="inline"/>  </td></tr>
</table>
<ul>
<li>atténuation des couleurs vert et bleu, en baissant la saturation autour de ces couleurs (on regarde la valeur de teinte H), et si elle est autour de vert ou bleu on abaisse la saturation S).</li>
</ul>
<table class="doxtable">
<tr>
<td><img src="./papillon.png" alt="" width="500" class="inline"/>  </td><td><img src="./papillon-e2.png" alt="" width="500" class="inline"/>  </td></tr>
</table>
<ul>
<li>atténuation des couleurs vert et bleu, en baissant la saturation autour de ces couleurs (on regarde la valeur de teinte H), et si elle est autour de vert ou bleu on abaisse la saturation S). Enfin, on décale la teinte de -60° sur le résultat.</li>
</ul>
<table class="doxtable">
<tr>
<td><img src="./papillon.png" alt="" width="500" class="inline"/>  </td><td><img src="./papillon-e5.png" alt="" width="500" class="inline"/>  </td></tr>
</table>
<ul>
<li>dilation morphologique sur le canal S (élément structurant disque de rayon 5), suivis d'une ériosion morphologique sur ce même canal, suivi d'un rehaussement de contraste (alpha=1) sur le canal V.</li>
</ul>
<table class="doxtable">
<tr>
<td><img src="./kowloon.png" alt="" width="500" class="inline"/>  </td><td><img src="./kowloon-e3.png" alt="" width="500" class="inline"/>  </td></tr>
</table>
<h1><a class="anchor" id="cpp_tp2_13"></a>
13 TP à rendre</h1>
<p>Vous écrirez un compte-rendu de ce TP (format Open office, Word, texte, PDF, LaTeX au choix) dans lequel vous préciserez les points suivants :</p>
<ul>
<li>nom(s), prénom(s), groupe (monôme ou binôme)</li>
<li>Vous listerez d'abord les points du TP que vous avez abordés, en précisant si selon vous, vous avez traité complètement ou traité partiellement la question. Précisez aussi pour chaque question si votre code fonctionne ou dans quelle mesure il fonctionne.</li>
<li>vous préciserez pour chaque partie quels sont les fichiers entête et sources que je dois regarder, et éventuellement le programme que je dois compiler/relancer.</li>
<li>n'hésitez pas à étoffer de commentaires utiles vos travaux, ou d'images de tests.</li>
<li>vous placerez dans une archive (zip ou tar.gz) votre compte-rendu ainsi que vos sources/entêtes/makefile, de façon à ce que je puisse tout recompiler en tapant "make".</li>
<li>le nom de votre archive sera de la forme <code>TP-XXX-YYY.*</code> où <code>XXX</code> et <code>YYY</code> désignent les noms respectifs des étudiants du binôme.</li>
<li>vous m'enverrez votre archive via <a href="https://tplab.apps.math.cnrs.fr">TPLab </a> avant la fin de la séance. Vous pouvez m'envoyer votre version finale avant une <b> date à définir </b>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 10 2025 15:49:34 for INFO702 - TPs by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
