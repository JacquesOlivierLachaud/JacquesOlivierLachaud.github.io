<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INFO607: Enveloppe convexe de points.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INFO607
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Enveloppe convexe de points.</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tp-CVX-1">1 - Objectifs</a></li>
<li class="level1"><a href="#tp-CVX-2">2 - Nombre de points quelconques et génération aléatoire</a><ul><li class="level2"><a href="#tp-CVX-2-1">2.1 - Tableau de points dynamique</a></li>
<li class="level2"><a href="#tp-CVX-2-2">2.2 - Variation du nombre de points ajouté.</a></li>
<li class="level2"><a href="#tp-CVX-2-3">2.3 - Génération de points aléatoires dans un losange</a></li>
</ul>
</li>
<li class="level1"><a href="#tp-CVX-3">3 - Balayage de Graham</a><ul><li class="level2"><a href="#tp-CVX-3-1">3-1 - Recherche du point le plus bas</a></li>
<li class="level2"><a href="#tp-CVX-3-2">3-2 - Tri du tableau de points</a></li>
<li class="level2"><a href="#tp-CVX-3-3">3-3 - Structure de Pile</a></li>
<li class="level2"><a href="#tp-CVX-3-4">3-4 - Balayage de Graham</a></li>
<li class="level2"><a href="#tp-CVX-3-5">3-5 - Nombre de points et temps d&#39;exécution</a></li>
</ul>
</li>
<li class="level1"><a href="#tp-CVX-4">4 - Algorithme de Jarvis</a></li>
<li class="level1"><a href="#tp-CVX-5">5 - Remise du tp</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tp-CVX-1"></a>
1 - Objectifs</h1>
<p>L'objectif de ce TP est de vous faire mettre en oeuvre des algorithmes efficaces pour calculer l'enveloppe convexe d'un ensemble de points.</p>
<p>Pour faciliter la visualisation, on utilisera la bibliothèque GTK (<a href="http://www.gtk.org">http://www.gtk.org</a>) comme interface graphique. Elle permet de tracer des points et des lignes, d'avoir des boutons et sélecteur de paramètres, etc. Vous vous en êtes déjà servi en cours de C, INFO504 (<a href="https://www.lama.univ-savoie.fr/pagesmembres/lachaud/Cours/INFO504/Tests/doc/html/tp3.html">https://www.lama.univ-savoie.fr/pagesmembres/lachaud/Cours/INFO504/Tests/doc/html/tp3.html</a>) pour le TP Tetris graphique.</p>
<p>Pour vous faire gagner du temps, on vous donne une application de base <a class="el" href="convex_8c.html">convex.c</a> , qui tire aléatoirement dix points dans le disque unité et affiche tous les points dans une zone de dessin.</p>
<p>Prenez d'abord le temps de bien comprendre le code écrit, le source est consultable là: <a class="el" href="convex_8c.html">convex.c</a>, <a class="el" href="TP-Proximity_2points_8h.html">points.h</a>, <a class="el" href="TP-Proximity_2points_8c.html">points.c</a> et est présent dans l'archive, le makefile est ci-dessous:</p>
<div class="fragment"><div class="line">CC=gcc</div>
<div class="line">LD=gcc</div>
<div class="line">CFLAGS=-g -Wall -Werror -pedantic -std=c11</div>
<div class="line">LIBS=-lm</div>
<div class="line"># gtk+-2.0 pour GTK2</div>
<div class="line"># gtk+-3.0 pour GTK3 (choisi ici)</div>
<div class="line">GTKCFLAGS:=-g $(shell pkg-config --cflags gtk+-3.0)</div>
<div class="line">GTKLIBS:=$(shell pkg-config --libs gtk+-3.0)</div>
<div class="line"> </div>
<div class="line">all: convex</div>
<div class="line"> </div>
<div class="line">convex: convex.o points.o</div>
<div class="line">        $(LD) convex.o points.o $(GTKLIBS) $(LIBS) -o convex</div>
<div class="line"> </div>
<div class="line">convex.o: convex.c</div>
<div class="line">        $(CC) -c $(CFLAGS) $(GTKCFLAGS) convex.c -o convex.o</div>
<div class="line"> </div>
<div class="line">points.o: points.c points.h </div>
<div class="line">        $(CC) -c $(CFLAGS) $(GTKCFLAGS) points.c -o points.o</div>
<div class="line"> </div>
<div class="line">clean:</div>
<div class="line">        rm -f convex convex.o points.o</div>
<div class="line"> </div>
<div class="line">fullclean: clean</div>
<div class="line">        rm -f *~ *.fig.bak</div>
</div><!-- fragment --><p>Il s'exécute ainsi: </p><pre class="fragment">prompt$ make
prompt$ ./convex</pre><p>A l'issue de ce TP, vous aurez:</p><ul>
<li>créer des tableaux dynamiques pour faire une pile de taille arbitraire,</li>
<li>programmer deux algorithmes efficaces de calcul d'enveloppe convexe,</li>
<li>mesurer leurs temps d'exécution et vérifier expérimentalement leur comportement lorsque le nombre de points tend vers l'infini mais aussi en fonction de la distribution spatiale des points.</li>
</ul>
<h1><a class="anchor" id="tp-CVX-2"></a>
2 - Nombre de points quelconques et génération aléatoire</h1>
<p>Nous allons tester nos fonctions de calcul de l'enveloppe convexe sur des ensembles de points de grande taille, mais aussi de formes particulières. On observera que l'efficacité de certains algorithmes ne dépend pas seulement de la taille des données en entrées, mais aussi de leurs valeurs (ici les formes considérées). Il faut donc d'une part pouvoir traiter des ensembles de points de taille arbitraire mais aussi générer des points suivant différentes formes. C'est ce que l'on fait dans cette section.</p>
<h2><a class="anchor" id="tp-CVX-2-1"></a>
2.1 - Tableau de points dynamique</h2>
<p>Pour le moment, les fonctions du fichier points.c ne permettent de gérer qu'un tableau de 100 points maximum. Vous pouvez le vérifier en cliquant plusieurs fois sur le bouton pour ajouter des points. Au bout d'un moment, les points ne sont plus ajoutés.</p>
<p>Ecrivez une fonction <code>TabPoints_agrandir</code>, appelée automatiquement par <a class="el" href="TP-Convex_2points_8c.html#ab284e1d30c1eb99d8b679c2434ef9dce">TabPoints_ajoute</a>, qui double la capacité du tableau lorsqu'il est saturé. Notez que vous avez vu en TD que cette opération a un <em>coût</em> <em>amorti</em> constant.</p>
<h2><a class="anchor" id="tp-CVX-2-2"></a>
2.2 - Variation du nombre de points ajouté.</h2>
<p>Ajoutez un champ GTK_ENTRY pour que l'utilisateur puisse changer le nombre de points ajoutés lorsqu'il clique sur le bouton "Points
   aléatoires dans disque". Vous utiliserez les fonctions <code>gtk_entry_new</code> puis <code>gtk_entry_set_text</code> et <code>gtk_entry_get_text</code> pour ce faire. Vous ajouterez aussi un champ GTK_LABEL pour afficher le nombre <b>total</b> de points dans le tableau de points. Les fonctions utiles associées sont <code>gtk_label_new</code> et <code>gtk_label_set_text</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Pour converter une chaîne de caractères vers un entier, on rappelle que vous disposez de la fonction <code>int atoi( char * )</code> dans <code>stdlib.h</code>. Pour faire l'inverse, on peut utiliser <code>sprintf</code> qui affiche dans un tableau de caractères.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* txt = <span class="stringliteral">&quot;357&quot;</span>;</div>
<div class="line"><span class="keywordtype">int</span>   nb  = atoi( txt );  <span class="comment">// nb = 357</span></div>
<div class="line"><span class="keywordtype">char</span>  str[ 100 ];</div>
<div class="line">sprintf( str, <span class="stringliteral">&quot;%d&quot;</span>, nb ); <span class="comment">// str = &quot;357&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="tp-CVX-2-3"></a>
2.3 - Génération de points aléatoires dans un losange</h2>
<p>Ajoutez un bouton pour générer des points dans le losange de sommets \( \pm (1,0), \pm (0,1) \). L'idée est de tourner les points générés dans le carré \( [-1:1] \times [-1:1] \) de 45 degrés, en divisant les longueurs pour obtenir un côté de taille \(\frac{\sqrt{2}}{2}\). Si <em>x</em> et <em>y</em> sont les coordonnées du point tiré aléatoirement dans le carré précédent, alors la transformation s'écrit ainsi </p><p class="formulaDsp">
\[ \left(\begin{array}{c}x&#39;\\
   y&#39;\end{array}\right) = \frac{\sqrt{2}}{4}
   \left(\begin{array}{cc}1&amp;1\\-1&amp;1\end{array}\right)
   \left(\begin{array}{c}x\\ y\end{array}\right). \]
</p>
<p>Vous reconnaissez une rotation de 45 degrés avec un changement d'échelle.</p>
<p>A la fin de cette section, votre application peut ressembler à cela:</p>
<div class="image">
<img src="capture-2.png" alt=""/>
<div class="caption">
700 points générés aléatoirement dans le losange unité.</div></div>
<h1><a class="anchor" id="tp-CVX-3"></a>
3 - Balayage de Graham</h1>
<p>Le balayage de Graham suit l'idée suivante. On se donne un point que l'on sait sur l'enveloppe convexe. Ensuite on ordonne tous les points autour selon leur angle polaire par rapport à ce point. On les trie donc suivant cet ordre. Si on considère la ligne polygonale qui relie tous ces points ordonnés, on remarque qu'il s'agit d'un polygone simple.</p>
<div class="image">
<img src="capture-3.png" alt=""/>
<div class="caption">
Balayage de Graham. Les points triés forment un polygone simple.</div></div>
<p>Ensuite il suffit de construire progressivement l'enveloppe convexe à l'aide d'une pile, en vérifiant si le nouveau point ajouté est bien à gauche des deux points précédents sur la pile. Si oui, on l'ajoute à la pile. Si non, on enlève le sommet de pile jusqu'à ce que le point soit bien à gauche des deux précédents. L'algorithme est le suivant.</p>
<pre class="fragment">// Enveloppe convexe par Parcours de Graham.
Procedure ConvexHull(E T : Tableau de Point, E n : entier, S P : Pile de Point);
Var i : entier;
Debut
  i &lt;- TrouverPointBasGauche( T, n );
  Echange( T[0], T[i] ); // T[0] est le pivot
  TrierSelonT0( T, n );  // On trie les points 1 à n-1 suivant l'angle T[0]T[i].
  CréerPile( P );
  Empiler( P, T[ 0 ] );
  Empiler( P, T[ 1 ] );
  Pour i de 2 a n-1 Faire
    Tant que non EstAGauche( ValeurDeuxième( P ), ValeurSommet( P ), T[ i ] ) Faire
      Dépiler( P );
    Empiler( P, T[ i ] );
  // P contient la liste des sommets de l'enveloppe convexe dans l'ordre inverse.
Fin</pre><p>Notez que vous pouvez utiliser la fonction <code>Orientation</code> vue en cours pour trier les points (plutôt que de vraiment calculer un angle polaire).</p>
<h2><a class="anchor" id="tp-CVX-3-1"></a>
3-1 - Recherche du point le plus bas</h2>
<p>Dans un premier temps écrivez la fonction qui recherche l'indice du point le plus en bas, et si égalité, le plus à gauche. Ecrivez donc la fonction suivante dans les fichiers <a class="el" href="TP-Proximity_2points_8h.html">points.h</a> et <a class="el" href="TP-Proximity_2points_8c.html">points.c</a> :</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> TabPoints_indexBasGauche( <a class="code hl_struct" href="structSTabPoint.html">TabPoints</a>* tab );</div>
<div class="ttc" id="astructSTabPoint_html"><div class="ttname"><a href="structSTabPoint.html">STabPoint</a></div><div class="ttdef"><b>Definition</b> <a href="TP-Convex_2points_8h_source.html#l00009">points.h:9</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="tp-CVX-3-2"></a>
3-2 - Tri du tableau de points</h2>
<p>Ecrivez ensuite la fonction de tri suivant l'angle polaire par rapport au point d'indice 0 du tableau <em>tab</em> donné en entrée.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TabPoints_triSelonT0( <a class="code hl_struct" href="structSTabPoint.html">TabPoints</a>* tab );</div>
</div><!-- fragment --><p>Vous pouvez utiliser votre propre algorithme de tri (bulle, quick sort). On peut aussi utiliser la fonction <code>qsort</code> de <code>stdlib.h</code> en veillant à lui fournir la bonne fonction de comparaison. Faites</p>
<pre class="fragment">prompt$ man 3 qsort</pre><p>pour avoir des infos.</p>
<dl class="section note"><dt>Note</dt><dd>On doit trier par rapport à la position du point <code>T[0]</code>. Donc il faut passer cette information à la fonction de comparaison de l'algorithme <code>qsort</code>. La solution la plus simple (que vous allez suivre ici) est de définir une variable globale de type <code>Point</code> à laquelle vous affectez la valeur <code>T[0]</code>, puis vous pouvez l'utilisez dans la fonction de comparaison appelée par <code>qsort</code>.</dd></dl>
<h2><a class="anchor" id="tp-CVX-3-3"></a>
3-3 - Structure de Pile</h2>
<p>Nous avons besoin d'une structure de pile pour l'algorithme. En récupérant pas mal de code de la structure <a class="el" href="TP-Convex_2points_8h.html#ab536e9a06f39c3aed5fc5c4ede63d781">TabPoints</a>, écrivez une structure de pile de taille quelconque avec les fonctions suivantes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef _PILE_H_</span></div>
<div class="line"><span class="preprocessor">#define _PILE_H_</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;points.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>SPilePoint {</div>
<div class="line">  <span class="keywordtype">int</span> taille;</div>
<div class="line">  <span class="keywordtype">int</span> nb;</div>
<div class="line">  <a class="code hl_struct" href="structSPoint.html">Point</a>* points;</div>
<div class="line">} PilePoints;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span>  PilePoints_init( PilePoints* pile );</div>
<div class="line"><span class="keywordtype">int</span>   PilePoints_estVide( PilePoints* pile );</div>
<div class="line"><span class="keywordtype">void</span>  PilePoints_empile( PilePoints* pile, <a class="code hl_struct" href="structSPoint.html">Point</a> p );</div>
<div class="line"><span class="keywordtype">void</span>  PilePoints_depile( PilePoints* pile );</div>
<div class="line"><a class="code hl_struct" href="structSPoint.html">Point</a> PilePoints_sommet( PilePoints* pile );</div>
<div class="line"><span class="comment">// Récupère l&#39;élément juste sous le sommet de la pile.</span></div>
<div class="line"><a class="code hl_struct" href="structSPoint.html">Point</a> PilePoints_deuxiemeSommet( PilePoints* pile );</div>
<div class="line"><span class="keywordtype">void</span>  PilePoints_agrandir( PilePoints* pile );</div>
<div class="line"><span class="keywordtype">void</span>  PilePoints_termine( PilePoints* pile );</div>
<div class="line"><span class="keywordtype">int</span>   PilePoints_nb( PilePoints* pile );</div>
<div class="line"><a class="code hl_struct" href="structSPoint.html">Point</a> PilePoints_get( PilePoints* pile, <span class="keywordtype">int</span> idx );</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="astructSPoint_html"><div class="ttname"><a href="structSPoint.html">SPoint</a></div><div class="ttdef"><b>Definition</b> <a href="TP-Convex_2points_8h_source.html#l00004">points.h:4</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="tp-CVX-3-4"></a>
3-4 - Balayage de Graham</h2>
<p>Vous avez maintenant tout ce qu'il faut pour écrire le balayage de Graham (cf. algorithme au dessus). Vous rajouterez un bouton pour réalisez le balayage de Graham. Vous enrichissez la structure Contexte avec une <code>PilePoints</code> qui contiendra le résultat. Pour l'affichage, on peut utiliser la fonction suivante pour afficher une ligne:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="main_8c.html#af4e48894cd74cff901d1f09e79be434b">drawLine</a>( cairo_t* cr, <a class="code hl_struct" href="structSPoint.html">Point</a> p, <a class="code hl_struct" href="structSPoint.html">Point</a> q )</div>
<div class="line">{</div>
<div class="line">  cairo_move_to( cr, p.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>, p.<a class="code hl_variable" href="structSPoint.html#a7bdc963df926f88eadaf4994f6a5583d">y</a> );</div>
<div class="line">  cairo_line_to( cr, q.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>, q.<a class="code hl_variable" href="structSPoint.html#a7bdc963df926f88eadaf4994f6a5583d">y</a> );</div>
<div class="line">  cairo_stroke( cr );</div>
<div class="line">}</div>
<div class="ttc" id="amain_8c_html_af4e48894cd74cff901d1f09e79be434b"><div class="ttname"><a href="main_8c.html#af4e48894cd74cff901d1f09e79be434b">drawLine</a></div><div class="ttdeci">void drawLine(cairo_t *cr, Point p, Point q)</div><div class="ttdef"><b>Definition</b> <a href="main_8c_source.html#l00230">main.c:230</a></div></div>
<div class="ttc" id="astructSPoint_html_a7bdc963df926f88eadaf4994f6a5583d"><div class="ttname"><a href="structSPoint.html#a7bdc963df926f88eadaf4994f6a5583d">SPoint::y</a></div><div class="ttdeci">double y</div><div class="ttdef"><b>Definition</b> <a href="TP-Convex_2points_8h_source.html#l00006">points.h:6</a></div></div>
<div class="ttc" id="astructSPoint_html_ad39d5d98239044aba9f723024d07d6bd"><div class="ttname"><a href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">SPoint::x</a></div><div class="ttdeci">double x</div><div class="ttdef"><b>Definition</b> <a href="TP-Convex_2points_8h_source.html#l00005">points.h:5</a></div></div>
</div><!-- fragment --><p>Voilà maintenant le résultat du balayage de Graham sur un nuage de points dans un disque.</p>
<div class="image">
<img src="capture-3-4.png" alt=""/>
<div class="caption">
Balayage de Graham. Résultat du calcul de l'enveloppe convexe.</div></div>
<h2><a class="anchor" id="tp-CVX-3-5"></a>
3-5 - Nombre de points et temps d'exécution</h2>
<p>En utilisant des GTK_LABEL, affichez maintenant le nombre de points sur l'enveloppe convexe ainsi que le temps d'exécution du dernier calcul de l'enveloppe convexe. On voit ainsi que sur les formes polygonales, l'enveloppe convexe a très peu de sommets.</p>
<div class="image">
<img src="capture-3-5.png" alt=""/>
<div class="caption">
Balayage de Graham. Nombre de sommets de l'enveloppe convexe et temps d'exécution.</div></div>
<p>Pour mesurer le temps d'exécution, reportez vous au TP précédent (<a class="el" href="tp-UF.html#tp-UF-3-3">3.3 Utilisation de cette structure pour le découpage en composantes connexes.</a>).</p>
<p>Avec <code>gnuplot</code> par exemple, vous tracerez les courbes suivantes en <b>log-scale</b> afin de mesurer l'efficacité de vos algorithmes ainsi que le nombre de sommets. Prenez un nombre suffisant d'échantillons.</p>
<ul>
<li>nb de sommets enveloppe convexe en fonction du nombre de points (points dans <b>disque</b>)</li>
<li>temps d'exécution Graham en fonction du nombre de points (points dans <b>disque</b>)</li>
<li>nb de sommets enveloppe convexe en fonction du nombre de points (points dans <b>losange</b>)</li>
<li>temps d'exécution Graham en fonction du nombre de points (points dans <b>losange</b>)</li>
</ul>
<p>Pour le disque, déterminer (empiriquement) la puissance <em>a</em> tel que \( s = n^a \), où <em>s</em> est le nombre de sommets et <em>n</em> le nombre de points.</p>
<p>Pour le losange qu'observez-vous ?</p>
<h1><a class="anchor" id="tp-CVX-4"></a>
4 - Algorithme de Jarvis</h1>
<p>L'algorithme de Jarvis est en un sens plus simple que l'algorithme de Graham et, dans certains cas, peut être plus rapide. Sa complexité dépend de la <b>sortie</b> du problème, ici du nombre de sommets \( s \) de l'enveloppe convexe. Plus précisément, la complexité est dans \( \Theta(n s) \). L'idée est extrêmement simple. On construit d'abord la partie droite de l'enveloppe convexe. On part du sommet le plus bas. Puis on recherche parmi tous les autres points plus haut le sommet qui a l'angle polaire le plus faible par rapport au point initial. Il fait donc aussi partie de l'enveloppe convexe. On procède de la même manière ensuite en recherchant le sommet plus haut qui a l'angle polaire le plus faible par rapport au deuxième point. Et ainsi de suite jusqu'au sommet le plus haut de l'enveloppe convexe. Pour la partie gauche de l'enveloppe convexe, on procède similairement.</p>
<p>Il est clair qu'un tel algorithme prend un temps \( \Theta(n) \) pour chaque sommet de l'enveloppe convexe. D'où la complexité globale.</p>
<dl class="section note"><dt>Note</dt><dd>On pourrait mesurer l'angle polaire. En fait on cherche le sommet de coordonnée y plus grande qui est toujours à droite des segments orientés partant du sommet précédent de l'enveloppe convexe. On peut donc utiliser <code>Orientation</code> aussi. Comme on ne peut que chercher un point plus haut que le précédent, on coupe la construction de l'enveloppe convexe en partie gauche et droite.</dd></dl>
<p>Implémentez l'algorithme de Jarvis. Il devrait être assez lent sur la forme "disque" et être le plus efficace sur la forme "losange".</p>
<p>Vous tracerez les courbes suivantes en <b>log-scale</b> afin de mesurer l'efficacité de vos algorithmes. Prenez un nombre suffisant d'échantillons.</p>
<ul>
<li>temps d'exécution Jarvis en fonction du nombre de points (points dans <b>disque</b>)</li>
<li>temps d'exécution Jarvis en fonction du nombre de points (points dans <b>losange</b>)</li>
</ul>
<h1><a class="anchor" id="tp-CVX-5"></a>
5 - Remise du tp</h1>
<ul>
<li>Ce TP peut être fait par binôme.</li>
<li>Vous m'enverrez votre première version du TP à la <b>fin</b> <b>de</b> <b>la</b> <b>séance</b>, puis la version finale au plus tard <b>dimanche</b> <b>7</b> <b>avril</b> <b>2023</b> <b>minuit</b>, via <a href="https://lama.univ-savoie.fr/TPLab">TPLab</a>. Il faudra une archive nommée TP2-[votre ou vos nom(s)] contenant tous les fichiers sources, entêtes, makefile.</li>
<li>Vous <b>devez</b> inclure un petit compte-rendu précisant l'état d'avancement (ce qui marche, ce qui marche à moitié, et ce qui ne marche pas), qui donnera les graphiques demandés, et qui pourra montrer quelques exemples de calcul d'enveloppe convexe.</li>
<li>Bien entendu, il faut que vos programmes compilent sous Linux. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
