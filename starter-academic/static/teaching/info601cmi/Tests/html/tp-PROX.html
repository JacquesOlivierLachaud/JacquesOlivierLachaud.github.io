<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INFO607: Structures pour les requêtes de localisation et proximité, Arbres k-D, Collisions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INFO607
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Structures pour les requêtes de localisation et proximité, Arbres k-D, Collisions</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tp-PROX-1">1 - Objectifs</a></li>
<li class="level1"><a href="#tp-PROX-2">2 - Génération de particules plus funky</a></li>
<li class="level1"><a href="#tp-PROX-3">3 - Ajout d&#39;obstacles</a><ul><li class="level2"><a href="#tp-PROX-3-1">3.1 - Création d&#39;une structure obstacle</a></li>
<li class="level2"><a href="#tp-PROX-3-2">3.2 - Clic sur la zone de dessin</a></li>
<li class="level2"><a href="#tp-PROX-3-3">3.3 - Les obstacles bloquent les particules.</a></li>
<li class="level2"><a href="#tp-PROX-3-4">3.4 - Les particules rebondissent sur les obstacles.</a></li>
</ul>
</li>
<li class="level1"><a href="#tp-PROX-4">4 - Une structure pour accélerer les tests de collision</a><ul><li class="level2"><a href="#tp-PROX-4-1">4.1 - Création de l&#39;arbre k-D des obstacles</a></li>
<li class="level2"><a href="#tp-PROX-4-2">4.2 - Détection des obstacles proches de vos particules</a></li>
<li class="level2"><a href="#tp-PROX-4-3">4.3 - Pour aller un peu plus loin</a></li>
</ul>
</li>
<li class="level1"><a href="#tp-PROX-5">5 - Remise du tp</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tp-PROX-1"></a>
1 - Objectifs</h1>
<p>L'objectif de ce TP est de vous faire mettre en oeuvre des algorithmes efficaces pour détecter les collisions entre objets dans le plan, au travers d'une application de simulation de déplacement de particules.</p>
<p>Un premier moteur temps-réel de visualisation, basé sur la bibliothèque GTK (<a href="http://www.gtk.org">http://www.gtk.org</a>), vous est fourni. Vous vous en êtes déjà servi en cours de C, INFO505 (<a href="http://www.lama.univ-savoie.fr/~lachaud/Cours/INFO504/Tests/doc/html/tp3.html">http://www.lama.univ-savoie.fr/~lachaud/Cours/INFO504/Tests/doc/html/tp3.html</a>) pour le TP Tetris graphique. Vous reconnaîtrez l'utilisation des timers et des zones de dessins pour une application animée en temps-réel.</p>
<p>Pas mal de choses vous sont déjà fournis, histoire de se concentrer un peu plus sur les requêtes de proximité. On vous donne les fichiers suivants:</p>
<ul>
<li><a class="el" href="main_8c.html">main.c</a> : contient l'IHM, la partie temps-réel, le calcul de la dynamique des objets, l'affichage.</li>
<li><a class="el" href="TP-Proximity_2points_8h.html">points.h</a>, <a class="el" href="TP-Proximity_2points_8c.html">points.c</a> : la structure de point "simple", avec quelques opérations point/vecteur.</li>
<li><a class="el" href="particules_8h.html">particules.h</a>, <a class="el" href="particules_8c.html">particules.c</a> : la structure de particules qui mémorise la position, le vecteur vitesse, les forces, la masse. On dispose aussi d'une structure de tableau dynamique de ces particules.</li>
<li><a class="el" href="forces_8h.html">forces.h</a>, <a class="el" href="forces_8c.html">forces.c</a> : contient la structure pour représenter des forces, ici la simple gravité.</li>
</ul>
<p>Prenez d'abord le temps de bien comprendre le code écrit. Un Makefile vous est aussi fourni.</p>
<p>Il s'exécute ainsi: </p><pre class="fragment">prompt$ make
prompt$ ./main</pre><p>L'exécution du programme donne quelque chose comme ceci:</p>
<div class="image">
<img src="proximity-0.png" alt=""/>
<div class="caption">
Programme initial. Des particules sont générés avec un vecteur initial et sont soumis à la gravité.</div></div>
<p>Les points suivants sont à mémoriser pour réaliser le tp:</p>
<ul>
<li>Toute la logique du programme est gérée par la fonction <a class="el" href="main_8c.html#a14d6410fc79e36193810f1404ea6c48a">tic</a>, qui est appelée toutes les DT secondes (20 ms). Celle-ci s'occupe de générer de nouvelles particules, calculer les forces sur les particules, les déplacer, et demander le réaffichage de la zone de dessin.</li>
<li>Le contexte mémorise comme d'habitude tous les éléments importants de l'application.</li>
<li><p class="startli">Les particules ont leurs coordonnées <b>réelles</b> dans une fenêtre [-1:1]x[-1:1]. Il faut donc transformer leurs coordonnées avant affichage en coordonnées <b>pixel</b>, ici [0:499]x[0:499], car la zone de dessin fait 500x500. Grâce à cela, si vous voulez augmenter ou diminuer la taille de la zone de dessin, vous pouvez le faire très simplement en modifiant le contexte.</p>
<dl class="section note"><dt>Note</dt><dd>Les fonctions ci-dessous, déjà écrites, vous permettent de faire le changement de repère, coordonnées réelles &lt;-&gt; coordonnées pixel.</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structSPoint.html">Point</a>  <a class="code hl_function" href="main_8c.html#ab5e509fc9a740c06feb572c9d0be4f4d">point2DrawingAreaPoint</a>( <a class="code hl_struct" href="structSContexte.html">Contexte</a>* pCtxt, <a class="code hl_struct" href="structSPoint.html">Point</a> p );    <span class="comment">//&lt; point réel      -&gt; pixel</span></div>
<div class="line"><span class="keywordtype">double</span> <a class="code hl_function" href="main_8c.html#a6b7a753e7dff4175d441f79829ceea72">length2DrawingAreaLength</a>( <a class="code hl_struct" href="structSContexte.html">Contexte</a>* pCtxt, <span class="keywordtype">double</span> l ); <span class="comment">//&lt; longueur réelle -&gt; longueur en pixels</span></div>
<div class="line"><a class="code hl_struct" href="structSPoint.html">Point</a>  <a class="code hl_function" href="main_8c.html#acaafb5db173fe34f4ea64ce334cdf69d">drawingAreaPoint2Point</a>( <a class="code hl_struct" href="structSContexte.html">Contexte</a>* pCtxt, <a class="code hl_struct" href="structSPoint.html">Point</a> p );    <span class="comment">//&lt; pixel           -&gt; point réel</span></div>
<div class="ttc" id="amain_8c_html_a6b7a753e7dff4175d441f79829ceea72"><div class="ttname"><a href="main_8c.html#a6b7a753e7dff4175d441f79829ceea72">length2DrawingAreaLength</a></div><div class="ttdeci">double length2DrawingAreaLength(Contexte *pCtxt, double l)</div><div class="ttdef"><b>Definition</b> <a href="main_8c_source.html#l00200">main.c:200</a></div></div>
<div class="ttc" id="amain_8c_html_ab5e509fc9a740c06feb572c9d0be4f4d"><div class="ttname"><a href="main_8c.html#ab5e509fc9a740c06feb572c9d0be4f4d">point2DrawingAreaPoint</a></div><div class="ttdeci">Point point2DrawingAreaPoint(Contexte *pCtxt, Point p)</div><div class="ttdef"><b>Definition</b> <a href="main_8c_source.html#l00192">main.c:192</a></div></div>
<div class="ttc" id="amain_8c_html_acaafb5db173fe34f4ea64ce334cdf69d"><div class="ttname"><a href="main_8c.html#acaafb5db173fe34f4ea64ce334cdf69d">drawingAreaPoint2Point</a></div><div class="ttdeci">Point drawingAreaPoint2Point(Contexte *pCtxt, Point p)</div><div class="ttdef"><b>Definition</b> <a href="main_8c_source.html#l00205">main.c:205</a></div></div>
<div class="ttc" id="astructSContexte_html"><div class="ttname"><a href="structSContexte.html">SContexte</a></div><div class="ttdef"><b>Definition</b> <a href="union-find_8c_source.html#l00013">union-find.c:13</a></div></div>
<div class="ttc" id="astructSPoint_html"><div class="ttname"><a href="structSPoint.html">SPoint</a></div><div class="ttdef"><b>Definition</b> <a href="TP-Convex_2points_8h_source.html#l00004">points.h:4</a></div></div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="tp-PROX-2"></a>
2 - Génération de particules plus funky</h1>
<p>Pour rendre le reste du TP moins déterministe et plus joli visuellement, on introduit de l'aléatoire dans la génération des particules. Créez donc une fonction <code>fontaineVariable</code> par exemple avec le prototype ci-dessous:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> fontaineVariable( <a class="code hl_struct" href="structSContexte.html">Contexte</a>* pCtxt, </div>
<div class="line">                       <span class="keywordtype">double</span> p, <span class="keywordtype">double</span> var,  </div>
<div class="line">                       <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> vx, <span class="keywordtype">double</span> vy, <span class="keywordtype">double</span> m );</div>
</div><!-- fragment --><p>Par rapport à <a class="el" href="main_8c.html#a340417499f2b4c244f7cfe36c5effb58">fontaine</a>, le paramètre <em>var</em> donne la variabilité sur la vitesse initiale et sur la masse. Par exemple si <em>var</em> vaut 0.1 alors la composante x de la vitesse à une valeur aléatoire entre (1-0.1)*vx et (1+0.1)*vx, pareil pour la composante y. Utiliser dans le générateur aléatoire <code>rand</code> pour créer des particules avec la variabilité <em>var</em>.</p>
<p>Par exemple, si vous placez dans <a class="el" href="main_8c.html#a14d6410fc79e36193810f1404ea6c48a">tic</a> les lignes ci-dessous pour générer les particules:</p>
<div class="fragment"><div class="line">fontaineVariable( pCtxt, 0.2, 0.1, -0.5, 0.5, 0.3, 0.3, 1.0 );</div>
<div class="line">fontaineVariable( pCtxt, 0.25, 0.2, -0.5, 0.5, 0.3, 0.3, 0.5 );</div>
<div class="line">fontaineVariable( pCtxt, 0.6, 0.18, -0.5, 0.5, 0.3, 0.3, 2.5 );</div>
</div><!-- fragment --><p>Cela donne à peu près le résultat suivant:</p>
<div class="image">
<img src="proximity-1.png" alt=""/>
<div class="caption">
Les particules sont maintenant générées avec un vecteur initial légèrement aléatoire et sont soumis à la gravité.</div></div>
<dl class="section note"><dt>Note</dt><dd>L'expression <code>rand() / (double) RAND_MAX</code> vous retourne un nombre aléatoire entre 0 et 1. Faites donc une fonction <code>rand01()</code> qui vous retourne un nombre entre 0 et 1 ainsi:</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> rand01() { <span class="keywordflow">return</span> (<span class="keywordtype">double</span>) rand() / (double) RAND_MAX; }</div>
</div><!-- fragment --><h1><a class="anchor" id="tp-PROX-3"></a>
3 - Ajout d'obstacles</h1>
<p>On va laisser l'utilisateur rajouter des obstacles (des boules) infranchissables pour nos particules, qui vont rebondir contre. Ces obstacles seront placés dans un premier temps dans un simple tableau de taille variable (comme les particules). Pour détecter si une particule rencontre un obstacle, on parcourera tous les obstacles et on vérifiera s'il y a eu collision. Dans la section suivante, on verra comment utiliser les arbres k-D pour limiter le nombre de tests de collision.</p>
<h2><a class="anchor" id="tp-PROX-3-1"></a>
3.1 - Création d'une structure obstacle</h2>
<p>On va créer des obstacles simples pour les particules. Ce seront des disques de rayon donné. Créez deux fichiers <code>obstacles.h</code> et <code>obstacles.c</code> pour stocker les structures de données associées aux obstacles. Un Obstacle sera donc</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> { DISQUE } ObstacleType;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>SObstacle {</div>
<div class="line">  ObstacleType type; <span class="comment">//&lt; Le type de l&#39;obstacle. Ici on aura juste des DISQUEs.</span></div>
<div class="line">  <span class="keywordtype">double</span> x[ <a class="code hl_define" href="TP-Proximity_2points_8h.html#ac25189db92959bff3c6c2adf4c34b50a">DIM</a> ];   <span class="comment">//&lt; Les coordonnées du centre de l&#39;obstacle.</span></div>
<div class="line">  <span class="keywordtype">double</span> r;          <span class="comment">//&lt; Le rayon de l&#39;obstacle</span></div>
<div class="line">  <span class="keywordtype">double</span> att;        <span class="comment">//&lt; le facteur d&#39;atténuation de l&#39;obstacle (0.0 amortisseur parfait, 1.0 rebondisseur parfait, 3.0 &quot;bumper&quot; comme dans un flipper.)</span></div>
<div class="line">  <span class="keywordtype">double</span> cr, cg, cb; <span class="comment">//&lt; couleurs rgb de l&#39;obstacle.</span></div>
<div class="line">} Obstacle;</div>
<div class="ttc" id="aTP-Proximity_2points_8h_html_ac25189db92959bff3c6c2adf4c34b50a"><div class="ttname"><a href="TP-Proximity_2points_8h.html#ac25189db92959bff3c6c2adf4c34b50a">DIM</a></div><div class="ttdeci">#define DIM</div><div class="ttdef"><b>Definition</b> <a href="TP-Proximity_2points_8h_source.html#l00005">points.h:5</a></div></div>
</div><!-- fragment --><p>Sinon, vous créerez une structure <code>TabObstacle</code> complétement similaire à <a class="el" href="particules_8h.html#a302a353c7d4a837ada9884edb16f724f">TabParticules</a>, afin de stocker une liste d'obstacles. (Ab)usez du copier-coller pour faire les fonctions suivantes:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TabObstacles_init( TabObstacles* tab );                  <span class="comment">//&lt; initialise le tableau dyn. d&#39;obstacles</span></div>
<div class="line"><span class="keywordtype">void</span> TabObstacles_ajoute( TabObstacles* tab, Obstacle p );    <span class="comment">//&lt; ajoute l&#39;obstacle p</span></div>
<div class="line"><span class="keywordtype">void</span> TabObstacles_set( TabObstacles* tab, <span class="keywordtype">int</span> i, Obstacle p );<span class="comment">//&lt; met à jour le i-ème obstacle à p</span></div>
<div class="line">Obstacle TabObstacles_get( TabObstacles* tab, <span class="keywordtype">int</span> i );        <span class="comment">//&lt; retourne le i-ème obstacle</span></div>
<div class="line"><span class="keywordtype">int</span> TabObstacles_nb( TabObstacles* tab );                     <span class="comment">//&lt; retourne le nombre d&#39;obstacles</span></div>
<div class="line">Obstacle* TabObstacles_ref( TabObstacles* tab, <span class="keywordtype">int</span> i );       <span class="comment">//&lt; retourne l&#39;adresse du i-ème obstacle</span></div>
<div class="line"><span class="keywordtype">void</span> TabObstacles_termine( TabObstacles* tab );               <span class="comment">//&lt; libère les obstacles et termine le tableau</span></div>
<div class="line"><span class="keywordtype">void</span> TabObstacles_agrandir( TabObstacles* tab );              <span class="comment">//&lt; double la taille du tableau dynamique</span></div>
</div><!-- fragment --><p>N'oubliez pas de rajouter la compilation de <code>obstacles.c</code> dans le <code>Makefile</code>, ainsi que l'édition des liens de <code>obstacles.o</code>.</p>
<h2><a class="anchor" id="tp-PROX-3-2"></a>
3.2 - Clic sur la zone de dessin</h2>
<p>Pour ajouter des obstacles pour les particules, on va simplement demander à l'utilisateur de faire un clic gauche dans la zone de dessin. Pour capter un clic souris dans la zone de dessin il faut rajouter les lignes suivantes dans <a class="el" href="union-find_8c.html#a86e86ac233f7a07f1d6d504cd9da33d0">creerIHM</a> :</p>
<div class="fragment"><div class="line">g_signal_connect( G_OBJECT( pCtxt-&gt;drawing_area ), <span class="stringliteral">&quot;button_press_event&quot;</span>,</div>
<div class="line">                  G_CALLBACK( mouse_clic_reaction ), pCtxt );</div>
<div class="line">gtk_widget_set_events ( pCtxt-&gt;drawing_area, GDK_EXPOSURE_MASK</div>
<div class="line">                        | GDK_LEAVE_NOTIFY_MASK</div>
<div class="line">                        | GDK_BUTTON_PRESS_MASK</div>
<div class="line">                        | GDK_POINTER_MOTION_MASK</div>
<div class="line">                        | GDK_POINTER_MOTION_HINT_MASK);</div>
</div><!-- fragment --><p>La réaction appelée est la fonction <code>mouse_clic_reaction</code>, qui aura la forme suivante:</p>
<div class="fragment"><div class="line">gboolean mouse_clic_reaction( GtkWidget *widget, GdkEventButton *event, gpointer data )</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structSContexte.html">Contexte</a>* pCtxt = (<a class="code hl_struct" href="structSContexte.html">Contexte</a>*) data;</div>
<div class="line">  <span class="keywordtype">int</span> button = <span class="keyword">event</span>-&gt;button; <span class="comment">// 1 is left button</span></div>
<div class="line">  <span class="keywordflow">if</span> ( button != 1 ) <span class="keywordflow">return</span> TRUE;</div>
<div class="line">  <span class="keywordtype">int</span> x = <span class="keyword">event</span>-&gt;x;</div>
<div class="line">  <span class="keywordtype">int</span> y = <span class="keyword">event</span>-&gt;y;</div>
<div class="line">  ... <span class="comment">// A compléter</span></div>
<div class="line">  <span class="keywordflow">return</span> TRUE;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Il vous reste donc à:</p>
<ul>
<li>rajouter au contexte un champ <code>TabObstacles</code> <code>TabO</code>, et l'initialiser dans le <a class="el" href="union-find_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>.</li>
<li>compléter <code>mouse_clic_reaction</code> pour qu'il ajoute dans <code>TabO</code> un nouvel <code>Obstacle</code> aux coordonnées cliquées. Attention il faut utiliser la fonction <a class="el" href="main_8c.html#acaafb5db173fe34f4ea64ce334cdf69d">drawingAreaPoint2Point</a> pour convertir les coordonnées <b>pixel</b> en coordonnées <b>réelles</b>. On choisira dans un premier temps un rayon réel <code>r</code> de 0.05, et une atténuation <code>att</code> de 0.6.</li>
<li>rajouter quelques lignes dans la fonction <a class="el" href="convex_8c.html#a23f093136857a9d27c727162c8ece026">on_draw</a> pour afficher tous les obstacles du contexte. N'oubliez pas d'utiliser la fonction de conversion de longueur réelle vers longueur pixel.</li>
</ul>
<div class="image">
<img src="proximity-3-2.png" alt=""/>
<div class="caption">
Les obstacles mis par l'utilisateur sont visibles.</div></div>
<h2><a class="anchor" id="tp-PROX-3-3"></a>
3.3 - Les obstacles bloquent les particules.</h2>
<p>Vous allez maintenant modifier la fonction <a class="el" href="main_8c.html#aa7e673a44be06db2002069efb6bedd06">deplaceParticule</a> pour qu'elle bloque la particule si elle rencontre un obstacle. Pour faire simple dans un premier temps, vous parcourez tout le tableau d'obstacles. Dès que la distance entre les nouvelles coordonnées de la particule et un obstacle est plus petite que le rayon de l'obstacle (ici 0.05), cela veut dire que la particule est dans l'obstacle. Dans ce cas-là, vous vous contenterez de mettre à zéro la vitesse de la particule. Si la particule ne collisionne avec aucun obstacle, alors vous mettez à jour sa position comme dans la fonction <a class="el" href="main_8c.html#aa7e673a44be06db2002069efb6bedd06">deplaceParticule</a> initiale.</p>
<dl class="section note"><dt>Note</dt><dd>Vous avez déjà une fonction <code>distance</code> ou une fonction <code>Point_distance</code> dans <a class="el" href="TP-Proximity_2points_8c.html">points.c</a> pour calculer les distances</dd></dl>
<p>Voilà à quoi ressemble l'application maintenant:</p>
<div class="image">
<img src="proximity-3-3.png" alt=""/>
<div class="caption">
Les obstacles mis par l'utilisateur bloquent les particules.</div></div>
<p>Vous voyez maintenant le nombre de tests "distance" réalisés par seconde par l'application. Ce nombre est directement proportionnel au nombre d'obstacles et au nombre de particules.</p>
<h2><a class="anchor" id="tp-PROX-3-4"></a>
3.4 - Les particules rebondissent sur les obstacles.</h2>
<p>Pour que l'application soit plus réaliste, on va simuler un comportement physique des particules. En général, on rebondit sur un obstacle, comme les boules au billard rebondissent sur les côtés. Tout le calcul du rebond vous est donné dans la fonction suivante. Le principe est de simuler un rebond parfait, puis d'atténuer la force du rebond.</p>
<div class="fragment"><div class="line"><span class="comment">// Cette fonction n&#39;est appelé que si la particule p déplacée (p.x +</span></div>
<div class="line"><span class="comment">// DT*p.v) est à l&#39;intérieur du disque B_r(center).  Elle retourne</span></div>
<div class="line"><span class="comment">// alors le rebond de la particule calculé pour cet obstacle circulaire</span></div>
<div class="line"><span class="comment">// (nouveau x, nouveau v) en fonction de l&#39;atténuation choisie.  En</span></div>
<div class="line"><span class="comment">// sortie, la particule est en dehors de l&#39;obstacle.</span></div>
<div class="line"><a class="code hl_struct" href="structSParticule.html">Particule</a> calculRebond( <a class="code hl_struct" href="structSParticule.html">Particule</a> p, <a class="code hl_struct" href="structSPoint.html">Point</a> center, <span class="keywordtype">double</span> r, <span class="keywordtype">double</span> att )</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structSPoint.html">Point</a> xd, v;</div>
<div class="line">  <span class="comment">// Calcule la nouvelle position xd (sans collision) et le vecteur vitesse.</span></div>
<div class="line">  xd.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 0 ] = p.<a class="code hl_variable" href="structSParticule.html#a3dce37ad974d5d2eb76ce06dd8678772">x</a>[ 0 ] + <a class="code hl_define" href="main_8c.html#a943f07034774ef1261d62cd0d3d1fec9">DT</a> * p.<a class="code hl_variable" href="structSParticule.html#ad5a127d2acb27eb325c45e00b0b93731">v</a>[ 0 ]; </div>
<div class="line">  xd.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 1 ] = p.<a class="code hl_variable" href="structSParticule.html#a3dce37ad974d5d2eb76ce06dd8678772">x</a>[ 1 ] + <a class="code hl_define" href="main_8c.html#a943f07034774ef1261d62cd0d3d1fec9">DT</a> * p.<a class="code hl_variable" href="structSParticule.html#ad5a127d2acb27eb325c45e00b0b93731">v</a>[ 1 ];</div>
<div class="line">  v.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 0 ] = p.<a class="code hl_variable" href="structSParticule.html#ad5a127d2acb27eb325c45e00b0b93731">v</a>[ 0 ];</div>
<div class="line">  v.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 1 ] = p.<a class="code hl_variable" href="structSParticule.html#ad5a127d2acb27eb325c45e00b0b93731">v</a>[ 1 ];</div>
<div class="line">  <a class="code hl_struct" href="structSPoint.html">Point</a> u = <a class="code hl_function" href="TP-Proximity_2points_8c.html#a0fbf3f1f13fa8cdecde13ec674ab0d91">Point_normalize</a>( <a class="code hl_function" href="TP-Proximity_2points_8c.html#ae78bfa9a21edc144d5a8f31d184ac9ca">Point_sub</a>( xd, center ) );</div>
<div class="line">  <span class="keywordtype">double</span> l = <a class="code hl_function" href="TP-Proximity_2points_8c.html#ada7bc0a72dfba0e1b003e73ba877930a">Point_norm</a>( <a class="code hl_function" href="TP-Proximity_2points_8c.html#ae78bfa9a21edc144d5a8f31d184ac9ca">Point_sub</a>( xd, center ) );</div>
<div class="line">  <a class="code hl_struct" href="structSPoint.html">Point</a> xm = <a class="code hl_function" href="TP-Proximity_2points_8c.html#af27bff76530de5a7b01a56e99a53ec01">Point_add</a>( center, <a class="code hl_function" href="TP-Proximity_2points_8c.html#a55e54dbc9864d8ed6471238cbf258a38">Point_mul</a>( r + att*( r - l), u ) );</div>
<div class="line">  <span class="keywordtype">double</span> proj_v = <a class="code hl_function" href="TP-Proximity_2points_8c.html#a7922f9fb48eafdb782a2d4287b568a35">Point_dot</a>( v, u );</div>
<div class="line">  <span class="comment">// réalise le rebond si la particule est bien en train de rentrer dans l&#39;obstacle. </span></div>
<div class="line">  <span class="keywordflow">if</span> ( proj_v &lt; 0.0 ) </div>
<div class="line">    v = <a class="code hl_function" href="TP-Proximity_2points_8c.html#ae78bfa9a21edc144d5a8f31d184ac9ca">Point_sub</a>( v, <a class="code hl_function" href="TP-Proximity_2points_8c.html#a55e54dbc9864d8ed6471238cbf258a38">Point_mul</a>( 2.0 * proj_v, u ) );</div>
<div class="line">  <a class="code hl_struct" href="structSParticule.html">Particule</a> p_out = p;</div>
<div class="line">  p_out.<a class="code hl_variable" href="structSParticule.html#a3dce37ad974d5d2eb76ce06dd8678772">x</a>[ 0 ] = xm.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 0 ];</div>
<div class="line">  p_out.<a class="code hl_variable" href="structSParticule.html#a3dce37ad974d5d2eb76ce06dd8678772">x</a>[ 1 ] = xm.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 1 ];</div>
<div class="line">  p_out.<a class="code hl_variable" href="structSParticule.html#ad5a127d2acb27eb325c45e00b0b93731">v</a>[ 0 ] = att*v.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 0 ];</div>
<div class="line">  p_out.<a class="code hl_variable" href="structSParticule.html#ad5a127d2acb27eb325c45e00b0b93731">v</a>[ 1 ] = att*v.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 1 ];</div>
<div class="line">  <span class="keywordflow">return</span> p_out;</div>
<div class="line">}</div>
<div class="ttc" id="aTP-Proximity_2points_8c_html_a0fbf3f1f13fa8cdecde13ec674ab0d91"><div class="ttname"><a href="TP-Proximity_2points_8c.html#a0fbf3f1f13fa8cdecde13ec674ab0d91">Point_normalize</a></div><div class="ttdeci">Point Point_normalize(Point p)</div><div class="ttdef"><b>Definition</b> <a href="TP-Proximity_2points_8c_source.html#l00046">points.c:46</a></div></div>
<div class="ttc" id="aTP-Proximity_2points_8c_html_a55e54dbc9864d8ed6471238cbf258a38"><div class="ttname"><a href="TP-Proximity_2points_8c.html#a55e54dbc9864d8ed6471238cbf258a38">Point_mul</a></div><div class="ttdeci">Point Point_mul(double c, Point p)</div><div class="ttdef"><b>Definition</b> <a href="TP-Proximity_2points_8c_source.html#l00019">points.c:19</a></div></div>
<div class="ttc" id="aTP-Proximity_2points_8c_html_a7922f9fb48eafdb782a2d4287b568a35"><div class="ttname"><a href="TP-Proximity_2points_8c.html#a7922f9fb48eafdb782a2d4287b568a35">Point_dot</a></div><div class="ttdeci">double Point_dot(Point p, Point q)</div><div class="ttdef"><b>Definition</b> <a href="TP-Proximity_2points_8c_source.html#l00026">points.c:26</a></div></div>
<div class="ttc" id="aTP-Proximity_2points_8c_html_ada7bc0a72dfba0e1b003e73ba877930a"><div class="ttname"><a href="TP-Proximity_2points_8c.html#ada7bc0a72dfba0e1b003e73ba877930a">Point_norm</a></div><div class="ttdeci">double Point_norm(Point p)</div><div class="ttdef"><b>Definition</b> <a href="TP-Proximity_2points_8c_source.html#l00036">points.c:36</a></div></div>
<div class="ttc" id="aTP-Proximity_2points_8c_html_ae78bfa9a21edc144d5a8f31d184ac9ca"><div class="ttname"><a href="TP-Proximity_2points_8c.html#ae78bfa9a21edc144d5a8f31d184ac9ca">Point_sub</a></div><div class="ttdeci">Point Point_sub(Point p, Point q)</div><div class="ttdef"><b>Definition</b> <a href="TP-Proximity_2points_8c_source.html#l00005">points.c:5</a></div></div>
<div class="ttc" id="aTP-Proximity_2points_8c_html_af27bff76530de5a7b01a56e99a53ec01"><div class="ttname"><a href="TP-Proximity_2points_8c.html#af27bff76530de5a7b01a56e99a53ec01">Point_add</a></div><div class="ttdeci">Point Point_add(Point p, Point q)</div><div class="ttdef"><b>Definition</b> <a href="TP-Proximity_2points_8c_source.html#l00012">points.c:12</a></div></div>
<div class="ttc" id="amain_8c_html_a943f07034774ef1261d62cd0d3d1fec9"><div class="ttname"><a href="main_8c.html#a943f07034774ef1261d62cd0d3d1fec9">DT</a></div><div class="ttdeci">#define DT</div><div class="ttdef"><b>Definition</b> <a href="main_8c_source.html#l00027">main.c:27</a></div></div>
<div class="ttc" id="astructSParticule_html"><div class="ttname"><a href="structSParticule.html">SParticule</a></div><div class="ttdef"><b>Definition</b> <a href="particules_8h_source.html#l00008">particules.h:8</a></div></div>
<div class="ttc" id="astructSParticule_html_a3dce37ad974d5d2eb76ce06dd8678772"><div class="ttname"><a href="structSParticule.html#a3dce37ad974d5d2eb76ce06dd8678772">SParticule::x</a></div><div class="ttdeci">double x[DIM]</div><div class="ttdef"><b>Definition</b> <a href="particules_8h_source.html#l00009">particules.h:9</a></div></div>
<div class="ttc" id="astructSParticule_html_ad5a127d2acb27eb325c45e00b0b93731"><div class="ttname"><a href="structSParticule.html#ad5a127d2acb27eb325c45e00b0b93731">SParticule::v</a></div><div class="ttdeci">double v[DIM]</div><div class="ttdef"><b>Definition</b> <a href="particules_8h_source.html#l00010">particules.h:10</a></div></div>
<div class="ttc" id="astructSPoint_html_ad39d5d98239044aba9f723024d07d6bd"><div class="ttname"><a href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">SPoint::x</a></div><div class="ttdeci">double x</div><div class="ttdef"><b>Definition</b> <a href="TP-Convex_2points_8h_source.html#l00005">points.h:5</a></div></div>
</div><!-- fragment --><p>Il vous reste donc à modifier <a class="el" href="main_8c.html#aa7e673a44be06db2002069efb6bedd06">deplaceParticule</a> pour qu'il utilise <code>calculRebond</code> en cas de rencontre avec un obstacle. Pour simplifier, on supposera que la particule rebondit sur le premier obstacle rencontré (les autres sont ignorés).</p>
<dl class="section note"><dt>Note</dt><dd>Dans une simulation plus réaliste, on calcule toutes les collisions, puis on fait la moyenne des résultats de toutes les collisions. Cela donne un comportement un peu plus stable.</dd></dl>
<div class="image">
<img src="proximity-3-4.png" alt=""/>
<div class="caption">
Les particules rebondissent sur les obstacles placés par l'utilisateur.</div></div>
<dl class="section note"><dt>Note</dt><dd>Vous pouvez déjà vous amuser en changeant l'atténuation pour voir l'effet sur le rebond des particules.</dd></dl>
<h1><a class="anchor" id="tp-PROX-4"></a>
4 - Une structure pour accélerer les tests de collision</h1>
<p>On voit que notre simulateur doit faire un nombre considérable de tests de collision, dès lors qu'on met un certain nombre d'obstacles. Ce serait encore plus vrai si on gérait les collisions entre particules. Comme nos obstacles sont statiques (ne se déplacent pas), on va les structurer dans un arbre k-D. Du coup on n'aura pas besoin de tester pour chaque particule ses collisions possibles avec tous les obstacles.</p>
<p>Les arbres k-D sont des arbres binaires avec juste un fonctionnement un peu particulier. On vous donne donc les fichiers <a class="el" href="arbre_8h.html">arbre.h</a> et <a class="el" href="arbre_8c.html">arbre.c</a>, qui vous fournissent la structure <a class="el" href="arbre_8h.html#acf88594ceae6b727346db9a9f8c46577">Arbre</a> et des fonctions pour créer, modifier ou se déplacer dans les arbres.</p>
<p>Les arbres k-D sont décrits dans la <a href="http://www.lama.univ-savoie.fr/pagesmembres/lachaud/Cours/INFO602/Cours/lesson-5.pdf">Leçon 5</a> d'INFO607. Les arbres k-D qui sont des arbres binaires. Chaque point situé à un noeud de l'arbre coupe l'espace en deux régions selon un plan qui dépend de la profondeur dans l'arbre. Ainsi les noeuds de profondeur 0 coupe l'espace selon leur première coordonnée \( x \), les noeuds de profondeur 1 coupe l'espace selon leur deuxième coordonnée \( y \), les noeuds de profondeur 2 coupe l'espace selon leur troisième coordonnée \( z
   \) en 3D, etc, en recommançant à la première coordonnée après avoir coupé selon la dernière.</p>
<p>Il est facile d'équilibrer les arbres k-D. Il suffit en effet à chaque fois de choisir comme point de découpe le point situé à la médiane des points restants selon la direction de découpe. Une illustration est donnée ci-dessous.</p>
<div class="image">
<img src="fig-kdtree.png" alt="" width="60%"/>
<div class="caption">
Illustration de la structure d'un k-d-tree.</div></div>
<h2><a class="anchor" id="tp-PROX-4-1"></a>
4.1 - Création de l'arbre k-D des obstacles</h2>
<p>On va donc enrichir le module <a class="el" href="arbre_8h.html">arbre.h</a> / <a class="el" href="arbre_8c.html">arbre.c</a> . Vous définirez le type <a class="el" href="arbre_8h.html#afe61909d742430b06f9331e359e36c4f">Donnee</a> comme étant un <code>Obstacle</code>. Il s'agira ensuite d'écrire la fonction suivante, en utilisant bien sûr les fonctions données <a class="el" href="arbre_8c.html#a10c6291ea5f5fb51509af06bfaf10a14">ArbreVide</a>, <a class="el" href="arbre_8c.html#abfbf741907803614619e1d14959261b8">Creer0</a>, <a class="el" href="arbre_8c.html#a691ba6bfe019008f3b9f05388c97f0b0">Creer2</a> :</p>
<div class="fragment"><div class="line"><span class="comment">// Si T est un Obstacle* pointant vers la première case d&#39;un tableau</span></div>
<div class="line"><span class="comment">// d&#39;Obstacle, i &lt; j désignent les indices de début et de fin dans le</span></div>
<div class="line"><span class="comment">// tableau T, a est l&#39;axe (0 ou 1) utilisé pour découper le plan.</span></div>
<div class="line"><span class="comment">// Alors cette fonction crée et retourne l&#39;arbre binaire (arbre k-D)</span></div>
<div class="line"><span class="comment">// stockant tous les obstacles spécifiés.</span></div>
<div class="line"><a class="code hl_struct" href="structSNoeud.html">Arbre</a>* KDT_Creer( <a class="code hl_typedef" href="arbre_8h.html#afe61909d742430b06f9331e359e36c4f">Donnee</a>* T, <span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> a );</div>
<div class="ttc" id="aarbre_8h_html_afe61909d742430b06f9331e359e36c4f"><div class="ttname"><a href="arbre_8h.html#afe61909d742430b06f9331e359e36c4f">Donnee</a></div><div class="ttdeci">int Donnee</div><div class="ttdef"><b>Definition</b> <a href="arbre_8h_source.html#l00005">arbre.h:5</a></div></div>
<div class="ttc" id="astructSNoeud_html"><div class="ttname"><a href="structSNoeud.html">SNoeud</a></div><div class="ttdef"><b>Definition</b> <a href="arbre_8h_source.html#l00030">arbre.h:30</a></div></div>
</div><!-- fragment --><p>Cette fonction suit le pseudo-code de la fonction de création d'arbre k-D vue en cours:</p>
<div class="image">
<img src="creer-kdtree.png" alt="" width="60%"/>
<div class="caption">
Algorithme de création d'un arbre k-D.</div></div>
<p>Pour les fonctions <code>MedianeSelonAxe</code> et <code>Partition</code>, je vous conseille de les remplacer par une fonction de <b>tri</b> selon l'axe <em>a</em>, qui sera plus facile à écrire, quoique moins optimal. Pour le tri, vous pouvez faire un tri "maison" (genre bulle) ou utiliser <code>qsort</code> de <code>stdlib.h</code> (en utilisant une variable globale indiquant la dimension où vous triez).</p>
<p>Vous rajouterez alors le code suivant dans votre <code>main:</code> </p>
<ul>
<li>On rajoute un champ <a class="el" href="arbre_8h.html#acf88594ceae6b727346db9a9f8c46577">Arbre</a> * <code>kdtree</code> dans le contexte (au début initialisé à <a class="el" href="arbre_8c.html#a10c6291ea5f5fb51509af06bfaf10a14">ArbreVide</a>).</li>
<li>Chaque fois qu'on rajoute un <code>Obstacle</code>, on va recréer tout l'arbre (ce n'est pas optimal, mais en fait on ne le fait qu'à chaque clic). Donc on appelle d'abord <a class="el" href="arbre_8c.html#a11ec929c2eae09300b587e667b170a99">Detruire</a> sur l'arbre du contexte, avant d'en recréer un nouveau avec <code>KDT_Creer</code> qui contient un obstacle de plus.</li>
<li>Dans la fonction d'affichage, on appelle la fonction suivante <code>viewerKDTree</code>, ce qui vous permettra de déboguer votre fonction de création d'arbre.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Affiche le K-d-tree de manière récursive, en mettant à jour la boîte</span></div>
<div class="line"><span class="comment">// englobante (bg, hd) correspondant à chaque noeud de l&#39;arbre.</span></div>
<div class="line"><span class="keywordtype">void</span> viewerKDTree( <a class="code hl_struct" href="structSContexte.html">Contexte</a>* pCtxt, cairo_t* cr, </div>
<div class="line">                   <a class="code hl_struct" href="structSNoeud.html">Noeud</a>* N, <a class="code hl_struct" href="structSPoint.html">Point</a> bg, <a class="code hl_struct" href="structSPoint.html">Point</a> hd, <span class="keywordtype">int</span> a )</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> ( N != <a class="code hl_function" href="arbre_8c.html#a10c6291ea5f5fb51509af06bfaf10a14">ArbreVide</a>() )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">int</span> b = (a+1) % <a class="code hl_define" href="TP-Proximity_2points_8h.html#ac25189db92959bff3c6c2adf4c34b50a">DIM</a>;</div>
<div class="line">      Obstacle* q = <a class="code hl_function" href="arbre_8c.html#ad7c02919ddc150c691a29ba5c4783f6a">Valeur</a>( N );</div>
<div class="line">      <a class="code hl_struct" href="structSPoint.html">Point</a> p,p1,p2; </div>
<div class="line">      p1.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ a ] = q-&gt;x[ a ];</div>
<div class="line">      p1.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ b ] = bg.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ b ];</div>
<div class="line">      p2.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ a ] = q-&gt;x[ a ];</div>
<div class="line">      p2.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ b ] = hd.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ b ];</div>
<div class="line">      cairo_set_source_rgb( cr, 0.0, 1.0, 1.0 );</div>
<div class="line">      <a class="code hl_struct" href="structSPoint.html">Point</a> draw_p1 = <a class="code hl_function" href="main_8c.html#ab5e509fc9a740c06feb572c9d0be4f4d">point2DrawingAreaPoint</a>( pCtxt, p1 );</div>
<div class="line">      <a class="code hl_struct" href="structSPoint.html">Point</a> draw_p2 = <a class="code hl_function" href="main_8c.html#ab5e509fc9a740c06feb572c9d0be4f4d">point2DrawingAreaPoint</a>( pCtxt, p2 );</div>
<div class="line">      cairo_move_to( cr, draw_p1.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 0 ], draw_p1.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 1 ] );</div>
<div class="line">      cairo_line_to( cr, draw_p2.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 0 ], draw_p2.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 1 ]);</div>
<div class="line">      cairo_stroke( cr );</div>
<div class="line">      cairo_set_source_rgb( cr, 1.0, 0.0, 0.0 );</div>
<div class="line">      p.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 0 ] = q-&gt;x[ 0 ]; </div>
<div class="line">      p.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 1 ] = q-&gt;x[ 1 ]; </div>
<div class="line">      <a class="code hl_struct" href="structSPoint.html">Point</a> dp = <a class="code hl_function" href="main_8c.html#ab5e509fc9a740c06feb572c9d0be4f4d">point2DrawingAreaPoint</a>( pCtxt, p );</div>
<div class="line">      <a class="code hl_function" href="convex_8c.html#a84e7aa0206045214a119e09ade191be7">drawPoint</a>( cr, dp.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 0 ], dp.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 1 ], 3 );</div>
<div class="line">      <a class="code hl_struct" href="structSPoint.html">Point</a> hd2 = hd;</div>
<div class="line">      hd2.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ a ] = q-&gt;x[ a ];</div>
<div class="line">      <a class="code hl_struct" href="structSPoint.html">Point</a> bg2 = bg;</div>
<div class="line">      bg2.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ a ] = q-&gt;x[ a ];</div>
<div class="line">      viewerKDTree( pCtxt, cr, <a class="code hl_function" href="arbre_8c.html#a9991584ba7184d2e83cbba237511bcdd">Gauche</a>( N ), bg, hd2, b );</div>
<div class="line">      viewerKDTree( pCtxt, cr, <a class="code hl_function" href="arbre_8c.html#ab935ea02b09d64a33d679196e8e2fd45">Droit</a>( N ), bg2, hd, b );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aarbre_8c_html_a10c6291ea5f5fb51509af06bfaf10a14"><div class="ttname"><a href="arbre_8c.html#a10c6291ea5f5fb51509af06bfaf10a14">ArbreVide</a></div><div class="ttdeci">Arbre * ArbreVide()</div><div class="ttdef"><b>Definition</b> <a href="arbre_8c_source.html#l00024">arbre.c:24</a></div></div>
<div class="ttc" id="aarbre_8c_html_a9991584ba7184d2e83cbba237511bcdd"><div class="ttname"><a href="arbre_8c.html#a9991584ba7184d2e83cbba237511bcdd">Gauche</a></div><div class="ttdeci">Noeud * Gauche(Noeud *N)</div><div class="ttdef"><b>Definition</b> <a href="arbre_8c_source.html#l00104">arbre.c:104</a></div></div>
<div class="ttc" id="aarbre_8c_html_ab935ea02b09d64a33d679196e8e2fd45"><div class="ttname"><a href="arbre_8c.html#ab935ea02b09d64a33d679196e8e2fd45">Droit</a></div><div class="ttdeci">Noeud * Droit(Noeud *N)</div><div class="ttdef"><b>Definition</b> <a href="arbre_8c_source.html#l00128">arbre.c:128</a></div></div>
<div class="ttc" id="aarbre_8c_html_ad7c02919ddc150c691a29ba5c4783f6a"><div class="ttname"><a href="arbre_8c.html#ad7c02919ddc150c691a29ba5c4783f6a">Valeur</a></div><div class="ttdeci">Donnee * Valeur(Noeud *N)</div><div class="ttdef"><b>Definition</b> <a href="arbre_8c_source.html#l00153">arbre.c:153</a></div></div>
<div class="ttc" id="aconvex_8c_html_a84e7aa0206045214a119e09ade191be7"><div class="ttname"><a href="convex_8c.html#a84e7aa0206045214a119e09ade191be7">drawPoint</a></div><div class="ttdeci">void drawPoint(cairo_t *cr, Point p)</div><div class="ttdef"><b>Definition</b> <a href="convex_8c_source.html#l00113">convex.c:113</a></div></div>
</div><!-- fragment --><p>On l'appelle ainsi dans expose_evt_reaction : </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structSPoint.html">Point</a> bg = { {-10.0, -10.0} };</div>
<div class="line"><a class="code hl_struct" href="structSPoint.html">Point</a> hd = { { 10.0,  10.0} };</div>
<div class="line">viewerKDTree( pCtxt, cr, <a class="code hl_function" href="arbre_8c.html#a228f1d85433277e0605db3f1710e1df2">Racine</a>( pCtxt-&gt;kdtree ), bg, hd, 0 );</div>
<div class="ttc" id="aarbre_8c_html_a228f1d85433277e0605db3f1710e1df2"><div class="ttname"><a href="arbre_8c.html#a228f1d85433277e0605db3f1710e1df2">Racine</a></div><div class="ttdeci">Noeud * Racine(Arbre *A)</div><div class="ttdef"><b>Definition</b> <a href="arbre_8c_source.html#l00092">arbre.c:92</a></div></div>
</div><!-- fragment --><p>Vous obtenez alors ce genre de résultat, si votre fonction de création d'arbre k-D fonctionne !</p>
<div class="image">
<img src="proximity-4-1.png" alt=""/>
<div class="caption">
Visualisation de l'arbre k-D des obstacles.</div></div>
<h2><a class="anchor" id="tp-PROX-4-2"></a>
4.2 - Détection des obstacles proches de vos particules</h2>
<p>Vous êtes presque au bout de vos peines. Il s'agit maintenant juste d'être un peu plus intelligent dans la fonction <a class="el" href="main_8c.html#aa7e673a44be06db2002069efb6bedd06">deplaceParticule</a>, en n'appelant la fonction <a class="el" href="TP-Proximity_2points_8c.html#a7d653a23bc3022afd9b32e419abbbc2d">distance</a> que sur les obstacles suffisamment près de la particule. On va donc utiliser l'algorithme <code>PointsDansBoule</code> vu en-cours et de prototype :</p>
<div class="fragment"><div class="line"><span class="comment">// Ajoute dans le tableau d&#39;obstacles F les obstacles de l&#39;arbre</span></div>
<div class="line"><span class="comment">// désigné par le noeud racine N qui sont à une distance inférieure à</span></div>
<div class="line"><span class="comment">// r du point p. Le paramètre a désigne l&#39;axe courant (0 ou 1) et</span></div>
<div class="line"><span class="comment">// change à chaque niveau de récursion.</span></div>
<div class="line"><span class="keywordtype">void</span> KDT_PointsDansBoule( TabObstacles* F, <a class="code hl_struct" href="structSNoeud.html">Noeud</a>* N, <a class="code hl_struct" href="structSPoint.html">Point</a>* p, <span class="keywordtype">double</span> r, <span class="keywordtype">int</span> a );</div>
</div><!-- fragment --><div class="image">
<img src="points-dans-boule.png" alt="" width="60%"/>
<div class="caption">
Algorithme de recherche des points proches (dans une boule de centre p et de rayon r).</div></div>
<p>Ensuite, dans <a class="el" href="main_8c.html#aa7e673a44be06db2002069efb6bedd06">deplaceParticule</a>, on ne teste <b>que</b> les obstacles qui ont été détectés par <code>KDT_PointsDansBoule</code>. Une partie du code est donné ci-dessous:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="main_8c.html#aa7e673a44be06db2002069efb6bedd06">deplaceParticule</a>( <a class="code hl_struct" href="structSContexte.html">Contexte</a>* pCtxt, <a class="code hl_struct" href="structSParticule.html">Particule</a>* p )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Déplace p en supposant qu&#39;il n&#39;y a pas de collision.</span></div>
<div class="line">  <a class="code hl_struct" href="structSPoint.html">Point</a> pp;</div>
<div class="line">  pp.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 0 ] = p-&gt;<a class="code hl_variable" href="structSParticule.html#a3dce37ad974d5d2eb76ce06dd8678772">x</a>[ 0 ] + <a class="code hl_define" href="main_8c.html#a943f07034774ef1261d62cd0d3d1fec9">DT</a> * p-&gt;<a class="code hl_variable" href="structSParticule.html#ad5a127d2acb27eb325c45e00b0b93731">v</a>[ 0 ];</div>
<div class="line">  pp.<a class="code hl_variable" href="structSPoint.html#ad39d5d98239044aba9f723024d07d6bd">x</a>[ 1 ] = p-&gt;<a class="code hl_variable" href="structSParticule.html#a3dce37ad974d5d2eb76ce06dd8678772">x</a>[ 1 ] + <a class="code hl_define" href="main_8c.html#a943f07034774ef1261d62cd0d3d1fec9">DT</a> * p-&gt;<a class="code hl_variable" href="structSParticule.html#ad5a127d2acb27eb325c45e00b0b93731">v</a>[ 1 ];</div>
<div class="line"> </div>
<div class="line">  TabObstacles F; <span class="comment">// obstacles potentiels;</span></div>
<div class="line">  TabObstacles_init( &amp;F );</div>
<div class="line">  <span class="comment">// Trouve les obstacles dans un rayon de 0.05 du point d&#39;intérêt pp.</span></div>
<div class="line">  KDT_PointsDansBoule( &amp;F, <a class="code hl_function" href="arbre_8c.html#a228f1d85433277e0605db3f1710e1df2">Racine</a>( pCtxt-&gt;kdtree ), &amp;pp, 0.05, 0 );</div>
<div class="line">  <span class="comment">// On teste si il y a une &quot;vraie&quot; collision dans F </span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  <span class="comment">// et on déplace le point en fonction</span></div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  TabObstacles_termine( &amp;F ); <span class="comment">// pour éviter les fuites mémoire.</span></div>
<div class="line">}</div>
<div class="ttc" id="amain_8c_html_aa7e673a44be06db2002069efb6bedd06"><div class="ttname"><a href="main_8c.html#aa7e673a44be06db2002069efb6bedd06">deplaceParticule</a></div><div class="ttdeci">void deplaceParticule(Contexte *pCtxt, Particule *p)</div><div class="ttdef"><b>Definition</b> <a href="main_8c_source.html#l00376">main.c:376</a></div></div>
</div><!-- fragment --><p>On note qu'ici on a choisi le même rayon de localisation 0.05 que la taille des obstacles. En fait, il faut juste veiller à ce que le rayon d'un obstacle soit inférieur ou égal à ce rayon de localisation. Au bout du compte, votre application ressemble à ceci. On note qu'il y a beaucoup moins d'appels à la fonction <a class="el" href="TP-Proximity_2points_8c.html#a7d653a23bc3022afd9b32e419abbbc2d">distance</a> par seconde, alors même qu'il y a plus de particules et plus d'obstacles !</p>
<div class="image">
<img src="proximity-4-2.png" alt=""/>
<div class="caption">
Visualisation de l'arbre k-D des obstacles et accélération des tests de proximité.</div></div>
<h2><a class="anchor" id="tp-PROX-4-3"></a>
4.3 - Pour aller un peu plus loin</h2>
<p>Vous avez toute liberté pour aller un peu plus loin. Le plus dur est fait. On peut s'amuser à étoffer simplement l'application de beaucoup de façons:</p>
<ul>
<li>mettre d'autres fontaines.</li>
<li>rajouter une couleur aux particules et les colorer différemment selon les fontaines.</li>
<li>laisser l'utilisateur placer plusieurs sortes d'obstacles: des obstacles plus petits ou plus gros, des obstacles avec forte atténuation (att = 0.1) ou au contraire des "bumpers" comme dans les flippers (att=1.5).</li>
<li>créer d'autres forces, comme un attracteur ou un répulseur lorsqu'une particule se rapproche trop d'une zone.</li>
<li>faire des puits qui mangent les particules.</li>
<li>le transformer en jeu avec score et objectifs...</li>
<li>...</li>
</ul>
<p>On note que gérer les collisions entre particules elles-mêmes est plus délicat, en tous cas avec les arbres k-D. Il faut en effet recréer les arbres stockant les particules à chaque itération.</p>
<h1><a class="anchor" id="tp-PROX-5"></a>
5 - Remise du tp</h1>
<ul>
<li>Ce TP peut être fait par binôme.</li>
<li>Vous m'enverrez par email votre TP avant le <b>25</b> <b>avril</b> <b>2023</b> <b>minuit</b>, via <a href="https://www.lama.univ-savoie.fr/TPLab">TPLab</a>. Il faudra une archive nommée TP3-[votre ou vos nom(s)] contenant tous les fichiers sources, entêtes, makefile.</li>
<li>Bien entendu, il faut que vos programmes compilent sous Linux.</li>
<li>si je fais <code>make</code>, ça doit compiler sans erreur et sans warning (dans vos sources).</li>
<li>Vous me ferez un petit compte-rendu (README) précisant l'état d'avancement (ce qui marche, ce qui marche à moitié, et ce qui ne marche pas), ainsi que les éléments supplémentaires éventuels que vous avez rajoutés.</li>
</ul>
<div class="image">
<img src="proximity-5.png" alt="" width="60%"/>
</div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
