<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INFO607: Structures Union-Find par forêts et application à la segmentation d&#39;image.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INFO607
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Structures Union-Find par forêts et application à la segmentation d'image.</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tp-UF-1">1 - Objectifs</a><ul><li class="level2"><a href="#tp-UF-11">1.1 Quelques précisions utiles</a></li>
<li class="level2"><a href="#tp-UF-12">1.2 Réaction à un clic sur un bouton et appel d&#39;une fonction</a></li>
<li class="level2"><a href="#tp-UF-13">1.3 Segmentation d&#39;image</a></li>
</ul>
</li>
<li class="level1"><a href="#tp-UF-2">2 Seuillage de l&#39;image</a></li>
<li class="level1"><a href="#tp-UF-3">3 Découpage de l&#39;image seuillée en composantes connexes</a><ul><li class="level2"><a href="#tp-UF-3-1">3.1 Présentation des structures Union-Find par forêt</a></li>
<li class="level2"><a href="#tp-UF-3-2">3.2 Codage des structures Union-Find par forêt</a></li>
<li class="level2"><a href="#tp-UF-3-3">3.3 Utilisation de cette structure pour le découpage en composantes connexes.</a></li>
</ul>
</li>
<li class="level1"><a href="#tp-UF-3-4">3.4 Temps d&#39;exécution de Union-Find.</a></li>
<li class="level1"><a href="#tp-UF-4">4 Affichage de la couleur moyenne pour chaque région</a></li>
<li class="level1"><a href="#tp-UF-5">5 Connexité floue et découpage en composantes connexes floues</a></li>
<li class="level1"><a href="#tp-UF-6">6. Remise du tp</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tp-UF-1"></a>
1 - Objectifs</h1>
<p>L'objectif de ce TP est de vous faire mettre en oeuvre une structure de données efficace pour les ensembles disjoints : la forêt. On se servira de cette structure pour faire de la segmentation d'image, c'est-à-dire une partition de l'image en zones d'intérêt.</p>
<p>Pour faciliter la visualisation, on utilisera la bibliothèque GTK (<a href="http://www.gtk.org">http://www.gtk.org</a>) comme interface graphique. Elle permet de charger les images, de les afficher, d'avoir des boutons et sélecteur de paramètres, etc. Vous vous en êtes déjà servi en INFO505 (<a href="http://www.lama.univ-savoie.fr/~lachaud/Cours/INFO504/Tests/doc/html/tp3.html">http://www.lama.univ-savoie.fr/~lachaud/Cours/INFO504/Tests/doc/html/tp3.html</a>) pour le TP Tetris graphique.</p>
<p>Pour vous faire gagner du temps, on vous donne une application de base <a class="el" href="union-find_8c.html">union-find.c</a> , qui charge une image et permet de choisir entre deux pixbufs pour la visualisation (l'image en entrée et l'image de sortie calculée).</p>
<p>Prenez d'abord le temps de bien comprendre le code écrit, le source est consultable là: <a class="el" href="union-find_8c.html">union-find.c</a> et est présent dans l'archive, le makefile est ci-dessous:</p>
<div class="fragment"><div class="line">SRC=union-find.c</div>
<div class="line">CC=gcc</div>
<div class="line">LD=gcc</div>
<div class="line"># CFLAGS=-g -Wall -Werror -pedantic -Wno-deprecated-declarations -std=c11</div>
<div class="line">CFLAGS=-g -Wall -Werror -pedantic -std=c11</div>
<div class="line">LIBS=-lm</div>
<div class="line"># Choisissez si vous préférez GTK2 ou GTK3</div>
<div class="line"># gtk+-2.0 pour GTK2</div>
<div class="line"># gtk+-3.0 pour GTK3 (choisi ici)</div>
<div class="line">GTKCFLAGS:=-g $(shell pkg-config --cflags gtk+-3.0)</div>
<div class="line">GTKLIBS:=$(shell pkg-config --libs gtk+-3.0)</div>
<div class="line"> </div>
<div class="line">all: union-find</div>
<div class="line"> </div>
<div class="line">union-find: union-find.o </div>
<div class="line">        $(LD) union-find.o $(GTKLIBS) $(LIBS) -lm -o union-find</div>
<div class="line"> </div>
<div class="line">union-find.o: $(SRC)</div>
<div class="line">        $(CC) -c $(SRC) $(CFLAGS) $(GTKCFLAGS) -o union-find.o</div>
<div class="line"> </div>
<div class="line">clean:</div>
<div class="line">        rm -f union-find union-find.o</div>
<div class="line"> </div>
<div class="line">fullclean: clean</div>
<div class="line">        rm -f *~ *.fig.bak</div>
</div><!-- fragment --><p>Pour l'exécuter, on pourra lui donner en paramètre un nom de fichier image (JPG, PNG, PGM, etc). </p><pre class="fragment">prompt$ make
prompt$ ./union-find papillon-express.jpg</pre><h2><a class="anchor" id="tp-UF-11"></a>
1.1 Quelques précisions utiles</h2>
<p>GTK, et plus précisément GDK, voit les images sous forme de tableaux d'octets (type <code>unsigned</code> <code>char</code> ou <code>guchar</code>), appelé <code>GdkPixbuf</code>. Chaque pixel est en général codé sur 3 octets :</p>
<ul>
<li>le premier octet code l'intensité de rouge entre 0 (aucun) et 255 (rouge à fond)</li>
<li>le deuxième octet code l'intensité de vert entre 0 (aucun) et 255 (vert à fond)</li>
<li>le troisième octet code l'intensité de bleu entre 0 (aucun) et 255 (bleu à fond)</li>
</ul>
<p>Dans l'image, le <code>GdkPixbuf</code> commence par stocker le pixel le plus en haut à gauche, puis stocke les pixels ligne par ligne. Les pixels d'une même ligne sont à la suite les uns des autres (donc tous les 3 octets). Pour passer d'une ligne à une autre, on ajoute <b>rowstride</b> octets au début de l'adresse du pixel de la ligne précédente.</p>
<p>On crée un type <a class="el" href="structPixel.html">Pixel</a> pour simplifier l'accès aux pixels. Le bout de code ci-dessous montre comment mettre la composante rouge de tous les pixels d'une image à fond.</p>
<div class="fragment"><div class="line"><span class="comment">// pixbuf est un GdkPixbuf*</span></div>
<div class="line">guchar* data        = gdk_pixbuf_get_pixels( pixbuf );          <span class="comment">// Pointeur vers le tampon de données</span></div>
<div class="line"><span class="keywordtype">int</span> rowstride       = gdk_pixbuf_get_rowstride( pixbuf );       <span class="comment">// Nombre d&#39;octets entre chaque ligne dans le tampon de données</span></div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> y = 0; y &lt; height; ++y )</div>
<div class="line"> {</div>
<div class="line">   <a class="code hl_struct" href="structPixel.html">Pixel</a>* pixel = (<a class="code hl_struct" href="structPixel.html">Pixel</a>*) data;</div>
<div class="line">   <span class="keywordflow">for</span> ( x = 0; x &lt; width; ++x ) </div>
<div class="line">     {</div>
<div class="line">       pixel-&gt;<a class="code hl_variable" href="structPixel.html#a72a901ee374a0d5154d2a35e84fe9723">rouge</a> = 255; <span class="comment">// met le rouge à fond</span></div>
<div class="line">       ++pixel;</div>
<div class="line">     }</div>
<div class="line">   data += rowstride; <span class="comment">// passe à la ligne suivante</span></div>
<div class="line"> }</div>
<div class="ttc" id="astructPixel_html"><div class="ttname"><a href="structPixel.html">Pixel</a></div><div class="ttdef"><b>Definition</b> <a href="union-find_8c_source.html#l00025">union-find.c:25</a></div></div>
<div class="ttc" id="astructPixel_html_a72a901ee374a0d5154d2a35e84fe9723"><div class="ttname"><a href="structPixel.html#a72a901ee374a0d5154d2a35e84fe9723">Pixel::rouge</a></div><div class="ttdeci">guchar rouge</div><div class="ttdef"><b>Definition</b> <a href="union-find_8c_source.html#l00026">union-find.c:26</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="tp-UF-12"></a>
1.2 Réaction à un clic sur un bouton et appel d'une fonction</h2>
<p>On voit que les fonctions selectInput et selectOutput sont des fonctions <b>"call-back"</b> ou <b>réaction</b> qui sont appelés lors d'un événement précis. Elles reçoivent en paramètre un pointeur, qui est ici le pointeur vers la variable <code>contexte</code>. Celle-ci nous permet donc d'accéder aux données utiles pour faire la segmentation.</p>
<div class="fragment"><div class="line"><span class="comment">/// Fonction appelée lorsqu&#39;on clique sur &quot;Input&quot;.</span></div>
<div class="line">gboolean <a class="code hl_function" href="union-find_8c.html#a55131410b57e2825f7dc31c1b3619e43">selectInput</a>( GtkWidget *widget, gpointer data )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Récupère le contexte.</span></div>
<div class="line">  <a class="code hl_struct" href="structSContexte.html">Contexte</a>* pCtxt = (<a class="code hl_struct" href="structSContexte.html">Contexte</a>*) data;</div>
<div class="line">  <span class="comment">// Place le pixbuf à visualiser dans le bon widget.</span></div>
<div class="line">  gtk_image_set_from_pixbuf( GTK_IMAGE( pCtxt-&gt;<a class="code hl_variable" href="structSContexte.html#adc8897e2535746a33b8ad4d3715afe53">image</a> ), pCtxt-&gt;<a class="code hl_variable" href="structSContexte.html#a067851d58ac524e10f3fa291c6b30533">pixbuf_input</a> );</div>
<div class="line">  <span class="comment">// Force le réaffichage du widget.</span></div>
<div class="line">  gtk_widget_queue_draw( pCtxt-&gt;<a class="code hl_variable" href="structSContexte.html#adc8897e2535746a33b8ad4d3715afe53">image</a> );</div>
<div class="line">  <span class="keywordflow">return</span> TRUE;</div>
<div class="line">}</div>
<div class="ttc" id="astructSContexte_html"><div class="ttname"><a href="structSContexte.html">SContexte</a></div><div class="ttdef"><b>Definition</b> <a href="union-find_8c_source.html#l00013">union-find.c:13</a></div></div>
<div class="ttc" id="astructSContexte_html_a067851d58ac524e10f3fa291c6b30533"><div class="ttname"><a href="structSContexte.html#a067851d58ac524e10f3fa291c6b30533">SContexte::pixbuf_input</a></div><div class="ttdeci">GdkPixbuf * pixbuf_input</div><div class="ttdef"><b>Definition</b> <a href="union-find_8c_source.html#l00016">union-find.c:16</a></div></div>
<div class="ttc" id="astructSContexte_html_adc8897e2535746a33b8ad4d3715afe53"><div class="ttname"><a href="structSContexte.html#adc8897e2535746a33b8ad4d3715afe53">SContexte::image</a></div><div class="ttdeci">GtkWidget * image</div><div class="ttdef"><b>Definition</b> <a href="union-find_8c_source.html#l00018">union-find.c:18</a></div></div>
<div class="ttc" id="aunion-find_8c_html_a55131410b57e2825f7dc31c1b3619e43"><div class="ttname"><a href="union-find_8c.html#a55131410b57e2825f7dc31c1b3619e43">selectInput</a></div><div class="ttdeci">gboolean selectInput(GtkWidget *widget, gpointer data)</div><div class="ttdoc">Fonction appelée lorsqu'on clique sur &quot;Input&quot;.</div><div class="ttdef"><b>Definition</b> <a href="union-find_8c_source.html#l00068">union-find.c:68</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="tp-UF-13"></a>
1.3 Segmentation d'image</h2>
<p>L'objectif de la segmentation d'image est de réaliser une partition de l'image en régions d'intérêt, afin de simplifier son analyse postérieure, notamment pour la reconnaissance ou l'indexation. Une région est souvent définie comme un ensemble de points connexes du plan. Pour faire simple, il y a deux grandes familles de techniques:</p>
<ul>
<li>l'approche par <b>homogénéité:</b> on définit les régions comme des zones à peu près homogènes, i.e. de couleurs et intensités proches.</li>
<li>l'approche par <b>hétérogénéité:</b> on définit les frontières entre régions comme des endroits où il y a de fortes variations de la couleur et/ou de l'intensité.</li>
</ul>
<p>Evidemment, on fait souvent un mélange de ces deux approches duales. Ici, ce que vous allez faire relève des deux approches:</p>
<ul>
<li>l'approche par <b>homogénéité:</b> le seuillage regroupe zones claires ensembles et zones sombres ensemble (<a class="el" href="tp-UF.html#tp-UF-2">2 Seuillage de l'image</a>) et l'extraction de composantes connexes en définit les régions (<a class="el" href="tp-UF.html#tp-UF-3">3 Découpage de l'image seuillée en composantes connexes</a>). Souvent, on préférerait faire un K-means ou K-moyennes (<a href="http://fr.wikipedia.org/wiki/Algorithme_des_k-moyennes">http://fr.wikipedia.org/wiki/Algorithme_des_k-moyennes</a>) plutôt qu'un seuillage en première phase.</li>
<li>l'approche par <b>hétérogénéité:</b> la non-similitude découpe le graphe autour des hétérogénéité et l'extraction de composantes connexes qui suit bloque sur les frontières pour retrouver les régions (<a class="el" href="tp-UF.html#tp-UF-5">5 Connexité floue et découpage en composantes connexes floues</a>).</li>
</ul>
<h1><a class="anchor" id="tp-UF-2"></a>
2 Seuillage de l'image</h1>
<p>On commence par faire un traitement très simple sur l'image, le <b>seuillage</b> par un niveau de gris <em>T</em> entre 0 et 255. Il s'agit tout simplement de transformer l'image donnée en entrée en une image noir et blanc telle que:</p>
<ul>
<li>soit <em>g</em> le niveau de gris d'un pixel <em>p</em> dans le pixbuf <code>input</code> (obtenu par un appel de <a class="el" href="union-find_8c.html#a9c7c8777886cf156cea8842118074a37">greyLevel</a>).</li>
<li>si <em>g</em> est strictement plus petit que <em>T</em>, alors le pixel à la même position que <em>p</em> dans le pixbuf <code>output</code> est mis noir (appel de <a class="el" href="union-find_8c.html#ae66d23c82260eeda317796173b934c17">setGreyLevel</a> avec 0)</li>
<li>sinon le pixel à la même position que <em>p</em> dans le pixbuf <code>output</code> est mis blanc (appel de <a class="el" href="union-find_8c.html#ae66d23c82260eeda317796173b934c17">setGreyLevel</a> avec 255)</li>
</ul>
<p>Créer donc un <code>GtkScale</code> et un bouton "Seuiller" et rajoutez les dans l'IHM pour que l'utilisateur puisse choisir son seuil et lancer le seuillage. L'image seuillée sera placée dans le pixbuf <code>output</code> du contexte.</p>
<div class="fragment"><div class="line"><span class="comment">// Crée un scale GTK2</span></div>
<div class="line">GtkWidget* seuil_widget = gtk_hscale_new_with_range( 0, 255, 1 );</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Crée un scale GTK3</span></div>
<div class="line">GtkWidget* seuil_widget = gtk_scale_new_with_range( GTK_ORIENTATION_HORIZONTAL, 0, 255, 1 );</div>
</div><!-- fragment --><p>N'oubliez pas de stocker le widget dans le contexte pour que vous puissiez accéder à la valeur choisie dans votre réaction <code>seuillerImage</code>. On utilisera la fonction gtk_range_get_value pour récupérer la valeur du widget. Cela donnera quelque chose du genre:</p>
<div class="image">
<img src="app-1.gif" alt=""/>
<div class="caption">
Image papillon-express seuillée à T=100</div></div>
<h1><a class="anchor" id="tp-UF-3"></a>
3 Découpage de l'image seuillée en composantes connexes</h1>
<p>On va maintenant coder une structure Union-Find pour calculer les composantes connexes de l'image seuillée. A une image seuillée, on associe un graphe dont les sommets sont les pixels et les arêtes relient deux pixels qui se touchent si ils ont même valeur. On cherchera à extraire les composantes connexes de ce graphe, c'est-à-dire les parties où il existe un chemin entre pixels. Dans un premier temps, on code une structure Union-Find, dans un deuxième temps on l'utilisera sur l'image.</p>
<h2><a class="anchor" id="tp-UF-3-1"></a>
3.1 Présentation des structures Union-Find par forêt</h2>
<p>Une présentation plus détaillée est à la fin de la <a href="http://www.lama.univ-savoie.fr/pagesmembres/lachaud/Cours/INFO602/Cours/lesson-3.pdf">Leçon 3</a> d'INFO607. Les <b>forêts</b> constituent la structure de données la plus <b>efficace</b> pour coder les problèmes utilisant les ensembles disjoints (i.e. \( S = \cup_i S_i \) et \( \forall i
   \neq j, S_i \cap S_j = \emptyset \)).</p>
<p>Chaque sous-ensemble est représenté par un arbre, dont les noeuds sont les objets appartenant à l'ensemble et la racine est le représentant de l'ensemble. Chaque noeud d'un arbre a donc un pointeur vers son parent. La racine pointe vers elle-même et est le représentant du sous-ensemble constitué de tous les noeuds de l'arbre. Les fonctions sur les ensembles disjoints sont mis en oeuvre ainsi:</p>
<ul>
<li>Un appel de <code>Créer-Ensemble(x)</code> crée simplement un arbre a un seul noeud <code>x</code> (coûte \( \Theta(1) \)).</li>
<li>La fonction <code>Trouver(x)</code> remonte d'un noeud <code>x</code> jusqu'à sa racine et retourne la racine, ce qui coûte \( \Theta(k) \) où <em>k</em> est la profondeur du noeud.</li>
<li>La fonction <code>Union(x,y)</code> relie la racine de <code>x</code> à la racine de <code>y</code>, si <code>x</code> et <code>y</code> n'ont pas le même représentant (i.e. la même racine). Pour ce faire, il suffit donc de remonter à la racine de chaque arbre et de modifier un pointeur.</li>
</ul>
<div class="fragment"><div class="line">Action Créer-Ensemble}( E x : Objet );</div>
<div class="line">Debut</div>
<div class="line">  x.pere &lt;- x;</div>
<div class="line">  x.rand &lt;- 1; <span class="comment">// servira après</span></div>
<div class="line">Fin</div>
</div><!-- fragment --> <div class="fragment"><div class="line">Action Union( E x :  Objet, y : Objet ); <span class="comment">// x et y dans 2 ensembles différents</span></div>
<div class="line">Debut</div>
<div class="line">  u &lt;- Trouver(x);</div>
<div class="line">  v &lt;- Trouver(y);</div>
<div class="line">  u.pere &lt;- v;</div>
<div class="line">Fin</div>
</div><!-- fragment --> <div class="fragment"><div class="line">Fonction Trouver( E x : Objet ) : Objet;</div>
<div class="line">Debut</div>
<div class="line">  Si x == x.pere Alors retourner x;</div>
<div class="line">                 Sinon retourner Trouver( x.pere );</div>
<div class="line">Fin</div>
</div><!-- fragment --><p>Telle quelle, cette implémentation n'est pas plus rapide que celle utilisant les listes chaînées. On applique deux heuristiques à cette structure de façon à la rendre la plus efficace possible.</p>
<ul>
<li><b>L'</b> <b>union</b> <b>par</b> <b>rang</b>. On stocke dans chaque noeud un majorant de la hauteur de son sous-arbre appelé rang (qui vaut 1 lorsque l'arbre est réduit à un élément). Lorsqu'on réalise l'union, c'est la racine de moindre rang qui pointe vers la racine de rang supérieur. C'est seulement lorsque les deux racines ont même rang qu'on augmente le rang. Il est clair que cette opération ne rajoute pas de surcoût en temps.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Pseudo-code si union par rang.</span></div>
<div class="line">Action Union( E x : Objet, y : Objet ); <span class="comment">// x et y dans 2 ensembles différents</span></div>
<div class="line">Debut</div>
<div class="line">  u &lt;- Trouver(x);</div>
<div class="line">  v &lt;- Trouver(y);</div>
<div class="line">  Si u.rang &gt; v.rang Alors v.pere &lt;- u;</div>
<div class="line">                     Sinon u.pere &lt;- v;</div>
<div class="line">  Si u.rang = v.rang Alors v.rang &lt;- v.rang + 1;</div>
<div class="line">Fin</div>
</div><!-- fragment --><ul>
<li><b>La</b> <b>compression</b> <b>de</b> <b>chemin</b>. Dès que l'on utilise <code>Trouver</code>, tous les noeuds traversés pour trouver la racine, sont modifiés de façon à ce que leur parent soit directement la racine. Il est clair que cette opération ne rajoute pas de surcoût en temps.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Pseudo-code si compression de chemin.</span></div>
<div class="line">Fonction Trouver( E x : Objet ) : Objet;</div>
<div class="line">Debut</div>
<div class="line">  Si x != x.pere Alors x.pere &lt;- Trouver( x.pere );</div>
<div class="line">  Retourner x.pere;</div>
<div class="line">Fin</div>
</div><!-- fragment --><p>Ces heuristiques ont un effet très important sur la complexité amortie des opérations sur les ensembles disjoints. On a :</p>
<p><b>Théorème</b> <b></b>[Tarjan 1975]. Si on utilise les forêts d'ensembles disjoints avec les heuristiques d'union par rang et de compression de chemin, alors une séquence arbitraire de \( m \) opérations <code>Créer-Ensemble</code>, <code>Trouver</code>, <code>Union</code> prend un temps \( O(m
  \alpha(n)) \), où \( \alpha(n) \) est une fonction qui croît extrêmement lentement ( \( n \le 4 \) dans tous les cas concevables). <br  />
</p>
<dl class="section note"><dt>Note</dt><dd>La preuve se fait en utilisant la méthode du potentiel.</dd></dl>
<h2><a class="anchor" id="tp-UF-3-2"></a>
3.2 Codage des structures Union-Find par forêt</h2>
<p>La difficulté est de coder la notion abstraite d'<code>Objet</code> (ou d'<code>Element</code>) définie en cours. L'<code>Objet</code> stockera un pointeur vers le pixel associé, son rang et un pointeur vers son père. On aura exactement un <code>Objet</code> par <a class="el" href="structPixel.html">Pixel</a>. Nous procéderons ainsi:</p>
<div class="fragment"><div class="line"><span class="comment">/// Un Objet stocke donc un pointeur vers son pixel, son rang et un pointeur vers l&#39;objet père.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>SObjet {</div>
<div class="line">  <a class="code hl_struct" href="structPixel.html">Pixel</a>* pixel; <span class="comment">// adresse du pixel dans le pixbuf</span></div>
<div class="line">  <span class="keywordtype">int</span> rang;</div>
<div class="line">  <span class="keyword">struct </span>SObjet* pere;</div>
<div class="line">} Objet;</div>
</div><!-- fragment --><p>On va créer autant d'<code>Objet</code> que de pixels. On les place dans un grand tableau d'<code>Objet</code>, indicés de 0 à width*height-1, dans l'ordre habituel. Au début, chaque <code>Objet</code> doit pointer sur le bon pixel, avoir rang 0, et son père c'est lui-même. Ecrivez donc la fonction <code>creerEnsembles</code> qui fait ce travail et retourne ce tableau d'<code>Objet</code> alloué dynamiquement. Son prototype sera:</p>
<div class="fragment"><div class="line">Objet* CreerEnsembles( GdkPixbuf* pixbuf );</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Cette fonction est délicate. Vérifiez bien que les champs <code>pixel</code> et <code>pere</code> sont remplis correctement. Au besoin, me demander.</dd></dl>
<p>Il faut ensuite créer les fonctions usuelles: </p><div class="fragment"><div class="line"><span class="comment">// Retourne le représentant de l&#39;objet obj</span></div>
<div class="line">Objet* Trouver( Objet* obj );</div>
<div class="line"><span class="comment">// Réalise l&#39;union des deux arbres contenant obj1 et obj2.</span></div>
<div class="line"><span class="comment">// @pre obj1 et obj2 ne doivent pas avoir les mêmes représentants.</span></div>
<div class="line"><span class="keywordtype">void</span> Union( Objet* obj1, Objet* obj2 );</div>
</div><!-- fragment --><p>Vous créerez les deux versions de <code>Union</code> (avec ou sans Union par rang), et les deux versions de <code>Trouver</code> (avec ou sans compression de chemin).</p>
<h2><a class="anchor" id="tp-UF-3-3"></a>
3.3 Utilisation de cette structure pour le découpage en composantes connexes.</h2>
<p>L'image seuillée est vue comme un graphe dont les sommets sont les pixels, et les arêtes relient deux pixels adjacents si ils ont la même valeur. Voilà le graphe (implicite) de la petite image binaire ci-dessous.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="pac-v1.png" alt=""/>
<div class="caption">
Image binaire</div></div>
  </td><td><div class="image">
<img src="pac-v2.png" alt=""/>
<div class="caption">
Son graphe de connexité induit.</div></div>
   </td></tr>
</table>
<p>Créez maintenant un nouveau bouton "Composantes connexes" avec une réaction <code>ComposantesConnexes</code>. Elle réalisera l'algorithme ci-dessous:</p>
<pre class="fragment">0) elle travaillera directement sur le \c pixbuf_output du contexte, en supposant que l'on a déjà appelé \c seuiller dessus.
1) Objet* objets = CreerEnsembles( ... ); // elle commence par créer le tableau d'\c Objet.
2) Soit i = 0, le numero de l'objet courant
3a) Pour toute paire d'objets objets[i] et objets[i+1] adjacents horizontalement,
      si ils ont même valeurs, on fait l'union.
3b) Pour toute paire d'objets objets[i] et objets[i+width] adjacents verticalement,
      si ils ont même valeurs, on fait l'union.
4) On reparcourt tous les objets et on affecte une couleur aléatoire à tous les objets 
   qui sont des représentants
5) On reparcourt tous les objets et on leur affecte la couleur de leur représentant
6) on force le réaffichage pour voir le résultat.
</pre><p>Sur l'exemple précédent du papillon seuillée à 100, voilà ce que vous obtenez:</p>
<div class="image">
<img src="app-3.gif" alt=""/>
<div class="caption">
Image papillon-express seuillée à T=100, puis dont les composantes connexes ont été extraites.</div></div>
<dl class="section note"><dt>Note</dt><dd>Faites attention aux <b>bords</b> de l'image ! (bord droit pour les adjacences horizontales, bord bas pour les adjacences verticales).</dd></dl>
<h1><a class="anchor" id="tp-UF-3-4"></a>
3.4 Temps d'exécution de Union-Find.</h1>
<p>On vérifiera que l'efficacité de la structure Union-Find est très dépendante des deux heuristiques d'optimisation. Pour mesurer le temps, on pourra utiliser à profit le bout de code suivant (Linux):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;time.h&gt;</span></div>
<div class="line">...</div>
<div class="line">  <span class="keyword">struct </span>timespec myTimerStart;</div>
<div class="line">  clock_gettime(CLOCK_REALTIME, &amp;myTimerStart); <span class="comment">// Démarre l&#39;horloge</span></div>
<div class="line">  <span class="comment">// mettre ici l&#39;algo de composantes connexes avec les CreerEnsemble, Union, TrouverEnsemble</span></div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="keyword">struct </span>timespec current; <span class="comment">// Stoppe l&#39;horloge</span></div>
<div class="line">  clock_gettime(CLOCK_REALTIME, &amp;current); <span class="comment">//Linux gettime</span></div>
<div class="line">  <span class="keywordtype">double</span> t = (( current.tv_sec - myTimerStart.tv_sec) *1000 +</div>
<div class="line">              ( current.tv_nsec - myTimerStart.tv_nsec)/1000000.0);</div>
<div class="line">  printf( <span class="stringliteral">&quot;time = %lf ms.\n&quot;</span>, t );</div>
</div><!-- fragment --><p>Il faudra modifier les deux lignes suivantes dans le Makefile: </p><pre class="fragment">CFLAGS=-g -Wall -Werror -pedantic -std=c11 -D_POSIX_C_SOURCE=199309
GTKLIBS:=$(shell pkg-config --libs gtk+-3.0) -lrt
</pre><p>Vous ferez un tableau où vous mesurerez les temps d'exécution avec plusieurs images de tailles différentes croisées avec les 4 algos Union-Find possible (Union-Find bête, Union-Find avec union par rang, Union-Find avec compression de chemins, Union-Find avec union par rang et compression de chemin). Vérifiez que le temps d'exécution est quasi-linéaire dans le dernier cas.</p>
<h1><a class="anchor" id="tp-UF-4"></a>
4 Affichage de la couleur moyenne pour chaque région</h1>
<p>Pour faire plus "joli", plutôt que d'afficher une couleur aléatoire pour une région, on va afficher la couleur moyenne de tous les pixels de la même région. Pour nous, couleur moyenne sera les moyennes respectives de chaque canal de couleur (ce qui est un peu faux du point de vue vision humaine). On adapte la fonction précédentes <code>ComposantesConnexes</code> dans sa deuxième partie. On se donne d'abord une structure pour stocker les moyennes de couleur:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">  <span class="keywordtype">double</span> rouge;</div>
<div class="line">  <span class="keywordtype">double</span> vert;</div>
<div class="line">  <span class="keywordtype">double</span> bleu;</div>
<div class="line">  <span class="keywordtype">int</span> nb;</div>
<div class="line">} StatCouleur;</div>
</div><!-- fragment --><p>Ensuite, les points 4), 5) et 6) de l'algorithme précédents sont remplacés par:</p>
<div class="fragment"><div class="line"><span class="comment">// 4) On alloue un tableau de stats de même taille que le nombre de pixels.</span></div>
<div class="line">StatCouleur* stats = (StatCouleur*) malloc( size * <span class="keyword">sizeof</span>( StatCouleur ) );</div>
<div class="line"><span class="comment">// 5) On initialise ses valeurs à 0 (c&#39;est suffisant de ne le faire que pour les représentants/racines)</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// 6) Pour chaque Objet i, on cherche son représentant rep. On récupère son indice j pour ensuite cherchez le bon pixel dans le pixbuf input</span></div>
<div class="line">  guchar* data_input = gdk_pixbuf_get_pixels( pCtxt-&gt;pixbuf_input );</div>
<div class="line">  <span class="keywordflow">for</span> ( i = 0; i &lt; size; ++i )</div>
<div class="line">    {</div>
<div class="line">      Objet* rep = Trouver( &amp;objets[ i ] );</div>
<div class="line">      <span class="keywordtype">long</span> <span class="keywordtype">int</span> j = rep - objets;</div>
<div class="line">      <a class="code hl_struct" href="structPixel.html">Pixel</a>* pixel_src = (<a class="code hl_struct" href="structPixel.html">Pixel</a>*) ( data_input + ( (guchar*) objets[ i ].pixel - data_output ) );</div>
<div class="line">      <span class="comment">// pixel_src est la couleur de ce pixel dans l&#39;image input.</span></div>
<div class="line">      <span class="comment">// On l&#39;ajoute à la stat du représentant j.</span></div>
<div class="line">      stats[ j ].<a class="code hl_variable" href="structPixel.html#a72a901ee374a0d5154d2a35e84fe9723">rouge</a> += pixel_src-&gt;<a class="code hl_variable" href="structPixel.html#a72a901ee374a0d5154d2a35e84fe9723">rouge</a>;</div>
<div class="line">      stats[ j ].vert  += pixel_src-&gt;<a class="code hl_variable" href="structPixel.html#a8c96d5a6c52e8fbe0176ce00e416bf55">vert</a>;</div>
<div class="line">      stats[ j ].bleu  += pixel_src-&gt;<a class="code hl_variable" href="structPixel.html#a2ccfd27a64ef497ec5b6b8d0cfdd5065">bleu</a>;</div>
<div class="line">      stats[ j ].nb += 1; <span class="comment">// On aura donc la somme cumulée</span></div>
<div class="line">    }</div>
<div class="line"><span class="comment">// 7) On reparcourt les pixels pour calculer la moyenne pour chaque représentant en divisant les canaux (rouge, vert, bleu) par le nombre (nb).</span></div>
<div class="line"><span class="comment">// 8) On reparcourt une dernière fois les pixels pour affecter la couleur moyenne du représentant à chaque pixel.</span></div>
<div class="ttc" id="astructPixel_html_a2ccfd27a64ef497ec5b6b8d0cfdd5065"><div class="ttname"><a href="structPixel.html#a2ccfd27a64ef497ec5b6b8d0cfdd5065">Pixel::bleu</a></div><div class="ttdeci">guchar bleu</div><div class="ttdef"><b>Definition</b> <a href="union-find_8c_source.html#l00028">union-find.c:28</a></div></div>
<div class="ttc" id="astructPixel_html_a8c96d5a6c52e8fbe0176ce00e416bf55"><div class="ttname"><a href="structPixel.html#a8c96d5a6c52e8fbe0176ce00e416bf55">Pixel::vert</a></div><div class="ttdeci">guchar vert</div><div class="ttdef"><b>Definition</b> <a href="union-find_8c_source.html#l00027">union-find.c:27</a></div></div>
</div><!-- fragment --><p>Cela vous donne sur l'exemple papillon un affichage similaire à ci-dessous:</p>
<div class="image">
<img src="app-4.gif" alt=""/>
<div class="caption">
Image papillon-express seuillée à T=135, puis dont les composantes connexes ont été extraites et visualisées en couleur moyenne.</div></div>
<h1><a class="anchor" id="tp-UF-5"></a>
5 Connexité floue et découpage en composantes connexes floues</h1>
<p>Le seuillage est bien souvent trop limité. En général on utilise des techniques plus évoluées comme les K-means, la segmentation par minimisation d'une énergie, la segmentation supervisée, etc. Nous proposons ici une petite évolution de l'approche précédente, appelée par certains auteurs la <b>connexité</b> <b>floue</b>.</p>
<p>On utilise les définitions suivantes. Soit \( \rho(x,x&#39;) \) une fonction appelée <b>similitude</b> qui retourne un nombre &gt;= 0 étant donné deux pixels adjacents <em>x</em> et <em>x'</em>. Plus \( \rho \) est proche de 0, plus les pixels <em>x</em> et <em>x'</em> sont similaires. On dit que deux pixels arbitraires <em>x</em> et <em>y</em> (pas forcément adjacents) sont \( \alpha \)-<b>connexes</b> (pour \( \alpha
 \ge 0 \)) si et seulement si il existe un chemin de pixels deux à deux adjacents entre <em>x</em> et <em>y</em> tels que chacun de ces pixels adjacents ont une similitude inférieure ou égale à \( \alpha \).</p>
<p>La relation d' \( \alpha \)-<b>connexité</b> est donc une généralisation de la connexité où deux pixels adjacents devaient être identiques (cf <a class="el" href="tp-UF.html#tp-UF-2">2 Seuillage de l'image</a> et <a class="el" href="tp-UF.html#tp-UF-3">3 Découpage de l'image seuillée en composantes connexes</a>). Maintenant, ils ont seulement besoin d'être similaire. En revanche, l'algorithme Union-Find fonctionnera toujours.</p>
<pre class="fragment">0) elle travaillera directement sur le \c pixbuf_output du contexte, en supposant qu'on a copié l'input dessus avant.
1) Objet* objets = CreerEnsembles( ... ); // elle commence par créer le tableau d'\c Objet.
2) Soit i = 0, le numero de l'objet courant
3a) Pour toute paire d'objets objets[i] et objets[i+1] adjacents horizontalement,
      si ils sont similaires, on fait l'union.
3b) Pour toute paire d'objets objets[i] et objets[i+width] adjacents verticalement,
      si ils sont similaires, on fait l'union.
4) On calcule la couleur moyenne de chaque région que l'on donne au représentant.
5) On affecte à chaque pixel la couleur moyenne de son représentant.
6) on force le réaffichage pour voir le résultat.
</pre><p>On peut définir plein de fonctions "similitude". On va en créer une qui se base sur la représentation TSV des couleurs ou Teinte / Saturation / Valeur (<a href="http://fr.wikipedia.org/wiki/Teinte_Saturation_Valeur">http://fr.wikipedia.org/wiki/Teinte_Saturation_Valeur</a>). Cette représentation est un peu plus représentative de notre perception des couleurs (sans être idéale). On représentera une couleur hsv avec le type:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">  <span class="keywordtype">int</span> t;    <span class="comment">// teinte comme angle en degrés</span></div>
<div class="line">  <span class="keywordtype">double</span> s; <span class="comment">// saturation comme nombre entre 0 et 1</span></div>
<div class="line">  <span class="keywordtype">double</span> v; <span class="comment">// valeur ou brillance comme nombre entre 0 et 1</span></div>
<div class="line">} TSVCouleur;</div>
</div><!-- fragment --><p>En vous inspirant des formules données sur la page wikipedia, vous écrirez une fonction <code>tsv</code> ainsi de prototype</p>
<div class="fragment"><div class="line">TSVCouleur tsv( <a class="code hl_struct" href="structPixel.html">Pixel</a>* pixel );</div>
</div><!-- fragment --><p>La similitude sera définie comme une distance pondérées entre teintes, saturations et valeurs des deux pixels: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> similitude( <a class="code hl_struct" href="structPixel.html">Pixel</a>* p1, <a class="code hl_struct" href="structPixel.html">Pixel</a>* p2 ) </div>
<div class="line">{</div>
<div class="line">  TSVCouleur tsv1 = tsv( p1 );</div>
<div class="line">  TSVCouleur tsv2 = tsv( p2 );</div>
<div class="line">  <span class="keywordtype">int</span> diff = tsv1.t - tsv2.t;</div>
<div class="line">  <span class="keywordflow">while</span> ( diff &gt;= 180 ) diff -= 360;</div>
<div class="line">  <span class="keywordflow">while</span> ( diff &lt;= -180 ) diff += 360;</div>
<div class="line">  <span class="keywordflow">return</span> abs( (<span class="keywordtype">double</span>) diff ) + 5.0 * abs( tsv1.s - tsv2.s ) + 10.0 * abs( tsv1.v - tsv2.v );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Adaptez donc le code précédent de <code>ComposantesConnexesEnCouleurMoyenne</code> pour réaliser cette segmentation. Sur les images <code>papillon-express</code> et <code>kowloon-1000</code>, cela donne les résultats ci-dessous.</p>
<div class="image">
<img src="app-5.gif" alt=""/>
<div class="caption">
Image papillon-express dont les composantes connexes ont été extraites par similitude &lt;= 54 et visualisées en couleur moyenne.</div></div>
<div class="image">
<img src="app-5-bis.gif" alt=""/>
<div class="caption">
Image kowloon-1000 dont les composantes connexes ont été extraites par similitude &lt;= 83 et visualisées en couleur moyenne.</div></div>
<p>Vous pourrez bien sûr essayer d'autres fonctions similitudes et d'autres images.</p>
<dl class="section note"><dt>Note</dt><dd>Faites attention dans les conversions RGB et TSV avec la manipulation des doubles et des entiers en même temps.</dd></dl>
<h1><a class="anchor" id="tp-UF-6"></a>
6. Remise du tp</h1>
<ul>
<li>Ce TP peut être fait par binôme.</li>
<li>vous déposerez votre travail à la fin de la séance via via <a href="http://www.lama.univ-savoie.fr/TPLab">TPLab</a>. Il faudra une archive nommée TP1-[votre ou vos nom(s)] contenant tous les fichiers sources, entêtes, makefile. Vous ajouterez un petit README.txt indiquant les questions traitées complètement et celles traitées partiellement.</li>
<li>Vous m'enverrez une version finale de votre TP au plus tard une semaine après via <a href="http://www.lama.univ-savoie.fr/TPLab">TPLab</a>. Il faudra une archive nommée TP1-[votre ou vos nom(s)] contenant tous les fichiers sources, entêtes, makefile. Vous me ferez un petit <b>compte-rendu</b> précisant l'état d'avancement (ce qui marche, ce qui marche à moitié, et ce qui ne marche pas), qui donnera un tableau des temps de calcul de Union-Find, et qui pourra montrer quelques exemples de segmentation.</li>
<li>Vous pouvez éventuellement mettre des exemples de segmentation dans votre compte-rendu.</li>
<li>Bien entendu, il faut que vos programmes compilent sous Linux. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
